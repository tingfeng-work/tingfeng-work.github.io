---
title: leetcode 通过先序 / 中序 / 后序遍历构造二叉树（
date: 2026-01-03 13:00
author: tingfeng
categories:
  - 算法
  - 二叉树
  - 递归
tags:
  - 递归
  - 二叉树
  - 先序、中序、后序
  - 由遍历序列生成二叉树
toc: true
toc_number: true
---

**刷题范围**

**基础题目**

98.验证二叉搜索树

**扩展题目**

- 二叉搜索树中的众数
- 二叉搜索树中第 K 小的元素
- 二叉搜索子树的最大键值和
- 从前序与中序遍历序列构造二叉树（重点）
- 从中序与后序遍历序列构造二叉树
- 根据前序和后序遍历构造二叉树
- 删点成林

这些题目从 **BST 的性质利用**，逐步过渡到 **通过遍历序列反向构造树结构**，对理解递归非常有帮助。

------

## BST 性质在遍历中的典型应用

### 501. 二叉搜索树中的众数

**最直观的想法**：

- 用 `HashMap` 统计每个值出现次数
- 再遍历 map 找最大值

但这种方式 **没有利用 BST 的任何性质**。

------

### 利用 BST 的优化思路

BST 的一个关键性质是：

> **中序遍历结果是一个非递减（有序）序列**

因此：

- 相同值一定是 **连续出现的**
- 众数一定出现在连续相同节点中

#### 实现思路

- 使用中序遍历
- 维护：
  - `pre`：前一个节点值
  - `cnt`：当前值连续出现次数
  - `maxCnt`：历史最大频次
  - `ans`：答案集合

#### 关键细节

- 当前值 == pre → `cnt++`
- 否则 → `cnt = 1`
- 当 `cnt == maxCnt` → 加入答案
- 当 `cnt > maxCnt` → **清空答案 + 更新 maxCnt**

这一步让我意识到：**题目给出二叉搜索树，大概率要用到中序遍历。**

------

### 230. 二叉搜索树中第 K 小的元素

这是一个非常“教科书级”的题目：

- BST 中序遍历 = 递增序列
- 第 K 小元素 = 中序遍历第 K 个访问的节点

**直接中序遍历即可**，不需要额外结构。

------

### 1373. 二叉搜索子树的最大键值和

这道题开始明显体现“遍历方式选择”的重要性。

#### 问题拆解

- 需要判断：

  > 以当前节点为根的子树是否是 BST

- 如果是：

  - 计算其键值和
  - 与全局最大值比较

------

### 为什么用后序遍历？

- 判断 BST 需要 **左右子树的信息**
- 键值和也是 **由左右子树向上汇总**

这是一个典型的 **自底向上问题**，非常适合后序遍历。

#### 需要返回的信息

- 子树最小值 / 最大值
- 子树键值和

#### 特殊情况

- 节点值为负数时，允许返回 `0`，因为空树也是 BST，其“最大和”为 0

------

## 通过遍历序列构造二叉树（核心部分）

### 105. 从前序与中序遍历序列构造二叉树（重点）

这是今天收获最大的题目之一。

#### 一开始的困难

- 手写在纸上非常直观
- 但转成代码时容易“无从下手”

------

### 核心思路（和手写过程完全一致）

1. **前序遍历的第一个元素一定是根节点**
2. 在中序遍历中找到该根节点的位置
3. 中序中：
   - 左边部分 → 左子树
   - 右边部分 → 右子树
4. 对左右子数组递归执行同样的过程

本质是：**不断确定根节点，然后把问题缩小到左右子数组**

------

### 优化点

- 用 `HashMap` 预处理中序遍历中： **“节点值 → 下标”**
- 将查找根节点位置从 `O(n)` 降为 `O(1)`

------

### 106. 从中序与后序遍历序列构造二叉树

这道题与 105 非常类似：

- 后序遍历的 **最后一个元素是根节点**
- 在中序遍历中划分左右子树
- 递归构造

进一步加深了我对： **“遍历序列 + 根节点定位 + 子数组递归”** 这一套路的理解。

------

### 889. 根据前序和后序遍历构造二叉树

这道题的变化点在于：

- 已知根节点
- 但**无法唯一确定左右子树的边界**

题目允许：

> **返回任意一种满足条件的二叉树**

------

### 关键约定思路

- 若当前节点不是叶子节点
- 则：
  - 前序序列中下一个节点（index + 1）
  - 一定可以视为左子树的根

基于这个约定：

- 在后序中找到该左子树根的位置
- 确定左子树大小
- 再递归构造左右子树

 这道题让我意识到： **不是所有构造题都要求“唯一解”，要学会读题，**自己给出一些不影响答案的假设。

------

### 1110. 删点成林

这是一道遍历顺序选择非常典型的题目。

#### 为什么必须用后序遍历？

- 如果用先序：
  - 当前节点删掉后
  - 无法再访问左右子树
- 如果用中序：
  - 右子树访问会受影响

**后序遍历**：

- 先处理左右子树
- 再决定是否删除当前节点
- 若删除：将左右子树加入结果集

------

## 今日学习总结（方法论层面）

今天的题目虽然多，但核心收获非常集中：

1. **BST 题目，优先考虑中序遍历**
2. 构造二叉树的题目，本质是：
   - 找根
   - 划分左右子树
   - 在子数组中递归
3. 后序遍历适合：
   - 需要子树返回信息
   - 删除 / 汇总 / 判断类问题
4. 写递归时要学会：
   - **抓大放小**
   - 先想整体递归关系
   - 再补边界条件与细节
5. 如果题目已经限定“二叉搜索树”，**一定要考虑用 BST 的性质，否则条件就显得多余**

今天让我最深刻的一点是：

> **很多二叉树难题，并不是逻辑复杂，而是“把纸上推演的过程，忠实地翻译成递归代码”。**

只要：

- 根节点是谁
- 什么时候递
- 什么时候归
- 边界条件是什么

想清楚了，代码自然就出来了。

## 相关代码

本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。