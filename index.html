<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>廷风的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="记录 Java 后端学习与项目实践的技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="廷风的技术博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="廷风的技术博客">
<meta property="og:description" content="记录 Java 后端学习与项目实践的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tingfeng Li">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="廷风的技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">廷风的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java 后端开发</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-backend/ssm/springboot/2026-1-11-springboot-day03 " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T16:00:00.000Z" itemprop="datePublished">2026-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/">Spring Boot 配置与测试实战复盘</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文基于一次完整的学习与踩坑过程，系统复盘 <strong>配置绑定、宽松绑定、属性校验、测试配置覆盖、Web 测试</strong> 等关键机制，重点回答一个问题：<br> <strong>Spring Boot 为什么要这样设计？我在工程中应该如何正确使用？</strong></p>
</blockquote>
<h2 id="一、Spring-Boot-热部署的本质：不是“热更新”，而是-ClassLoader-重启"><a href="#一、Spring-Boot-热部署的本质：不是“热更新”，而是-ClassLoader-重启" class="headerlink" title="一、Spring Boot 热部署的本质：不是“热更新”，而是 ClassLoader 重启"></a>一、Spring Boot 热部署的本质：不是“热更新”，而是 ClassLoader 重启</h2><p>在传统 Java Web 项目中，热部署通常由外置 Web 容器完成；<br>而 Spring Boot 采用 <strong>内嵌容器</strong>，服务器本身运行在 Spring 容器中，因此热部署的实现方式完全不同。</p>
<h3 id="devtools-的核心原理"><a href="#devtools-的核心原理" class="headerlink" title="devtools 的核心原理"></a>devtools 的核心原理</h3><p>Spring Boot 的热部署依赖 <code>spring-boot-devtools</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>其核心并不是 JVM 层面的“代码热替换”，而是 <strong>类加载器分层重启</strong>：</p>
<ul>
<li><strong>base ClassLoader</strong>：加载第三方依赖（jar 包），只加载一次</li>
<li><strong>restart ClassLoader</strong>：加载业务代码，修改后可重新加载</li>
</ul>
<p>热部署的本质是：<strong>重启 restart ClassLoader，而不是整个 JVM</strong>。</p>
<h3 id="为什么线上环境必须关闭热部署？"><a href="#为什么线上环境必须关闭热部署？" class="headerlink" title="为什么线上环境必须关闭热部署？"></a>为什么线上环境必须关闭热部署？</h3><ul>
<li>ClassLoader 重启可能带来状态不一致</li>
<li>与线上稳定性目标冲突</li>
<li>devtools 本身只服务于开发阶段</li>
<li>额外的开销，线上改不了源码，所以也不会启动热部署</li>
</ul>
<p>因此，<strong>热部署是开发工具</strong>。</p>
<hr>
<h2 id="二、-ConfigurationProperties：配置绑定的正确方式"><a href="#二、-ConfigurationProperties：配置绑定的正确方式" class="headerlink" title="二、@ConfigurationProperties：配置绑定的正确方式"></a>二、@ConfigurationProperties：配置绑定的正确方式</h2><h3 id="为什么不推荐大量使用-Value？"><a href="#为什么不推荐大量使用-Value？" class="headerlink" title="为什么不推荐大量使用 @Value？"></a>为什么不推荐大量使用 @Value？</h3><p><code>@Value</code> 属于“点对点注入”，在配置复杂时会带来问题：</p>
<ul>
<li>类型不安全</li>
<li>分散、不可维护</li>
<li>无法集中校验</li>
</ul>
<p>相比之下，<code>@ConfigurationProperties</code> 提供了 <strong>结构化配置绑定</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">servers:</span><br><span class="line">  ip-address: 192.168.0.1</span><br><span class="line">  port: 2345</span><br><span class="line">  timeout: 3h</span><br><span class="line"></span><br><span class="line">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="line">public class ServerConfig &#123;</span><br><span class="line">    private String ipAddress;</span><br><span class="line">    private int port;</span><br><span class="line">    private Duration timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、宽松绑定-≠-配置名可以随便写（第一个踩坑点）"><a href="#三、宽松绑定-≠-配置名可以随便写（第一个踩坑点）" class="headerlink" title="三、宽松绑定 ≠ 配置名可以随便写（第一个踩坑点）"></a>三、宽松绑定 ≠ 配置名可以随便写（第一个踩坑点）</h2><h3 id="我最初的误解"><a href="#我最初的误解" class="headerlink" title="我最初的误解"></a>我最初的误解</h3><blockquote>
<p>Spring Boot 配置支持宽松绑定，忽略大小写、中划线、下划线<br> 那是不是 <code>dataSource</code>、<code>data_source</code>、<code>data-source</code> 都可以？</p>
</blockquote>
<h3 id="实际踩坑现象"><a href="#实际踩坑现象" class="headerlink" title="实际踩坑现象"></a>实际踩坑现象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataSource:</span><br><span class="line">  url: jdbc:mysql://...</span><br></pre></td></tr></table></figure>

<p>启动时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Configuration property name &#x27;dataSource&#x27; is not valid</span><br><span class="line">Canonical names should be kebab-case</span><br></pre></td></tr></table></figure>

<h3 id="3-3-正确理解（非常重要）"><a href="#3-3-正确理解（非常重要）" class="headerlink" title="3.3 正确理解（非常重要）"></a>3.3 正确理解（非常重要）</h3><ul>
<li><strong>宽松绑定发生在：配置项 → Java 字段</strong></li>
<li><strong>但配置 key 本身必须是合法的 canonical 名称</strong></li>
</ul>
<p>正确写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  url: ...</span><br></pre></td></tr></table></figure>

<p>或官方标准写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>宽松绑定解决的是“如何映射”，不是“命名是否合法”。</p>
</blockquote>
<hr>
<h2 id="四、-Validated-是一把“双刃剑”（第二个踩坑点）"><a href="#四、-Validated-是一把“双刃剑”（第二个踩坑点）" class="headerlink" title="四、@Validated 是一把“双刃剑”（第二个踩坑点）"></a>四、@Validated 是一把“双刃剑”（第二个踩坑点）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="line">@Validated</span><br><span class="line">public class ServerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Min(1)</span><br><span class="line">    @Max(1234)</span><br><span class="line">    private int port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在生产环境中的价值"><a href="#在生产环境中的价值" class="headerlink" title="在生产环境中的价值"></a>在生产环境中的价值</h3><ul>
<li>配置非法 → 容器启动失败</li>
<li>fail-fast，避免线上事故</li>
<li>非常符合工程安全性要求</li>
</ul>
<h3 id="在测试环境中被“反杀”"><a href="#在测试环境中被“反杀”" class="headerlink" title="在测试环境中被“反杀”"></a>在测试环境中被“反杀”</h3><p>测试中尝试覆盖配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(properties = &#123;</span><br><span class="line">    &quot;servers.port=8888&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果直接启动失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstraintViolationException</span><br></pre></td></tr></table></figure>

<p>原因：<br> <strong>8888 超出了 @Max(1234)</strong></p>
<h3 id="正确的工程姿势"><a href="#正确的工程姿势" class="headerlink" title="正确的工程姿势"></a>正确的工程姿势</h3><ul>
<li><strong>测试只覆盖 <code>servers.port</code>（Web 端口）</strong></li>
<li>业务配置仍使用合法值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(properties = &#123;</span><br><span class="line">    &quot;servers.port=8888&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试不是绕过校验，而是在合法范围内模拟不同环境。</strong></p>
</blockquote>
<hr>
<h2 id="六、Web-层测试：为什么我选择-MockMvc"><a href="#六、Web-层测试：为什么我选择-MockMvc" class="headerlink" title="六、Web 层测试：为什么我选择 MockMvc"></a>六、Web 层测试：为什么我选择 MockMvc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">class WebTest &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="MockMvc-的优势"><a href="#MockMvc-的优势" class="headerlink" title="MockMvc 的优势"></a>MockMvc 的优势</h3><ul>
<li>不需要真实端口</li>
<li>不依赖网络</li>
<li>执行速度快</li>
<li>适合 CI &#x2F; 自动化测试</li>
</ul>
<h3 id="JSON-断言的工程选择"><a href="#JSON-断言的工程选择" class="headerlink" title="JSON 断言的工程选择"></a>JSON 断言的工程选择</h3><ul>
<li>接口稳定：<code>content().json()</code></li>
<li>接口可能演进：<code>jsonPath()</code></li>
</ul>
<hr>
<h2 id="七、我从这次-Spring-Boot-学习中总结的经验"><a href="#七、我从这次-Spring-Boot-学习中总结的经验" class="headerlink" title="七、我从这次 Spring Boot 学习中总结的经验"></a>七、我从这次 Spring Boot 学习中总结的经验</h2><ol>
<li><strong>配置名是否合法，比是否能绑定更早发生</strong></li>
<li>宽松绑定只解决映射问题，不解决命名问题</li>
<li><code>@Validated</code> 是 fail-fast，不是调试工具</li>
<li>测试配置覆盖必须遵守业务约束</li>
<li>Web 测试优先 MockMvc，而不是启动真实端口</li>
</ol>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/" data-id="cmkbbdw2f00585w8tgv2m8wgn" data-title="Spring Boot 配置与测试实战复盘" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T06:30:00.000Z" itemprop="datePublished">2026-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/">从回溯到记忆化搜索到递推：动态规划巩固练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>今天的练习并不是学习新的 DP 模板，而是<strong>围绕两个最经典的模型：打家劫舍 与 爬楼梯，去做“变形题”的识别与迁移</strong>。</p>
<p>通过这一组题目的训练，我逐渐体会到：</p>
<p>动态规划的关键不在于记公式，而在于识别“本质模型”，并主动把陌生题目转化为熟悉结构。</p>
</blockquote>
<p><strong>基础题目</strong>：198. 打家劫舍</p>
<p><strong>打家劫舍模型变形</strong></p>
<ul>
<li><strong>740. 删除并获得点数</strong></li>
</ul>
<p><strong>爬楼梯模型变形（方案数）</strong></p>
<ul>
<li><strong>2466. 统计构造好字符串的方案数</strong></li>
<li><strong>377. 组合总和 Ⅳ</strong></li>
<li><strong>2266. 统计打字方案数</strong></li>
</ul>
<p><strong>经典二维 DP</strong></p>
<ul>
<li><strong>64. 最小路径和</strong></li>
</ul>
<hr>
<h2 id="核心模型回顾"><a href="#核心模型回顾" class="headerlink" title="核心模型回顾"></a>核心模型回顾</h2><p>在进入具体题目之前，先明确两个核心模型的“<strong>本质约束</strong>”。</p>
<h3 id="1-打家劫舍模型的本质"><a href="#1-打家劫舍模型的本质" class="headerlink" title="1. 打家劫舍模型的本质"></a>1. 打家劫舍模型的本质</h3><ul>
<li>每个元素都有「选 &#x2F; 不选」两种状态</li>
<li><strong>一旦选择某个元素，就会限制相邻元素不能被选择</strong></li>
<li>状态转移通常是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i - 1], dp[i - 2] + value[i])</span><br></pre></td></tr></table></figure>

<p>重点不在“房子”，而在<strong>相邻约束</strong></p>
<hr>
<h3 id="2-爬楼梯模型的本质"><a href="#2-爬楼梯模型的本质" class="headerlink" title="2. 爬楼梯模型的本质"></a>2. 爬楼梯模型的本质</h3><ul>
<li>本质是一个<strong>排列问题</strong></li>
<li><strong>顺序不同 &#x3D; 不同方案</strong></li>
<li>给定一个目标值 <code>target</code></li>
<li>每一步可以选择若干“步长”，问总方案数</li>
</ul>
<p>只要是：</p>
<ul>
<li>「目标值固定」</li>
<li>「每一步可以选择若干选项」</li>
<li>「顺序敏感」</li>
</ul>
<p>都可以往爬楼梯模型上靠</p>
<hr>
<h2 id="结合具体题目分析"><a href="#结合具体题目分析" class="headerlink" title="结合具体题目分析"></a>结合具体题目分析</h2><h3 id="740-删除并获得点数-——-打家劫舍的值域改造"><a href="#740-删除并获得点数-——-打家劫舍的值域改造" class="headerlink" title="740. 删除并获得点数 —— 打家劫舍的值域改造"></a>740. 删除并获得点数 —— 打家劫舍的值域改造</h3><p><strong>题意简述</strong>：<br> 选择一个数 <code>nums[i]</code>，可以获得 <code>nums[i]</code> 的点数，但会删除所有值为 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p>
<h4 id="思路转化"><a href="#思路转化" class="headerlink" title="思路转化"></a>思路转化</h4><p>这道题的难点在于：</p>
<ul>
<li>原数组中，相同数字可能出现多次</li>
<li>删除的是“值相邻”，而不是“位置相邻”</li>
</ul>
<p><strong>关键一步：构造打家劫舍的条件</strong></p>
<p>将数组转为<strong>值域数组</strong></p>
<ul>
<li><code>sums[x]</code>：表示值为 <code>x</code> 的所有元素之和</li>
<li>例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [2,2,3,3,3,4]</span><br><span class="line">sums = [0,0,4,9,4]</span><br></pre></td></tr></table></figure>

<p>此时问题变成：</p>
<blockquote>
<p>在 <code>sums</code> 数组中，选择若干不相邻的元素，使得总和最大</p>
</blockquote>
<p><strong>完全等价于打家劫舍</strong></p>
<hr>
<h3 id="2466-统计构造好字符串的方案数-——-爬楼梯模型"><a href="#2466-统计构造好字符串的方案数-——-爬楼梯模型" class="headerlink" title="2466. 统计构造好字符串的方案数 —— 爬楼梯模型"></a>2466. 统计构造好字符串的方案数 —— 爬楼梯模型</h3><p>这道题表面是字符串问题，但本质非常清晰：</p>
<ul>
<li>当前字符串长度 &#x3D; 已爬的台阶数</li>
<li>每一步可以：<ul>
<li>增加 <code>zero</code> 个字符</li>
<li>或增加 <code>one</code> 个字符</li>
</ul>
</li>
<li>问：长度在 <code>[low, high]</code> 区间内的方案总数</li>
</ul>
<p><strong>这是标准的爬楼梯模型</strong></p>
<ul>
<li><code>dp[i]</code>：构造长度为 <code>i</code> 的方案数</li>
<li>每次从 <code>i - zero</code> 或 <code>i - one</code> 转移而来</li>
</ul>
<hr>
<h3 id="377-组合总和-Ⅳ-——-爬楼梯-顺序敏感"><a href="#377-组合总和-Ⅳ-——-爬楼梯-顺序敏感" class="headerlink" title="377. 组合总和 Ⅳ —— 爬楼梯 + 顺序敏感"></a>377. 组合总和 Ⅳ —— 爬楼梯 + 顺序敏感</h3><p>这道题非常具有代表性：</p>
<ul>
<li>给定 <code>nums</code></li>
<li>目标和 <code>target</code></li>
<li><strong>不同顺序算不同方案</strong></li>
</ul>
<h4 id="本质理解"><a href="#本质理解" class="headerlink" title="本质理解"></a>本质理解</h4><p>可以这样理解：</p>
<blockquote>
<p>爬 <code>target</code> 阶楼梯<br> 每次可以爬 <code>nums[i]</code> 阶<br> 问一共有多少种爬法</p>
</blockquote>
<p>顺序不同 → 不同路径</p>
<hr>
<h3 id="2266-统计打字方案数-——-分组-爬楼梯"><a href="#2266-统计打字方案数-——-分组-爬楼梯" class="headerlink" title="2266. 统计打字方案数 —— 分组 + 爬楼梯"></a>2266. 统计打字方案数 —— 分组 + 爬楼梯</h3><p>这道题本身规则较复杂，但从 DP 角度可以拆解为：</p>
<ol>
<li><strong>按连续相同数字分组</strong></li>
<li>每一组内部：<ul>
<li>是一个「爬楼梯问题」</li>
<li>不同按键允许的最大步长不同</li>
</ul>
</li>
<li><strong>最终答案 &#x3D; 各组方案数相乘</strong></li>
</ol>
<p>这是一个非常典型的：</p>
<blockquote>
<p><strong>局部 DP + 全局组合</strong></p>
</blockquote>
<hr>
<h3 id="64-最小路径和-——-经典二维-DP"><a href="#64-最小路径和-——-经典二维-DP" class="headerlink" title="64. 最小路径和 —— 经典二维 DP"></a>64. 最小路径和 —— 经典二维 DP</h3><p>这是标准的网格 DP：</p>
<ul>
<li><code>dp[i][j]</code> 表示到 <code>(i, j)</code> 的最小路径和</li>
<li>当前状态只依赖：<ul>
<li>上方 <code>(i - 1, j)</code></li>
<li>左方 <code>(i, j - 1)</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</span><br></pre></td></tr></table></figure>

<p>没有变形，但非常适合作为 DP 基础模板反复巩固</p>
<hr>
<h2 id="心得与方法论总结"><a href="#心得与方法论总结" class="headerlink" title="心得与方法论总结"></a>心得与方法论总结</h2><h3 id="1-打家劫舍-≠-偷房子"><a href="#1-打家劫舍-≠-偷房子" class="headerlink" title="1. 打家劫舍 ≠ 偷房子"></a>1. 打家劫舍 ≠ 偷房子</h3><p>打家劫舍的真正核心是：</p>
<blockquote>
<p><strong>选择一个元素，会导致“相邻状态失效”</strong></p>
</blockquote>
<ul>
<li>740 题中，相邻的是「值」</li>
<li>所以我们主动<strong>构造值域数组</strong>，人为制造相邻关系</li>
</ul>
<p><strong>没有条件，就创造条件</strong></p>
<hr>
<h3 id="2-爬楼梯-顺序敏感的方案计数"><a href="#2-爬楼梯-顺序敏感的方案计数" class="headerlink" title="2. 爬楼梯 &#x3D; 顺序敏感的方案计数"></a>2. 爬楼梯 &#x3D; 顺序敏感的方案计数</h3><p>爬楼梯模型特别适合解决：</p>
<ul>
<li>方案数问题</li>
<li>和 &#x2F; 长度固定的问题</li>
<li>顺序不同算不同的情况</li>
</ul>
<p>例如：</p>
<ul>
<li>字符串构造</li>
<li>数字组合</li>
<li>步数累加</li>
</ul>
<p>把「目标值」当成台阶数，把「选择」当成一步能走的距离</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过今天这一组题目的训练，我对动态规划有了一个更重要的认知转变：</p>
<blockquote>
<p><strong>DP 的关键不是记住状态转移方程，而是识别题目的“原型模型”。</strong></p>
</blockquote>
<ul>
<li>看到「相邻不能同时选」 → 想打家劫舍</li>
<li>看到「目标固定 + 多种选择 + 顺序敏感」 → 想爬楼梯</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/" data-id="cmkbbdw2c004t5w8t5oj6449q" data-title="从回溯到记忆化搜索到递推：动态规划巩固练习" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-11-dynamicprogramming" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/" class="article-date">
  <time class="dt-published" datetime="2026-01-11T05:30:00.000Z" itemprop="datePublished">2026-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/">动态规划：从回溯到记忆化搜索，再到递推</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><strong>核心思想</strong>：当前状态的最优解，来源于之前状态的最优解</p>
</blockquote>
<p><strong>基础题目</strong>：198. 打家劫舍</p>
<p><strong>扩展题目</strong>：</p>
<ul>
<li>爬楼梯</li>
<li>使用最小花费爬楼梯</li>
<li>爬楼梯 II</li>
<li>打家劫舍 II</li>
</ul>
<hr>
<h2 id="一、什么是动态规划？"><a href="#一、什么是动态规划？" class="headerlink" title="一、什么是动态规划？"></a>一、什么是动态规划？</h2><p>很多人第一次接触动态规划，都会被「状态转移方程」劝退。但实际上，<strong>动态规划并不是一种“新算法”，而是回溯的一种系统性优化</strong>。</p>
<blockquote>
<p>动态规划 &#x3D; 回溯 + 去重 + 自底向上</p>
</blockquote>
<p>理解动态规划，最自然的一条路径是：</p>
<blockquote>
<p><strong>回溯 → 记忆化搜索 → 递推（DP）</strong></p>
</blockquote>
<p>下面我们通过「打家劫舍」这个经典问题，完整走一遍这条路径。</p>
<hr>
<h2 id="二、从回溯开始：暴力-DFS-的本质"><a href="#二、从回溯开始：暴力-DFS-的本质" class="headerlink" title="二、从回溯开始：暴力 DFS 的本质"></a>二、从回溯开始：暴力 DFS 的本质</h2><p>以 <strong>198. 打家劫舍</strong> 为例：</p>
<ul>
<li>每一间房子：<strong>选 or 不选</strong></li>
<li>不能选相邻的房子</li>
</ul>
<p>我们从“最后一个房子”开始思考，定义：</p>
<blockquote>
<p><strong>dfs(i)</strong>：考虑前 <code>i</code> 个房子，能偷到的最大金额</p>
</blockquote>
<p>那么对于第 <code>i</code> 个房子：</p>
<ul>
<li>不偷：最大金额 &#x3D; <code>dfs(i - 1)</code></li>
<li>偷：最大金额 &#x3D; <code>dfs(i - 2) + nums[i]</code></li>
</ul>
<p>得到递归公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i) = max(dfs(i - 1), dfs(i - 2) + nums[i])</span><br></pre></td></tr></table></figure>

<p>但问题也随之而来：<strong>大量重复计算</strong>。</p>
<p><img src="/assets/1.png" alt="1"></p>
<p>可以看到：</p>
<ul>
<li><code>dfs(2)</code> 被计算了多次</li>
<li><code>dfs(1)</code> 被计算了更多次</li>
</ul>
<p>这正是 <strong>动态规划要解决的核心问题：重复子问题</strong></p>
<hr>
<h2 id="三、记忆化搜索：给回溯加“缓存”"><a href="#三、记忆化搜索：给回溯加“缓存”" class="headerlink" title="三、记忆化搜索：给回溯加“缓存”"></a>三、记忆化搜索：给回溯加“缓存”</h2><p>回溯的问题不在于“递归”，而在于 <strong>重复递归</strong>。</p>
<p>解决方法也很直接：</p>
<blockquote>
<p><strong>算过的结果，存下来，下次直接用</strong></p>
</blockquote>
<p>这就是 <strong>记忆化搜索（Memoization）</strong>。</p>
<h3 id="Java-示例"><a href="#Java-示例" class="headerlink" title="Java 示例"></a>Java 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int dfs(int i, int[] nums, int[] cache) &#123;</span><br><span class="line">    if (i &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cache[i] != -1) &#123;</span><br><span class="line">    	// 之前计算过,直接返回</span><br><span class="line">        return cache[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 之前没算过，将当前结果缓存</span><br><span class="line">    cache[i] = Math.max(</span><br><span class="line">        dfs(i - 1, nums, cache),</span><br><span class="line">        dfs(i - 2, nums, cache) + nums[i]</span><br><span class="line">    );</span><br><span class="line">    return cache[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li>时间复杂度：从指数级 ➜ <strong>O(n)</strong></li>
<li>但仍然有：<ul>
<li>递归栈空间</li>
<li>cache 数组空间</li>
</ul>
</li>
</ul>
<p>接下来就是最后一步优化空间复杂度：<strong>递推</strong></p>
<hr>
<h2 id="四、从记忆化搜索到递推（真正的-DP）"><a href="#四、从记忆化搜索到递推（真正的-DP）" class="headerlink" title="四、从记忆化搜索到递推（真正的 DP）"></a>四、从记忆化搜索到递推（真正的 DP）</h2><p>观察记忆化搜索中的递归关系：</p>
<ul>
<li><code>dfs(2)</code> 依赖 <code>dfs(1)</code> 和 <code>dfs(0)</code></li>
<li><code>dfs(3)</code> 依赖 <code>dfs(2)</code> 和 <code>dfs(1)</code></li>
<li>……</li>
</ul>
<p>这说明：</p>
<blockquote>
<p><strong>状态之间的依赖顺序是确定的</strong></p>
</blockquote>
<p>既然如此，我们完全可以：</p>
<ul>
<li>不再“递”</li>
<li>只保留“归”</li>
<li><strong>从小到大计算每一个状态</strong></li>
</ul>
<h3 id="递推（DP）的三要素"><a href="#递推（DP）的三要素" class="headerlink" title="递推（DP）的三要素"></a>递推（DP）的三要素</h3><p>从记忆化搜索到递推，本质上完成了三件事：</p>
<ol>
<li><strong>状态数组（dp）</strong>：<code>dp[i]</code> 记录 <code>dfs(i)</code> 的结果</li>
<li><strong>循环代替递归</strong>：从 <code>i = 0</code> 推到 <code>n</code></li>
<li><strong>初始化代替递归边界</strong>：<code>dp[0]</code>、<code>dp[1]</code> 对应原来的递归边界</li>
</ol>
<h3 id="为什么叫“递推”？"><a href="#为什么叫“递推”？" class="headerlink" title="为什么叫“递推”？"></a>为什么叫“递推”？</h3><blockquote>
<p>因为当前状态是 <strong>由之前状态推导出来的</strong></p>
</blockquote>
<p>在打家劫舍中：</p>
<ul>
<li>偷到第 <code>i</code> 间房子的最大金额<br> <strong>不是只由第 <code>i</code> 间房子决定的</strong></li>
<li>而是由：<ul>
<li>第 <code>i-1</code> 间房子的最优解</li>
<li>第 <code>i-2</code> 间房子的最优解<br> 共同决定</li>
</ul>
</li>
</ul>
<p>这正是动态规划中最核心的结构：</p>
<blockquote>
<p><strong>最优子结构</strong></p>
</blockquote>
<hr>
<h2 id="五、空间优化：从-O-n-到-O-1"><a href="#五、空间优化：从-O-n-到-O-1" class="headerlink" title="五、空间优化：从 O(n) 到 O(1)"></a>五、空间优化：从 O(n) 到 O(1)</h2><p>在打家劫舍中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] 只依赖 dp[i-1] 和 dp[i-2]</span><br></pre></td></tr></table></figure>

<p>因此：</p>
<ul>
<li>不需要完整 dp 数组</li>
<li>只需要保存「前两个状态」</li>
</ul>
<p> 空间复杂度可进一步优化为 <strong>O(1)</strong></p>
<hr>
<h2 id="六、结合具体题目总结-DP-模型"><a href="#六、结合具体题目总结-DP-模型" class="headerlink" title="六、结合具体题目总结 DP 模型"></a>六、结合具体题目总结 DP 模型</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><ul>
<li><strong>状态定义</strong>：<code>dp[i]</code> &#x3D; 爬到第 i 阶的方法数</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化</strong>：<ul>
<li><code>dp[0] = 1</code></li>
<li><code>dp[1] = 1</code></li>
</ul>
</li>
<li><strong>答案</strong>：<code>dp[n]</code></li>
</ul>
<p>本质：<strong>斐波那契数列</strong></p>
<hr>
<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><ul>
<li><strong>状态定义</strong>：<code>dp[i]</code> &#x3D; 到达第 i 阶的最小花费</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i - 1] + cost[i - 1],</span><br><span class="line">            dp[i - 2] + cost[i - 2])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化</strong>：<ul>
<li><code>dp[0] = 0</code></li>
<li><code>dp[1] = 0</code></li>
</ul>
</li>
<li><strong>答案</strong>：<code>dp[n]</code></li>
</ul>
<p>特点： <strong>不是计数，而是最小值优化</strong></p>
<hr>
<h3 id="3693-爬楼梯-II"><a href="#3693-爬楼梯-II" class="headerlink" title="3693. 爬楼梯 II"></a>3693. 爬楼梯 II</h3><ul>
<li>一次可以跳 <strong>1 &#x2F; 2 &#x2F; 3</strong> 阶</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]</span><br></pre></td></tr></table></figure>

<p>本质变化只有：</p>
<blockquote>
<p><strong>当前状态依赖的“历史状态数量”变多了</strong>，计算 cost 的方式不同了</p>
</blockquote>
<hr>
<h3 id="213-打家劫舍-II（环形）"><a href="#213-打家劫舍-II（环形）" class="headerlink" title="213. 打家劫舍 II（环形）"></a>213. 打家劫舍 II（环形）</h3><p>核心难点：</p>
<blockquote>
<p><strong>首尾不能同时选</strong></p>
</blockquote>
<p>经典处理方式：</p>
<ul>
<li>情况一：不偷第 0 间 ➜ 偷 <code>[1 … n-1]</code></li>
<li>情况二：不偷第 n-1 间 ➜ 偷 <code>[0 … n-2]</code></li>
<li>对两种情况分别做 <strong>198 打家劫舍</strong></li>
<li>取最大值</li>
</ul>
<p> <strong>环形 DP → 拆成两个线性 DP</strong></p>
<hr>
<h2 id="七、心得与方法论总结"><a href="#七、心得与方法论总结" class="headerlink" title="七、心得与方法论总结"></a>七、心得与方法论总结</h2><h3 id="动态规划到底“动”在哪？"><a href="#动态规划到底“动”在哪？" class="headerlink" title="动态规划到底“动”在哪？"></a>动态规划到底“动”在哪？</h3><ul>
<li>状态是变化的</li>
<li>当前状态来自之前状态</li>
<li>本质是 <strong>dfs 中的“归”</strong></li>
</ul>
<p>递推，其实就是：</p>
<blockquote>
<p><strong>省略 dfs 的“递”，只保留“归”</strong></p>
</blockquote>
<hr>
<h3 id="想不出递推公式怎么办？"><a href="#想不出递推公式怎么办？" class="headerlink" title="想不出递推公式怎么办？"></a>想不出递推公式怎么办？</h3><p>一个非常实用的技巧：</p>
<blockquote>
<p><strong>回退一步，用回溯 + 记忆化搜索先写出来</strong></p>
</blockquote>
<ul>
<li>回溯天然符合“选 or 不选”</li>
<li>递归公式写出来后</li>
<li>直接“翻译”为 dp 即可</li>
</ul>
<hr>
<h3 id="什么时候应该想到动态规划？"><a href="#什么时候应该想到动态规划？" class="headerlink" title="什么时候应该想到动态规划？"></a>什么时候应该想到动态规划？</h3><p>当题目满足以下特征之一时，<strong>高度警惕 DP</strong>：</p>
<ul>
<li>当前结果依赖之前的结果</li>
<li>有“最优”“最多”“最少”“方案数”等关键词</li>
<li>存在大量重复子问题</li>
<li>能清晰定义「状态」</li>
</ul>
<p>一句话总结：</p>
<blockquote>
<p><strong>只要当前状态是在之前状态的基础上演化而来，就可以尝试动态规划</strong></p>
</blockquote>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>动态规划并不是死记模板，而是一种 <strong>从回溯中抽象出的系统性思维方式</strong>。<br>真正掌握 DP 的标志，不是会写状态转移方程，而是：</p>
<blockquote>
<p><strong>能从回溯自然地推导出递推</strong></p>
</blockquote>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/" data-id="cmkbbdw2a004l5w8tcr5hatqq" data-title="动态规划：从回溯到记忆化搜索，再到递推" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-10-Permutation-backtracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/" class="article-date">
  <time class="dt-published" datetime="2026-01-10T05:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/">排列型回溯</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>排列型回溯的本质是「<strong>每一层都可以从所有未使用的元素中重新选择</strong>」，顺序不同即视为不同答案，通常通过 <strong>used &#x2F; flag 数组</strong> 来记录当前路径中已使用的元素。</p>
</blockquote>
<hr>
<h2 id="一、什么是排列型回溯？"><a href="#一、什么是排列型回溯？" class="headerlink" title="一、什么是排列型回溯？"></a>一、什么是排列型回溯？</h2><p>在回溯问题中，<strong>排列型问题</strong>有一个非常鲜明的特征：</p>
<ul>
<li><strong>元素相同，但顺序不同，算作不同答案</strong></li>
<li>例如：<ul>
<li><code>[1, 2]</code> 和 <code>[2, 1]</code> 是 <strong>两个不同的解</strong></li>
</ul>
</li>
</ul>
<p>这与我们之前做过的两类问题形成了清晰对比：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否关心顺序</th>
<th>是否允许重复选</th>
</tr>
</thead>
<tbody><tr>
<td>子集型</td>
<td>❌ 不关心</td>
<td>每个元素只选 &#x2F; 不选</td>
</tr>
<tr>
<td>组合型</td>
<td>❌ 不关心</td>
<td>对于选或不选有约束条件</td>
</tr>
<tr>
<td><strong>排列型</strong></td>
<td>✅ 关心</td>
<td><strong>每一轮可选任意当前轮次未使用元素</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="二、排列型回溯的核心思想"><a href="#二、排列型回溯的核心思想" class="headerlink" title="二、排列型回溯的核心思想"></a>二、排列型回溯的核心思想</h2><p>从「<strong>枚举答案的角度</strong>」来看，排列型回溯有两个关键点：</p>
<h3 id="每一层都在“选位置”，而不是“选元素范围”"><a href="#每一层都在“选位置”，而不是“选元素范围”" class="headerlink" title="每一层都在“选位置”，而不是“选元素范围”"></a>每一层都在“选位置”，而不是“选元素范围”</h3><ul>
<li>第 0 位选谁？</li>
<li>第 1 位选谁？</li>
<li>第 2 位选谁？</li>
</ul>
<p>每一层都可以从 <strong>当前轮所有尚未使用的元素中选择</strong></p>
<hr>
<h3 id="必须显式记录「当前路径中已使用的元素」"><a href="#必须显式记录「当前路径中已使用的元素」" class="headerlink" title="必须显式记录「当前路径中已使用的元素」"></a>必须显式记录「当前路径中已使用的元素」</h3><p>因此，排列型回溯 <strong>一定需要</strong> 一个 <code>used / flag</code> 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">used[i] = true  → nums[i] 已经在当前排列中使用过</span><br><span class="line">used[i] = false → 当前轮次仍可选择 nums[i]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、基础题目分析"><a href="#三、基础题目分析" class="headerlink" title="三、基础题目分析"></a>三、基础题目分析</h2><h3 id="46-全排列（Permutations）"><a href="#46-全排列（Permutations）" class="headerlink" title="46. 全排列（Permutations）"></a>46. 全排列（Permutations）</h3><h4 id="问题特征"><a href="#问题特征" class="headerlink" title="问题特征"></a>问题特征</h4><ul>
<li>目标：生成数组的所有排列</li>
<li>终止条件：<strong>当前路径长度 &#x3D;&#x3D; nums.length</strong></li>
<li>每一层：从所有 <code>used[i] == false</code> 的元素中选一个</li>
</ul>
<hr>
<h4 id="核心实现思路"><a href="#核心实现思路" class="headerlink" title="核心实现思路"></a>核心实现思路</h4><ol>
<li>使用 <code>path</code> 记录当前排列</li>
<li>使用 <code>used[]</code> 标记哪些元素已被选</li>
<li>当 <code>path.size() == nums.length</code> 时，记录答案</li>
<li>回溯时恢复现场（<code>used[i] = false</code>）</li>
</ol>
<hr>
<h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><ul>
<li><strong>排列的深度 &#x3D; nums.length</strong></li>
<li><strong>叶子节点数量 &#x3D; n!</strong></li>
<li><code>used[]</code> 的作用是：<strong>保证每个元素在同一条路径中只出现一次</strong></li>
</ul>
<hr>
<h3 id="51-N-皇后（N-Queens）"><a href="#51-N-皇后（N-Queens）" class="headerlink" title="51. N 皇后（N-Queens）"></a>51. N 皇后（N-Queens）</h3><p>这是一个<strong>非常经典的“受限排列问题”</strong>。</p>
<hr>
<h4 id="问题拆解"><a href="#问题拆解" class="headerlink" title="问题拆解"></a>问题拆解</h4><ul>
<li>每一行只能放一个皇后</li>
<li>每一列只能放一个皇后</li>
<li>皇后不能在同一条对角线上</li>
</ul>
<hr>
<h4 id="建模方式（非常关键）"><a href="#建模方式（非常关键）" class="headerlink" title="建模方式（非常关键）"></a>建模方式（非常关键）</h4><p>用一个一维数组 <code>queens</code> 表示棋盘状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queens[row] = col</span><br></pre></td></tr></table></figure>

<p>含义是：</p>
<ul>
<li>第 <code>row</code> 行</li>
<li>第 <code>col</code> 列</li>
<li>放置了一个皇后</li>
</ul>
<hr>
<h4 id="为什么这是一个排列问题？"><a href="#为什么这是一个排列问题？" class="headerlink" title="为什么这是一个排列问题？"></a>为什么这是一个排列问题？</h4><ul>
<li>行天然不重复（递归层数保证）</li>
<li>列不能重复 → <code>queens</code> 本质是一个 <strong>列索引的全排列</strong></li>
<li>对角线限制 → 给这个全排列 <strong>增加合法性约束</strong></li>
</ul>
<hr>
<h4 id="对角线判断条件"><a href="#对角线判断条件" class="headerlink" title="对角线判断条件"></a>对角线判断条件</h4><p>若两个皇后在 <code>(r1, c1)</code> 和 <code>(r2, c2)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|r1 - r2| == |c1 - c2| → 在同一对角线</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="本质总结"><a href="#本质总结" class="headerlink" title="本质总结"></a>本质总结</h4><blockquote>
<p><strong>N 皇后 &#x3D; 带约束条件的全排列问题</strong></p>
</blockquote>
<hr>
<h2 id="四、扩展题目"><a href="#四、扩展题目" class="headerlink" title="四、扩展题目"></a>四、扩展题目</h2><h3 id="357-统计各位数字都不同的数字个数"><a href="#357-统计各位数字都不同的数字个数" class="headerlink" title="357. 统计各位数字都不同的数字个数"></a>357. 统计各位数字都不同的数字个数</h3><p>这道题虽然形式不同，但本质仍然是：</p>
<ul>
<li>在每一位上选数字</li>
<li>同一个数字不能重复使用</li>
<li>位数不同，形成不同答案</li>
</ul>
<p>本质是 <strong>多层排列 + 剪枝计数</strong>，而不是生成具体排列。</p>
<hr>
<h2 id="五、排列型回溯的时间复杂度"><a href="#五、排列型回溯的时间复杂度" class="headerlink" title="五、排列型回溯的时间复杂度"></a>五、排列型回溯的时间复杂度</h2><p>排列问题的时间复杂度通常非常直观：</p>
<ul>
<li><p><strong>等于叶子节点数量</strong></p>
</li>
<li><p>对于 n 个元素的全排列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度 = O(n!) // 画树分析节点数量得到</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这是排列问题不可避免的代价，因此：</p>
<ul>
<li>剪枝尤为重要</li>
<li>约束条件越多，搜索空间越小</li>
</ul>
<hr>
<h2 id="六、心得体会与方法论总结"><a href="#六、心得体会与方法论总结" class="headerlink" title="六、心得体会与方法论总结"></a>六、心得体会与方法论总结</h2><h3 id="排列型回溯的固定模板"><a href="#排列型回溯的固定模板" class="headerlink" title="排列型回溯的固定模板"></a>排列型回溯的固定模板</h3><ol>
<li>路径长度固定（通常等于元素个数）</li>
<li>每一层从 <strong>所有未使用元素中选择</strong></li>
<li>使用 <code>used[] / flag[]</code> 记录使用状态</li>
<li>回溯时一定要 <strong>恢复现场</strong></li>
</ol>
<hr>
<h3 id="与前两类回溯的根本区别"><a href="#与前两类回溯的根本区别" class="headerlink" title="与前两类回溯的根本区别"></a>与前两类回溯的根本区别</h3><blockquote>
<p><strong>是否允许在下一层重新选择之前没选过的元素</strong></p>
</blockquote>
<ul>
<li>子集 &#x2F; 组合：「之前轮次选过，就不能再选」</li>
<li>排列：「只要当前路径没用过，就可以选」</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/" data-id="cmkbbdw19000f5w8tb38e03zn" data-title="排列型回溯" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-10-backtracking-summary" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/" class="article-date">
  <time class="dt-published" datetime="2026-01-10T05:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/">回溯总结篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在系统完成回溯相关题型后，本篇博客旨在对 <strong>回溯（Backtracking）这一类算法思想进行统一分析与方法论总结</strong>，帮助建立稳定的解题模型。</p>
</blockquote>
<hr>
<h2 id="一、什么是回溯？"><a href="#一、什么是回溯？" class="headerlink" title="一、什么是回溯？"></a>一、什么是回溯？</h2><p><strong>回溯不是一种具体算法，而是一种搜索思想。</strong></p>
<p>从直观角度理解，回溯可以看作是「<strong>悔棋</strong>」：</p>
<ul>
<li>当前选择了一条路往下走</li>
<li>发现这条路走不通，或者已经走完</li>
<li><strong>退回到上一个状态</strong></li>
<li>改选另一条路继续尝试</li>
</ul>
<hr>
<h3 id="回溯与-DFS-的关系"><a href="#回溯与-DFS-的关系" class="headerlink" title="回溯与 DFS 的关系"></a>回溯与 DFS 的关系</h3><p>回溯通常通过 <strong>递归 + 深度优先遍历（DFS）</strong> 实现。</p>
<ul>
<li>DFS 负责：<strong>一路向下探索</strong></li>
<li>回溯负责：<strong>返回时撤销选择，恢复到上一个状态</strong></li>
</ul>
<p>如果把搜索过程看作一棵树：</p>
<ul>
<li>向子节点走 → 递归深入</li>
<li>回到父节点 → 回溯</li>
<li>访问兄弟节点 → 新的选择</li>
</ul>
<hr>
<h3 id="什么是「增量构造答案」？"><a href="#什么是「增量构造答案」？" class="headerlink" title="什么是「增量构造答案」？"></a>什么是「增量构造答案」？</h3><blockquote>
<p><strong>增量构造答案</strong>：<br> 答案不是一开始就完整出现的，而是<strong>在搜索过程中一步步被“拼”出来的</strong>。</p>
</blockquote>
<p>以集合 <code>(1, 2, 3)</code> 的子集问题为例：</p>
<ul>
<li>我们不会一开始就知道一个完整子集</li>
<li>而是：<ol>
<li>先决定：要不要 <code>1</code></li>
<li>再决定：要不要 <code>2</code></li>
<li>再决定：要不要 <code>3</code></li>
</ol>
</li>
<li>每一次选择，都会在当前路径上 <strong>“增加一点信息”</strong></li>
</ul>
<p>因此：</p>
<ul>
<li>当前路径 <code>path</code> 始终是一个 <strong>“未完成的答案”</strong></li>
<li>只有当满足终止条件时，它才成为一个 <strong>完整答案</strong></li>
</ul>
<p>这也是<strong>剪枝能成立的根本原因</strong>：</p>
<blockquote>
<p>如果在“构造过程中”已经不满足条件，就没必要继续往下走。</p>
</blockquote>
<hr>
<h2 id="二、回溯三问（解题核心视角）"><a href="#二、回溯三问（解题核心视角）" class="headerlink" title="二、回溯三问（解题核心视角）"></a>二、回溯三问（解题核心视角）</h2><p>在写回溯代码前，几乎所有题目都可以先回答这三个问题。</p>
<p>以 <strong>电话号码的字母组合</strong> 为例（用 <code>path</code> 记录路径）：</p>
<hr>
<h3 id="问题一：当前在做什么？"><a href="#问题一：当前在做什么？" class="headerlink" title="问题一：当前在做什么？"></a>问题一：当前在做什么？</h3><blockquote>
<p>当前这一层，我要决定什么？</p>
</blockquote>
<ul>
<li>决定 <code>path[i]</code> 填什么字母</li>
</ul>
<hr>
<h3 id="问题二：子问题是什么？"><a href="#问题二：子问题是什么？" class="headerlink" title="问题二：子问题是什么？"></a>问题二：子问题是什么？</h3><blockquote>
<p>在当前选择之后，还剩下什么问题没解决？</p>
</blockquote>
<ul>
<li>构造字符串中 <strong>索引 ≥ i 的部分</strong></li>
</ul>
<hr>
<h3 id="问题三：递归如何推进？"><a href="#问题三：递归如何推进？" class="headerlink" title="问题三：递归如何推进？"></a>问题三：递归如何推进？</h3><blockquote>
<p>当前层和下一层的关系是什么？</p>
</blockquote>
<ul>
<li>当前决定第 <code>i</code> 位</li>
<li>递归进入第 <code>i + 1</code> 位</li>
</ul>
<p><strong>只要这三点清楚，回溯的递归结构自然就出来了</strong></p>
<hr>
<h2 id="三、恢复现场（回溯的关键）"><a href="#三、恢复现场（回溯的关键）" class="headerlink" title="三、恢复现场（回溯的关键）"></a>三、恢复现场（回溯的关键）</h2><p>在 DFS + 回溯过程中，我们通常会经历：</p>
<ol>
<li>做出一个选择（加入 <code>path</code>）</li>
<li>递归深入</li>
<li>返回时 <strong>撤销这个选择</strong></li>
</ol>
<p>如果不撤销，就会导致：</p>
<ul>
<li>当前路径“污染”后续分支</li>
<li>结果错误或重复</li>
</ul>
<hr>
<h3 id="常见的两种恢复现场方式"><a href="#常见的两种恢复现场方式" class="headerlink" title="常见的两种恢复现场方式"></a>常见的两种恢复现场方式</h3><h4 id="回撤（push-pop）"><a href="#回撤（push-pop）" class="headerlink" title="回撤（push + pop）"></a>回撤（push + pop）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.add(x);</span><br><span class="line">dfs();</span><br><span class="line">path.remove(path.size() - 1);</span><br></pre></td></tr></table></figure>

<p>适合 <code>path</code> 长度不固定的情况。</p>
<hr>
<h4 id="覆盖（固定长度数组）"><a href="#覆盖（固定长度数组）" class="headerlink" title="覆盖（固定长度数组）"></a>覆盖（固定长度数组）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path[index] = x;</span><br><span class="line">dfs(index + 1);</span><br></pre></td></tr></table></figure>

<p>适合：</p>
<ul>
<li>全排列</li>
<li>固定长度字符串构造</li>
</ul>
<hr>
<h2 id="四、回溯的三种典型类型"><a href="#四、回溯的三种典型类型" class="headerlink" title="四、回溯的三种典型类型"></a>四、回溯的三种典型类型</h2><p>回溯题目并不是杂乱无章的，大多数都可以归入以下三类。</p>
<p>以数组 <code>[1, 2, 3]</code> 为例：</p>
<hr>
<h3 id="子集型回溯（选-不选）"><a href="#子集型回溯（选-不选）" class="headerlink" title="子集型回溯（选 &#x2F; 不选）"></a>子集型回溯（选 &#x2F; 不选）</h3><p><strong>核心问题</strong>：</p>
<blockquote>
<p>每个元素，选还是不选？</p>
</blockquote>
<h4 id="两种视角"><a href="#两种视角" class="headerlink" title="两种视角"></a>两种视角</h4><ul>
<li><strong>从输入视角</strong>：<ul>
<li>对每个元素做「选 &#x2F; 不选」决策</li>
<li>搜索树是 <strong>严格二叉树</strong></li>
<li>答案通常在叶子节点产生</li>
</ul>
</li>
<li><strong>从答案构造视角</strong>：<ul>
<li>枚举第 <code>i</code> 个答案位置选哪个元素</li>
<li>搜索树是 <strong>多叉树</strong></li>
<li>答案可以在每个节点产生</li>
</ul>
</li>
</ul>
<hr>
<h3 id="组合型回溯（子集-约束）"><a href="#组合型回溯（子集-约束）" class="headerlink" title="组合型回溯（子集 + 约束）"></a>组合型回溯（子集 + 约束）</h3><p>组合型回溯本质上是：</p>
<blockquote>
<p><strong>对子集型回溯增加“合法性约束 + 剪枝”</strong></p>
</blockquote>
<p>常见约束包括：</p>
<ul>
<li>选 <code>k</code> 个数</li>
<li>和等于 <code>target</code></li>
</ul>
<hr>
<h4 id="为什么可以剪枝？"><a href="#为什么可以剪枝？" class="headerlink" title="为什么可以剪枝？"></a>为什么可以剪枝？</h4><p>因为答案是<strong>增量构造的</strong>：</p>
<ul>
<li>如果当前路径已经：<ul>
<li>选多了</li>
<li>和超了</li>
<li>剩余元素不可能满足条件</li>
</ul>
</li>
<li>那么继续向下递归 <strong>一定不可能得到合法答案</strong></li>
</ul>
<p>可以提前返回，剪掉整棵子树。</p>
<hr>
<h3 id="排列型回溯（顺序不同即不同）"><a href="#排列型回溯（顺序不同即不同）" class="headerlink" title="排列型回溯（顺序不同即不同）"></a>排列型回溯（顺序不同即不同）</h3><p>排列型回溯的核心特征：</p>
<ul>
<li><strong>顺序敏感</strong></li>
<li><code>[1,2]</code> 和 <code>[2,1]</code> 是不同答案</li>
</ul>
<hr>
<h4 id="与前两类的本质区别"><a href="#与前两类的本质区别" class="headerlink" title="与前两类的本质区别"></a>与前两类的本质区别</h4><ul>
<li><p>子集 &#x2F; 组合：</p>
<blockquote>
<p>之前选过的元素，后面不能再选</p>
</blockquote>
</li>
<li><p>排列：</p>
<blockquote>
<p><strong>只要当前路径没用过，就可以选</strong></p>
</blockquote>
</li>
</ul>
<p>因此需要：</p>
<ul>
<li>一个 <code>used / flag</code> 数组</li>
<li>表示当前路径中哪些元素已经使用过</li>
</ul>
<hr>
<h2 id="五、统一的回溯伪代码模板"><a href="#五、统一的回溯伪代码模板" class="headerlink" title="五、统一的回溯伪代码模板"></a>五、统一的回溯伪代码模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        记录答案;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：当前层可选的所有选项) &#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtracking(下一层参数);</span><br><span class="line">        撤销选择; // 恢复现场</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、心得总结"><a href="#六、心得总结" class="headerlink" title="六、心得总结"></a>六、心得总结</h2><ul>
<li><p>回溯问题 <strong>不一定是“选或不选”</strong></p>
</li>
<li><p>但一定是 <strong>“做选择 → 走一条路 → 回退 → 换一条路”</strong></p>
</li>
<li><p>本质是：</p>
<blockquote>
<p><strong>在状态空间中系统性地枚举所有可能解</strong></p>
</blockquote>
</li>
</ul>
<p>一旦你能：</p>
<ul>
<li>明确「当前层在决定什么」</li>
<li>明确「路径代表什么」</li>
<li>明确「什么时候可以停、什么时候该剪」</li>
</ul>
<p>那么回溯题目就不再是“凭感觉写代码”，而是一个<strong>高度可复用的方法论问题</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/" data-id="cmkbbdw1a000g5w8t4zawe1qc" data-title="回溯总结篇" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/ssm/springboot/2026-1-10-springboot-day02 " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/" class="article-date">
  <time class="dt-published" datetime="2026-01-09T16:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/">Spring Boot + SSMP 基础实战与问题复盘</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文基于一次完整的 Spring Boot 基础项目实践，总结了从<strong>实体类 → 数据层 → 业务层 → 表现层 → 前后端联调</strong>的开发流程，并重点记录了在整合 MyBatis-Plus、JUnit、分页插件等过程中遇到的典型问题及解决方案，作为后续复盘与查错参考。</p>
</blockquote>
<p>项目采用 <strong>单体架构（非前后端分离）</strong>，以熟悉 Spring Boot + MyBatis-Plus 的基础开发模式为目标。</p>
<h2 id="一、实体类开发（Entity）"><a href="#一、实体类开发（Entity）" class="headerlink" title="一、实体类开发（Entity）"></a>一、实体类开发（Entity）</h2><h3 id="1-数据库准备"><a href="#1-数据库准备" class="headerlink" title="1. 数据库准备"></a>1. 数据库准备</h3><ul>
<li>创建业务表（如 <code>tbl_book</code>）</li>
<li>初始化测试数据</li>
</ul>
<h3 id="2-实体类创建"><a href="#2-实体类创建" class="headerlink" title="2. 实体类创建"></a>2. 实体类创建</h3><ul>
<li>根据表结构创建实体类</li>
<li>使用 <strong>Lombok</strong> 简化样板代码（getter &#x2F; setter &#x2F; toString 等）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Book &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、数据层开发（CRUD）"><a href="#二、数据层开发（CRUD）" class="headerlink" title="二、数据层开发（CRUD）"></a>二、数据层开发（CRUD）</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>ORM 框架：<strong>MyBatis-Plus</strong></li>
<li>数据源：<strong>Druid</strong></li>
<li>测试框架：JUnit</li>
</ul>
<h3 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h3><ol>
<li>引入 MyBatis-Plus Starter</li>
<li>配置数据库连接信息</li>
<li>配置 MP 相关属性<ul>
<li>表名前缀（<code>table-prefix</code>）</li>
<li>主键策略（<code>id-type</code>）</li>
<li>SQL 日志（<code>log-impl</code>）</li>
</ul>
</li>
<li>使用 <code>BaseMapper&lt;T&gt;</code> 快速完成 CRUD</li>
<li>使用 <code>@Mapper</code> 或 <code>@MapperScan</code> 交给 Spring 管理</li>
<li>编写 Mapper 测试类验证功能</li>
</ol>
<hr>
<h2 id="三、问题复盘-①：测试类能运行，测试方法却报-NoSuchMethodError"><a href="#三、问题复盘-①：测试类能运行，测试方法却报-NoSuchMethodError" class="headerlink" title="三、问题复盘 ①：测试类能运行，测试方法却报 NoSuchMethodError"></a>三、问题复盘 ①：测试类能运行，测试方法却报 <code>NoSuchMethodError</code></h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><ul>
<li>直接运行测试类 ✔</li>
<li>单独运行测试方法 ❌ 报错：<code>NoSuchMethodError</code></li>
</ul>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ul>
<li><strong>Classpath 中存在多个 JUnit 版本</strong></li>
<li>Spring Boot 默认引入的测试依赖与本地环境冲突</li>
</ul>
<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><ul>
<li>尝试在 <code>pom.xml</code> 中强制覆盖 JUnit 版本 → ❌ 无效</li>
<li><strong>最终解决方案：降低 Spring Boot 版本</strong></li>
</ul>
<p>从 <strong>Spring Boot 4.x 降级到 Spring Boot 3.x</strong> 后问题消失</p>
<blockquote>
<p>结论：<br> <strong>测试相关问题优先排查：Spring Boot 版本 × Starter 版本 × IDE 运行方式</strong></p>
</blockquote>
<hr>
<h2 id="四、问题复盘-②：Spring-Boot-3-MyBatis-Plus-启动时报-Mapper-Bean-异常"><a href="#四、问题复盘-②：Spring-Boot-3-MyBatis-Plus-启动时报-Mapper-Bean-异常" class="headerlink" title="四、问题复盘 ②：Spring Boot 3 + MyBatis-Plus 启动时报 Mapper Bean 异常"></a>四、问题复盘 ②：Spring Boot 3 + MyBatis-Plus 启动时报 Mapper Bean 异常</h2><h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid bean definition with name &#x27;xxxMapper&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ul>
<li><code>@Mapper</code> ✔</li>
<li><code>@MapperScan</code> ✔</li>
<li>包路径无误 ✔</li>
</ul>
<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p><strong>Spring Boot 3 与 MyBatis-Plus Starter 版本不兼容</strong></p>
<h3 id="正确依赖方式"><a href="#正确依赖方式" class="headerlink" title="正确依赖方式"></a>正确依赖方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring Boot 2.x --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Spring Boot 3.x --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：<br> <strong>Spring Boot 3 必须使用 boot3 专用的 MyBatis-Plus Starter</strong></p>
</blockquote>
<hr>
<h2 id="五、问题复盘-③：配置了-IdType-AUTO，却生成了“雪花-ID”"><a href="#五、问题复盘-③：配置了-IdType-AUTO，却生成了“雪花-ID”" class="headerlink" title="五、问题复盘 ③：配置了 IdType.AUTO，却生成了“雪花 ID”"></a>五、问题复盘 ③：配置了 <code>IdType.AUTO</code>，却生成了“雪花 ID”</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><ul>
<li>实体类主键配置为 <code>IdType.AUTO</code></li>
<li>插入后 ID 却像雪花算法生成</li>
</ul>
<h3 id="真正原因"><a href="#真正原因" class="headerlink" title="真正原因"></a>真正原因</h3><p>并非 AUTO 失效，而是：</p>
<ul>
<li>之前使用过 <strong>雪花 ID 策略</strong></li>
<li>删除数据后，<strong>数据库的 <code>AUTO_INCREMENT</code> 未重置</strong></li>
<li>产生了“脏 ID ”</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_book AUTO_INCREMENT = 1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：<br> <strong>主键策略问题，一定要同时检查：代码配置 + 数据库状态</strong></p>
</blockquote>
<hr>
<h2 id="六、数据层开发（分页功能）"><a href="#六、数据层开发（分页功能）" class="headerlink" title="六、数据层开发（分页功能）"></a>六、数据层开发（分页功能）</h2><h3 id="MyBatis-Plus-分页-API"><a href="#MyBatis-Plus-分页-API" class="headerlink" title="MyBatis-Plus 分页 API"></a>MyBatis-Plus 分页 API</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testGetPage()&#123;</span><br><span class="line">    IPage&lt;Book&gt; page = new Page&lt;&gt;(2, 5);</span><br><span class="line">    bookMapper.selectPage(page, null);</span><br><span class="line"></span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页参数说明"><a href="#分页参数说明" class="headerlink" title="分页参数说明"></a>分页参数说明</h3><ul>
<li>当前页码</li>
<li>每页条数</li>
</ul>
<h3 id="必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）"><a href="#必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）" class="headerlink" title="必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）"></a>必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MPConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、问题复盘-④：分页不生效"><a href="#七、问题复盘-④：分页不生效" class="headerlink" title="七、问题复盘 ④：分页不生效"></a>七、问题复盘 ④：分页不生效</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>MyBatis-Plus <strong>将分页能力拆分为插件</strong></li>
<li>未引入解析 SQL 的依赖</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-jsqlparser&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.15&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、数据层开发（条件查询）"><a href="#八、数据层开发（条件查询）" class="headerlink" title="八、数据层开发（条件查询）"></a>八、数据层开发（条件查询）</h2><h3 id="普通条件构造（存在风险）"><a href="#普通条件构造（存在风险）" class="headerlink" title="普通条件构造（存在风险）"></a>普通条件构造（存在风险）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;Book&gt; qw = new QueryWrapper&lt;&gt;();</span><br><span class="line">qw.like(&quot;name&quot;, &quot;Spring&quot;);</span><br><span class="line">bookMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<p>❌ 问题：字段名是字符串，<strong>编译期无法检查</strong></p>
<hr>
<h3 id="Lambda-条件构造（推荐）"><a href="#Lambda-条件构造（推荐）" class="headerlink" title="Lambda 条件构造（推荐）"></a>Lambda 条件构造（推荐）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lqw.like(name != null, Book::getName, name);</span><br><span class="line">bookMapper.selectList(lqw);</span><br></pre></td></tr></table></figure>

<p>✅ 优点：</p>
<ul>
<li>编译期安全</li>
<li>支持条件开关</li>
<li>重构友好</li>
</ul>
<hr>
<h2 id="九、业务层开发（Service）"><a href="#九、业务层开发（Service）" class="headerlink" title="九、业务层开发（Service）"></a>九、业务层开发（Service）</h2><p>业务层职责：</p>
<blockquote>
<p><strong>组织业务逻辑，对数据层进行封装调用</strong></p>
</blockquote>
<p>开发步骤：</p>
<ol>
<li>定义 Service 接口</li>
<li>编写 ServiceImpl</li>
<li>注入 Mapper</li>
<li>编写测试验证逻辑正确性</li>
</ol>
<hr>
<h2 id="十、表现层开发（Controller）"><a href="#十、表现层开发（Controller）" class="headerlink" title="十、表现层开发（Controller）"></a>十、表现层开发（Controller）</h2><h3 id="核心工作"><a href="#核心工作" class="headerlink" title="核心工作"></a>核心工作</h3><ul>
<li>编写 REST Controller</li>
<li>接收参数</li>
<li>调用业务层</li>
<li>返回统一结果</li>
</ul>
<h3 id="参数接收注意点"><a href="#参数接收注意点" class="headerlink" title="参数接收注意点"></a>参数接收注意点</h3><ul>
<li>JSON 实体：<code>@RequestBody</code></li>
<li>路径变量：<code>@PathVariable</code></li>
</ul>
<p>使用 <strong>ApiFox</strong> 进行接口测试与调试。</p>
<hr>
<h2 id="十一、统一返回结果设计"><a href="#十一、统一返回结果设计" class="headerlink" title="十一、统一返回结果设计"></a>十一、统一返回结果设计</h2><p>为保证前后端交互一致性：</p>
<ul>
<li>封装统一响应对象</li>
<li>包含：<ul>
<li><code>code</code></li>
<li><code>data</code></li>
<li><code>msg</code></li>
</ul>
</li>
<li>同时考虑异常场景</li>
</ul>
<hr>
<h2 id="十二、前后端联调"><a href="#十二、前后端联调" class="headerlink" title="十二、前后端联调"></a>十二、前后端联调</h2><ul>
<li><p>将前端静态资源拷贝到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resources/static</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring Boot 自动托管静态资源</p>
</li>
<li><p>实现简单的前后端一体化访问</p>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次 Spring Boot 基础实战，我完成了：</p>
<ul>
<li>一条完整的 <strong>SSMP 开发链路</strong></li>
<li>多个 <strong>真实问题的排查与解决</strong></li>
<li>对 <strong>版本兼容性、插件机制、主键策略</strong> 的深入理解</li>
</ul>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/" data-id="cmkbbdw2e00535w8taqw88bl9" data-title="Spring Boot + SSMP 基础实战与问题复盘" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis-plus/" rel="tag">mybatis-plus</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-9-Combinatorial backtracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/" class="article-date">
  <time class="dt-published" datetime="2026-01-09T04:00:00.000Z" itemprop="datePublished">2026-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/">组合型回溯 + 剪枝：从子集枚举到条件收敛</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="组合型回溯-剪枝"><a href="#组合型回溯-剪枝" class="headerlink" title="组合型回溯 + 剪枝"></a>组合型回溯 + 剪枝</h1><blockquote>
<p><strong>一句话总结</strong>：<br> 组合型回溯本质仍是子集型回溯，但通过“组合约束 + 单调性剪枝”，将指数级搜索空间大幅收缩，只遍历“有可能成为答案”的分支。</p>
</blockquote>
<hr>
<h2 id="一、什么是组合型回溯？"><a href="#一、什么是组合型回溯？" class="headerlink" title="一、什么是组合型回溯？"></a>一、什么是组合型回溯？</h2><p>在回溯问题中，我们通常会遇到两类经典模型：</p>
<ul>
<li><strong>子集型回溯</strong>：<br> 枚举所有可能的子集（选 &#x2F; 不选），不关心长度或数值约束</li>
<li><strong>组合型回溯</strong>：<br> 在子集枚举的基础上，<strong>只保留满足条件的组合</strong></li>
</ul>
<p>常见的组合约束包括：</p>
<ul>
<li>固定长度（如选 k 个数）</li>
<li>固定和（如和为 target）</li>
<li>结构合法性（如括号匹配、IP 段合法）</li>
</ul>
<p>因此，<strong>组合型回溯 &#x3D; 子集型回溯 + 条件约束 + 剪枝</strong>。</p>
<hr>
<h2 id="二、组合型回溯的核心思想"><a href="#二、组合型回溯的核心思想" class="headerlink" title="二、组合型回溯的核心思想"></a>二、组合型回溯的核心思想</h2><p>组合型回溯的关键并不在「怎么枚举」，而在于：</p>
<blockquote>
<p><strong>当前状态已经不可能构成合法解时，要尽早停止搜索</strong></p>
</blockquote>
<p>这正是剪枝的价值所在。</p>
<h3 id="常见剪枝维度"><a href="#常见剪枝维度" class="headerlink" title="常见剪枝维度"></a>常见剪枝维度</h3><ol>
<li><strong>数量剪枝</strong><ul>
<li>剩余可选元素 &lt; 还需要选的数量 → 直接返回</li>
</ul>
</li>
<li><strong>数值剪枝（选择元素为正）</strong><ul>
<li>当前和已经超过 target</li>
<li>即使选最大值，也无法达到 target</li>
</ul>
</li>
<li><strong>结构剪枝</strong><ul>
<li>不满足合法结构（如右括号多于左括号）</li>
</ul>
</li>
</ol>
<p>这些剪枝往往都依赖于一个核心性质：</p>
<blockquote>
<p><strong>单调性</strong>：<br> 当前状态不满足条件，向下扩展只会更不满足。</p>
</blockquote>
<hr>
<h2 id="三、典型题目拆解与剪枝思路"><a href="#三、典型题目拆解与剪枝思路" class="headerlink" title="三、典型题目拆解与剪枝思路"></a>三、典型题目拆解与剪枝思路</h2><h3 id="77-组合（Combinations）"><a href="#77-组合（Combinations）" class="headerlink" title="77. 组合（Combinations）"></a>77. 组合（Combinations）</h3><p><strong>目标</strong>：从 <code>[1…n]</code> 中选 <code>k</code> 个数</p>
<h4 id="关键剪枝"><a href="#关键剪枝" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ul>
<li><strong>数量剪枝</strong><ul>
<li>剩余数字个数 &lt; 还需要选择的数量 → 直接返回</li>
</ul>
</li>
<li><strong>提前返回</strong><ul>
<li>当已选数量 &#x3D;&#x3D; k，记录答案，不再向下搜索</li>
</ul>
</li>
</ul>
<h4 id="本质理解"><a href="#本质理解" class="headerlink" title="本质理解"></a>本质理解</h4><p>这是一个<strong>固定长度的组合问题</strong>，搜索树深度是确定的，剪枝点非常清晰。</p>
<hr>
<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h3><p><strong>目标</strong>：从 <code>[1…9]</code> 中选 <code>k</code> 个数，和为 <code>n</code></p>
<h4 id="关键剪枝-1"><a href="#关键剪枝-1" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ol>
<li><code>leftTarget &lt; 0</code><ul>
<li>所有数均为正数，后续必然无解</li>
</ul>
</li>
<li><code>leftTarget &gt; 剩余可选数字的最大可能和</code><ul>
<li>即使全选最大值，也无法凑够</li>
</ul>
</li>
<li>剩余数字个数 &lt; 还需要选择的数量</li>
</ol>
<h4 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h4><ul>
<li>同时利用了「<strong>一大一小</strong>」两种剪枝方向</li>
<li>体现出数值约束与数量约束的对称性</li>
</ul>
<hr>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><p><strong>目标</strong>：生成 <code>n</code> 对合法括号</p>
<h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><ul>
<li><code>left</code>：已使用左括号数量</li>
<li><code>right</code>：已使用右括号数量</li>
</ul>
<h4 id="剪枝规则"><a href="#剪枝规则" class="headerlink" title="剪枝规则"></a>剪枝规则</h4><ul>
<li><code>left &gt; n</code> → 非法</li>
<li><code>right &gt; left</code> → 非法</li>
</ul>
<h4 id="本质理解-1"><a href="#本质理解-1" class="headerlink" title="本质理解"></a>本质理解</h4><p>这道题可以视为一种<strong>带结构约束的组合回溯</strong>：</p>
<ul>
<li>“选” → 加左括号</li>
<li>“不选” → 加右括号（但有条件）</li>
</ul>
<p>本质不是排列，而是<strong>合法结构的组合生成</strong>。</p>
<hr>
<h3 id="39-组合总和（可重复选择）"><a href="#39-组合总和（可重复选择）" class="headerlink" title="39. 组合总和（可重复选择）"></a>39. 组合总和（可重复选择）</h3><p><strong>目标</strong>：元素可重复选，和为 target</p>
<h4 id="关键剪枝-2"><a href="#关键剪枝-2" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ol>
<li><p><code>leftTarget &lt; 0</code> → 直接返回</p>
</li>
<li><p><code>leftTarget == 0</code> → 记录答案并返回</p>
</li>
<li><p><strong>排序 + 剪枝</strong></p>
<p>若当前元素 &gt; <code>leftTarget</code>，后续元素更大，可直接 break</p>
</li>
</ol>
<h4 id="可重复选择的表达"><a href="#可重复选择的表达" class="headerlink" title="可重复选择的表达"></a>可重复选择的表达</h4><ul>
<li>使用 <code>dfs(i)</code> 表示<strong>当前元素可再次选择</strong></li>
<li>通过起始索引控制是否允许重复</li>
</ul>
<hr>
<h3 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a>93. 复原 IP 地址</h3><p><strong>目标</strong>：将字符串分割为 4 段合法 IP</p>
<h4 id="强剪枝条件"><a href="#强剪枝条件" class="headerlink" title="强剪枝条件"></a>强剪枝条件</h4><ol>
<li><p><strong>字符数量剪枝</strong></p>
<p>剩余字符数 ∉ <code>[剩余段数, 剩余段数 * 3]</code></p>
</li>
<li><p><strong>数值剪枝</strong></p>
<p>当前段 &gt; 255</p>
</li>
<li><p><strong>前导零剪枝</strong></p>
<p>段以 <code>0</code> 开头但长度 &gt; 1</p>
</li>
</ol>
<h4 id="补充思路"><a href="#补充思路" class="headerlink" title="补充思路"></a>补充思路</h4><ul>
<li>由于段数固定为 4</li>
<li>该题也可以用 <strong>三重循环</strong> 实现</li>
<li>但回溯解法在结构上更统一、可复用性更强</li>
</ul>
<hr>
<h2 id="四、方法论总结：如何写好组合型回溯？"><a href="#四、方法论总结：如何写好组合型回溯？" class="headerlink" title="四、方法论总结：如何写好组合型回溯？"></a>四、方法论总结：如何写好组合型回溯？</h2><h3 id="推荐解题步骤"><a href="#推荐解题步骤" class="headerlink" title="推荐解题步骤"></a>推荐解题步骤</h3><ol>
<li><p><strong>先不剪枝，写出正确解</strong></p>
</li>
<li><p>明确以下要素：</p>
<p>状态变量（路径、索引、剩余目标）</p>
<p>终止条件</p>
</li>
<li><p>回看搜索树，问自己：</p>
<p>当前状态已经不可能成功了吗？</p>
</li>
<li><p>将「不可能成功」的情况提前 return</p>
</li>
</ol>
<h3 id="一个重要认知"><a href="#一个重要认知" class="headerlink" title="一个重要认知"></a>一个重要认知</h3><blockquote>
<p>剪枝为了利用题目的<strong>单调性</strong>。</p>
</blockquote>
<ul>
<li>当前不满足 → 未来一定不满足</li>
<li>才是可以安全剪枝的前提</li>
</ul>
<hr>
<h2 id="五、个人心得体会"><a href="#五、个人心得体会" class="headerlink" title="五、个人心得体会"></a>五、个人心得体会</h2><ul>
<li><p><strong>组合型回溯并不是新的模型</strong><br> 它只是对子集型回溯的“<strong>条件收敛</strong>”</p>
</li>
<li><p>实战中：</p>
<p>先保证正确性、再逐步加剪枝，思路更清晰</p>
</li>
<li><p>多数高质量剪枝，都来源于：</p>
<ul>
<li>数量边界</li>
<li>数值上下界</li>
<li>结构合法性</li>
</ul>
</li>
</ul>
<p>当你能一眼看出「当前状态是否还有希望」，回溯题就不再是暴力搜索，而是<strong>受控的状态枚举</strong>。</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/" data-id="cmkbbdw1d000q5w8t96bwf8ld" data-title="组合型回溯 + 剪枝：从子集枚举到条件收敛" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/ssm/springboot/2026-1-9-springboot-day01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/09/backend/ssm/springboot/2026-1-9-springboot-day01/" class="article-date">
  <time class="dt-published" datetime="2026-01-08T16:00:00.000Z" itemprop="datePublished">2026-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/09/backend/ssm/springboot/2026-1-9-springboot-day01/">Spring Boot 基础入门与整合实践</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文记录了我在学习 Spring Boot 基础与整合 MyBatis、Druid 过程中的核心知识点，以及一次完整、真实的排错过程。<br>重点不在于“配置怎么写”，而在于<strong>理解 Spring Boot 自动配置的工作机制</strong>。</p>
</blockquote>
<hr>
<h2 id="一、Spring-Boot-简介"><a href="#一、Spring-Boot-简介" class="headerlink" title="一、Spring Boot 简介"></a>一、Spring Boot 简介</h2><p>Spring Boot 是由 Pivotal 团队提供的快速开发框架，目标是：</p>
<ul>
<li>简化 Spring 应用的初始搭建</li>
<li>减少繁琐的 XML &#x2F; Java 配置</li>
<li>通过 <strong>自动配置（Auto Configuration）+ Starter 机制</strong> 提升开发效率</li>
</ul>
<hr>
<h2 id="二、Spring-Boot-入门方式"><a href="#二、Spring-Boot-入门方式" class="headerlink" title="二、Spring Boot 入门方式"></a>二、Spring Boot 入门方式</h2><h3 id="2-1-创建方式说明"><a href="#2-1-创建方式说明" class="headerlink" title="2.1 创建方式说明"></a>2.1 创建方式说明</h3><ul>
<li>使用 IDEA &#x2F; 官网 &#x2F; 阿里云脚手架：<strong>需要联网</strong></li>
<li>手动创建 Maven 项目：<ul>
<li>继承 <code>spring-boot-starter-parent</code></li>
<li>手动编写启动类</li>
<li><strong>不需要联网</strong>（前提是本地仓库已有依赖）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="三、parent-与-starter-的作用区分"><a href="#三、parent-与-starter-的作用区分" class="headerlink" title="三、parent 与 starter 的作用区分"></a>三、<code>parent</code> 与 <code>starter</code> 的作用区分</h2><h3 id="3-1-parent：统一依赖版本管理"><a href="#3-1-parent：统一依赖版本管理" class="headerlink" title="3.1 parent：统一依赖版本管理"></a>3.1 parent：统一依赖版本管理</h3><p><code>spring-boot-starter-parent</code> 的作用是：</p>
<ul>
<li>统一管理常用依赖的版本</li>
<li>避免版本冲突</li>
<li>简化 pom 文件</li>
</ul>
<blockquote>
<p><strong>注意</strong>：<br> parent 只“管理版本”，并不会实际引入任何依赖。</p>
</blockquote>
<hr>
<h3 id="3-2-starter：功能级依赖集合"><a href="#3-2-starter：功能级依赖集合" class="headerlink" title="3.2 starter：功能级依赖集合"></a>3.2 starter：功能级依赖集合</h3><p>starter 的作用是：</p>
<ul>
<li>一次性引入某个技术栈所需的依赖</li>
<li>通过<strong>依赖传递</strong>减少配置成本</li>
</ul>
<p>例如：</p>
<ul>
<li><code>spring-boot-starter-web</code></li>
<li><code>spring-boot-starter-jdbc</code></li>
<li><code>mybatis-spring-boot-starter</code></li>
</ul>
<blockquote>
<p>parent + starter 解决的是 <strong>“配置复杂度”问题</strong></p>
</blockquote>
<hr>
<h2 id="四、Spring-Boot-启动类"><a href="#四、Spring-Boot-启动类" class="headerlink" title="四、Spring Boot 启动类"></a>四、Spring Boot 启动类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot01QuickstartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot01QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动类的作用"><a href="#启动类的作用" class="headerlink" title="启动类的作用"></a>启动类的作用</h3><ul>
<li>标识这是一个 Spring Boot 应用</li>
<li>启动 Spring 容器</li>
<li>扫描当前包及其子包下的 Bean</li>
<li>返回值是 <code>ApplicationContext</code></li>
</ul>
<hr>
<h2 id="五、内嵌-Web-容器机制"><a href="#五、内嵌-Web-容器机制" class="headerlink" title="五、内嵌 Web 容器机制"></a>五、内嵌 Web 容器机制</h2><p>在引入 <code>spring-boot-starter-web</code> 后：</p>
<ul>
<li>默认内嵌 Tomcat</li>
<li>Spring 会创建并管理一个 Tomcat 对象</li>
<li>启动应用时自动启动 Web 服务器</li>
</ul>
<p>Spring Boot 也支持 Jetty、Undertow 等内嵌容器。</p>
<hr>
<h2 id="六、基础配置文件"><a href="#六、基础配置文件" class="headerlink" title="六、基础配置文件"></a>六、基础配置文件</h2><h3 id="6-1-配置文件类型与优先级"><a href="#6-1-配置文件类型与优先级" class="headerlink" title="6.1 配置文件类型与优先级"></a>6.1 配置文件类型与优先级</h3><p>Spring Boot 支持：</p>
<ul>
<li><code>application.properties</code></li>
<li><code>application.yml</code></li>
<li><code>application.yaml</code></li>
</ul>
<p>优先级（从高到低）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties &gt; yml &gt; yaml</span><br></pre></td></tr></table></figure>

<p>相同配置高优先级覆盖，未冲突配置全部生效。</p>
<hr>
<h3 id="6-2-为什么推荐-YAML"><a href="#6-2-为什么推荐-YAML" class="headerlink" title="6.2 为什么推荐 YAML"></a>6.2 为什么推荐 YAML</h3><ul>
<li>层级清晰</li>
<li>可读性更好</li>
<li>更适合复杂配置</li>
</ul>
<h4 id="YAML-核心规则"><a href="#YAML-核心规则" class="headerlink" title="YAML 核心规则"></a>YAML 核心规则</h4><ul>
<li>大小写敏感</li>
<li>缩进表示层级（只能用空格）</li>
<li><code>key: value</code> 中冒号后必须有空格</li>
<li><code>#</code> 表示注释</li>
</ul>
<hr>
<h3 id="6-3-YAML-数据绑定方式"><a href="#6-3-YAML-数据绑定方式" class="headerlink" title="6.3 YAML 数据绑定方式"></a>6.3 YAML 数据绑定方式</h3><h4 id="方式一：-Value"><a href="#方式一：-Value" class="headerlink" title="方式一：@Value"></a>方式一：<code>@Value</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;enterprise.name&#125;&quot;)</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure>

<h4 id="方式二：Environment"><a href="#方式二：Environment" class="headerlink" title="方式二：Environment"></a>方式二：<code>Environment</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment.getProperty(&quot;enterprise.name&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="方式三（推荐）：-ConfigurationProperties"><a href="#方式三（推荐）：-ConfigurationProperties" class="headerlink" title="方式三（推荐）：@ConfigurationProperties"></a>方式三（推荐）：<code>@ConfigurationProperties</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;enterprise&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class Enterprise &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String tel;</span><br><span class="line">    private String[] hobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本质：<br> Spring Boot 内部大量使用这种方式完成第三方组件的<strong>自动配置</strong></p>
</blockquote>
<hr>
<h2 id="七、整合第三方技术"><a href="#七、整合第三方技术" class="headerlink" title="七、整合第三方技术"></a>七、整合第三方技术</h2><h3 id="7-1-Spring-Boot-整合-JUnit"><a href="#7-1-Spring-Boot-整合-JUnit" class="headerlink" title="7.1 Spring Boot 整合 JUnit"></a>7.1 Spring Boot 整合 JUnit</h3><ul>
<li>自动引入测试 starter</li>
<li>使用 <code>@SpringBootTest</code></li>
<li>测试类不在启动类包下时需指定 <code>classes</code></li>
</ul>
<hr>
<h3 id="7-2-Spring-Boot-整合-MyBatis"><a href="#7-2-Spring-Boot-整合-MyBatis" class="headerlink" title="7.2 Spring Boot 整合 MyBatis"></a>7.2 Spring Boot 整合 MyBatis</h3><p>MyBatis 主要涉及两类配置：</p>
<ol>
<li><strong>全局配置</strong>（数据源）</li>
<li><strong>映射配置</strong>（XML &#x2F; 注解）</li>
</ol>
<p>基本步骤：</p>
<ul>
<li>引入 MyBatis Starter</li>
<li>配置数据源</li>
<li>定义 Mapper 接口</li>
<li>注入 Mapper 测试</li>
</ul>
<hr>
<h3 id="7-3-Spring-Boot-整合-Druid"><a href="#7-3-Spring-Boot-整合-Druid" class="headerlink" title="7.3 Spring Boot 整合 Druid"></a>7.3 Spring Boot 整合 Druid</h3><ul>
<li>引入 Druid Starter</li>
<li>配置 Druid 专属配置项</li>
<li>验证 DataSource 类型</li>
</ul>
<hr>
<h2 id="八、整合过程中的问题与排错总结（重点）"><a href="#八、整合过程中的问题与排错总结（重点）" class="headerlink" title="八、整合过程中的问题与排错总结（重点）"></a>八、整合过程中的问题与排错总结（重点）</h2><h3 id="问题一：UserDao-无法注入"><a href="#问题一：UserDao-无法注入" class="headerlink" title="问题一：UserDao 无法注入"></a>问题一：<code>UserDao</code> 无法注入</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No qualifying bean of type &#x27;tingfeng.mapper.UserDao&#x27; available</span><br></pre></td></tr></table></figure>

<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>Mapper 接口未被 Spring 扫描</li>
<li><code>@Mapper</code> 只对 MyBatis 生效</li>
</ul>
<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;tingfeng.mapper&quot;)</span><br><span class="line">public class Quickstart03Application &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键认知"><a href="#关键认知" class="headerlink" title="关键认知"></a>关键认知</h4><blockquote>
<p><strong>@Mapper 是 MyBatis 的，@MapperScan 才是 Spring 的</strong></p>
</blockquote>
<hr>
<h3 id="问题二：Mapper-能扫描，但报-sqlSessionFactory-缺失"><a href="#问题二：Mapper-能扫描，但报-sqlSessionFactory-缺失" class="headerlink" title="问题二：Mapper 能扫描，但报 sqlSessionFactory 缺失"></a>问题二：Mapper 能扫描，但报 <code>sqlSessionFactory</code> 缺失</h3><h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Property &#x27;sqlSessionFactory&#x27; or &#x27;sqlSessionTemplate&#x27; are required</span><br></pre></td></tr></table></figure>

<h4 id="定位结论"><a href="#定位结论" class="headerlink" title="定位结论"></a>定位结论</h4><ul>
<li>Mapper 已创建</li>
<li>SqlSessionFactory 未生成</li>
<li>SqlSessionFactory 依赖 DataSource</li>
</ul>
<h4 id="实际解决方式"><a href="#实际解决方式" class="headerlink" title="实际解决方式"></a>实际解决方式</h4><blockquote>
<p><strong>将 <code>mybatis-spring-boot-starter</code> 从 3.0.4 升级至 4.0.2</strong></p>
</blockquote>
<h4 id="根因分析（重要）"><a href="#根因分析（重要）" class="headerlink" title="根因分析（重要）"></a>根因分析（重要）</h4><p>新版本调整了：</p>
<ul>
<li>Mapper 初始化时机</li>
<li>SqlSessionFactory 校验逻辑</li>
</ul>
<p>避免在 DataSource 尚未完全初始化时进行强校验，从而绕开了该异常路径。</p>
<blockquote>
<p>⚠️ 注意：<br> 这并不代表 DataSource 问题“消失”，而是<strong>校验时机发生了变化</strong></p>
</blockquote>
<hr>
<h2 id="九、总结与反思"><a href="#九、总结与反思" class="headerlink" title="九、总结与反思"></a>九、总结与反思</h2><p>这次学习和排错过程中，我最大的收获不是“配置记住了多少”，而是：</p>
<ul>
<li>理解了 <strong>Starter 才是自动配置的触发条件</strong></li>
<li>明白了 <strong>异常信息可能并不是根因</strong></li>
<li>学会从 <strong>DataSource → SqlSessionFactory → Mapper</strong> 反向排查</li>
<li>认识到 <strong>版本升级可能改变行为，而非修复根因</strong></li>
</ul>
<hr>
<h2 id="十、一句话总结"><a href="#十、一句话总结" class="headerlink" title="十、一句话总结"></a>十、一句话总结</h2><blockquote>
<p>Spring Boot 整合 MyBatis 与数据源时，<br> 问题往往不在 Mapper 本身，<br> 而在自动配置链路是否完整、以及校验时机是否合理。</p>
</blockquote>
<hr>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/09/backend/ssm/springboot/2026-1-9-springboot-day01/" data-id="cmkbbdw2f005b5w8tdc8ue3ab" data-title="Spring Boot 基础入门与整合实践" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/druid/" rel="tag">druid</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-8-backtracking-subset-practice" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/08/algorithms/backtracking/2026-1-8-backtracking-subset-practice/" class="article-date">
  <time class="dt-published" datetime="2026-01-08T04:00:00.000Z" itemprop="datePublished">2026-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/08/algorithms/backtracking/2026-1-8-backtracking-subset-practice/">子集型回溯方法论得应用（2026-01-08）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、输入角度的子集型回溯"><a href="#一、输入角度的子集型回溯" class="headerlink" title="一、输入角度的子集型回溯"></a>一、输入角度的子集型回溯</h2><p>子集型回溯是一类<strong>通过枚举每个元素“选 or 不选”来构造答案集合</strong>的回溯问题。<br> 其核心思想是：</p>
<blockquote>
<p>对输入集合中的每一个元素，都做一次“是否加入当前解”的选择，通过递归枚举所有可能的子集。</p>
</blockquote>
<p>由于每个元素只有两种状态（选 &#x2F; 不选），因此这类问题<strong>天然覆盖所有可能情况，不会重、不漏</strong>。</p>
<hr>
<h2 id="二、子集型回溯的统一模板"><a href="#二、子集型回溯的统一模板" class="headerlink" title="二、子集型回溯的统一模板"></a>二、子集型回溯的统一模板</h2><p>子集型回溯的 DFS 过程通常包含三个核心要素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(i, 输入集合，当前状态)</span>:</span><br><span class="line">	<span class="comment">// n 为输入集合长度</span></span><br><span class="line">    <span class="keyword">if</span> i == n:</span><br><span class="line">		<span class="comment">// 说明当前轮枚举完了输入集合</span></span><br><span class="line">        更新答案</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不选第 i 个元素</span></span><br><span class="line">    dfs(i + <span class="number">1</span>, 输入集合，当前状态)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选第 i 个元素（有条件）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">check</span><span class="params">(i, 当前状态)</span>:</span><br><span class="line">        选择 i</span><br><span class="line">        <span class="title function_">dfs</span><span class="params">(i + <span class="number">1</span>, 输入集合，新状态)</span></span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>i</code>：当前处理到第 i 个元素</li>
<li><code>当前状态</code>：路径（已选元素 &#x2F; 剩余资源 &#x2F; 当前得分等）</li>
<li><code>check</code>：是否允许“选”的条件判断（<strong>条件回溯的关键</strong>）</li>
</ul>
<hr>
<h2 id="三、扩展题目统一拆解"><a href="#三、扩展题目统一拆解" class="headerlink" title="三、扩展题目统一拆解"></a>三、扩展题目统一拆解</h2><p>下面 6 道题，本质上都可以<strong>统一为「子集型回溯 + 条件判断」</strong>。</p>
<hr>
<h3 id="LCP51-烹饪料理"><a href="#LCP51-烹饪料理" class="headerlink" title="LCP51. 烹饪料理"></a>LCP51. 烹饪料理</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>枚举第 i 道料理：做 or 不做</li>
<li>选的条件：材料足够</li>
</ul>
<p><strong>状态维护</strong>：</p>
<ul>
<li>剩余材料数组</li>
</ul>
<p>典型的「<strong>资源约束型子集回溯</strong>」</p>
<hr>
<h3 id="2397-被列覆盖的最多行数"><a href="#2397-被列覆盖的最多行数" class="headerlink" title="2397. 被列覆盖的最多行数"></a>2397. 被列覆盖的最多行数</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>枚举第 i 列：选 or 不选</li>
<li>选的条件：已选列数 ≤ numSelect</li>
</ul>
<p><strong>关键剪枝</strong>：</p>
<ul>
<li>如果 <code>剩余列数 ≤ 剩余可选数</code> → <strong>必须全选</strong></li>
</ul>
<p>子集型回溯 + <strong>强剪枝</strong></p>
<hr>
<h3 id="1239-串联字符串的最大长度"><a href="#1239-串联字符串的最大长度" class="headerlink" title="1239. 串联字符串的最大长度"></a>1239. 串联字符串的最大长度</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>枚举每个字符串：选 or 不选</li>
</ul>
<p><strong>选的条件</strong>：</p>
<ol>
<li>字符串内部不能有重复字符</li>
<li>与当前已选字符串字符集不能冲突</li>
</ol>
<p><strong>状态设计</strong>：</p>
<ul>
<li>使用 boolean[26] 维护字符占用情况</li>
</ul>
<p> 典型的「<strong>集合冲突约束型回溯</strong>」</p>
<hr>
<h3 id="2212-射箭比赛中的最大得分"><a href="#2212-射箭比赛中的最大得分" class="headerlink" title="2212. 射箭比赛中的最大得分"></a>2212. 射箭比赛中的最大得分</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>枚举每个得分区间是否争夺</li>
</ul>
<p><strong>选的条件</strong>：</p>
<ul>
<li>剩余箭数 ≥ alice[i] + 1</li>
</ul>
<p><strong>状态维护</strong>：</p>
<ul>
<li>剩余箭数</li>
<li>当前得分</li>
</ul>
<p>本质是 <strong>资源分配 + 子集枚举</strong></p>
<hr>
<h3 id="2698-求一个整数的惩罚数"><a href="#2698-求一个整数的惩罚数" class="headerlink" title="2698. 求一个整数的惩罚数"></a>2698. 求一个整数的惩罚数</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>对 <code>i²</code> 的字符串进行切割</li>
<li>每一刀：切 or 不切</li>
</ul>
<p><strong>选的条件</strong>：</p>
<ul>
<li>当前分割出的数字之和 ≤ i</li>
</ul>
<p>本质是 <strong>字符串分割型子集回溯</strong></p>
<hr>
<h3 id="93-复原-IP-地址（从答案角度分析）"><a href="#93-复原-IP-地址（从答案角度分析）" class="headerlink" title="93. 复原 IP 地址（从答案角度分析）"></a>93. 复原 IP 地址（从答案角度分析）</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>字符串分割，一共分割为 4 段</li>
</ul>
<ul>
<li>枚举第 i 段从哪里分割</li>
</ul>
<p><strong>隐含条件（关键）</strong>：</p>
<ol>
<li>必须切成 <strong>4 段</strong></li>
<li>每段 ∈ [0,255]</li>
<li>不能有前导 0</li>
</ol>
<p>带<strong>分割约束</strong>的字符串回溯</p>
<hr>
<h2 id="五、子集型回溯的优化与剪枝"><a href="#五、子集型回溯的优化与剪枝" class="headerlink" title="五、子集型回溯的优化与剪枝"></a>五、子集型回溯的优化与剪枝</h2><h3 id="条件剪枝（最常见）"><a href="#条件剪枝（最常见）" class="headerlink" title="条件剪枝（最常见）"></a>条件剪枝（最常见）</h3><ul>
<li>选之前判断是否合法</li>
<li>不合法直接跳过</li>
</ul>
<h3 id="提前终止（上界剪枝）"><a href="#提前终止（上界剪枝）" class="headerlink" title="提前终止（上界剪枝）"></a>提前终止（上界剪枝）</h3><ul>
<li>剩余元素即使全选，也不可能更优</li>
<li>直接 return</li>
</ul>
<h3 id="强制选择"><a href="#强制选择" class="headerlink" title="强制选择"></a>强制选择</h3><ul>
<li>剩余元素数 ≤ 剩余配额</li>
<li>不再分支，直接全选</li>
</ul>
<hr>
<h2 id="六、心得体会与方法论总结"><a href="#六、心得体会与方法论总结" class="headerlink" title="六、心得体会与方法论总结"></a>六、心得体会与方法论总结</h2><ul>
<li>子集型回溯本质是一种<strong>暴力但系统的枚举方法</strong></li>
<li>通过“选 &#x2F; 不选”两条分支，可以<strong>完整覆盖解空间</strong></li>
<li>时间复杂度通常为 <code>O(2^n)</code>，但<strong>剪枝决定了实际性能</strong></li>
<li>带条件的子集回溯，核心是：<ul>
<li><strong>把“是否能选”的逻辑抽离成 check</strong></li>
<li>让 DFS 结构保持干净、统一</li>
</ul>
</li>
<li>很多看似不同的题（资源分配、字符串切割、组合选择），<strong>在建模层面是同一类问题</strong></li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/08/algorithms/backtracking/2026-1-8-backtracking-subset-practice/" data-id="cmkbbdw1c000m5w8tesxvad3t" data-title="子集型回溯方法论得应用（2026-01-08）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-6-backtracking-subset" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/06/algorithms/backtracking/2026-1-6-backtracking-subset/" class="article-date">
  <time class="dt-published" datetime="2026-01-06T05:00:00.000Z" itemprop="datePublished">2026-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/06/algorithms/backtracking/2026-1-6-backtracking-subset/">子集型回溯（2026-01-06）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>子集型回溯应用范围：子集&#x2F;组合&#x2F;切分字符串&#x2F;按位选择等“枚举所有可能”的题。</p>
</blockquote>
<h3 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h3><ul>
<li>子集</li>
<li>电话号码字母组合</li>
<li>分割回文串</li>
</ul>
<h3 id="扩展题目"><a href="#扩展题目" class="headerlink" title="扩展题目"></a>扩展题目</h3><ul>
<li>二叉树的所有路径</li>
<li>路径总和 II </li>
<li>字母大小写全排列</li>
</ul>
<hr>
<h2 id="1-什么是回溯？"><a href="#1-什么是回溯？" class="headerlink" title="1. 什么是回溯？"></a>1. 什么是回溯？</h2><p>以集合 <code>(1,2,3)</code> 的子集为例：我们可以选择 <code>1</code>，也可以“退回去”不选 <code>1</code> 改选 <code>2</code>，再选 <code>3</code>。<br> 这种<strong>在构造答案的过程中回退到上一步、去探索其它分支</strong>的现象就是回溯。</p>
<p>回溯通常伴随递归，而不是循环：</p>
<ul>
<li>循环适合固定层数（例如 2 层、3 层嵌套）。</li>
<li>但回溯题的“层数”往往<strong>未知或很深</strong>（例如字符串切分、树路径、排列组合），循环表达能力有限。</li>
<li>递归天然对应一棵“决策树”的深度优先遍历（DFS），更适合回溯。</li>
</ul>
<hr>
<h2 id="2-用“树”和“路径”理解回溯"><a href="#2-用“树”和“路径”理解回溯" class="headerlink" title="2. 用“树”和“路径”理解回溯"></a>2. 用“树”和“路径”理解回溯</h2><p>把回溯理解成 <strong>DFS 遍历一棵决策树</strong>最直观：</p>
<ul>
<li>每走到一个节点，我们都处于一条“根 → 当前节点”的路径上</li>
<li>用 <code>path</code> 维护这条路径</li>
<li>当到达满足条件的位置（通常是叶子，或某些题的节点），把 <code>path</code> 记录到 <code>ans</code></li>
</ul>
<p>关键点：<strong>回溯 &#x3D; 递归返回 + 恢复现场</strong></p>
<hr>
<h2 id="3-恢复现场：为什么必须做？"><a href="#3-恢复现场：为什么必须做？" class="headerlink" title="3. 恢复现场：为什么必须做？"></a>3. 恢复现场：为什么必须做？</h2><p>在 DFS 过程中我们经常会：</p>
<ol>
<li>把一个选择加入 <code>path</code></li>
<li>递归深入</li>
<li>返回时必须撤销这个选择，否则 <code>path</code> 会“污染”后续分支</li>
</ol>
<p>常见的两种恢复方式：</p>
<ul>
<li><strong>数据覆盖</strong>：适用于“固定长度答案”（常用数组保存）</li>
<li><strong>回滚（removeLast）</strong>：适用于 <code>List</code> &#x2F; <code>StringBuilder</code> 这种动态结构</li>
</ul>
<blockquote>
<p><strong>add → dfs → removeLast</strong><br> 只要你“改变了状态”，回来的时候就要“撤销状态”。</p>
</blockquote>
<hr>
<h2 id="4-子集型回溯的两大思路"><a href="#4-子集型回溯的两大思路" class="headerlink" title="4. 子集型回溯的两大思路"></a>4. 子集型回溯的两大思路</h2><p>回溯题通常两种建模方式：</p>
<h3 id="思路-A：从输入角度——“当前元素选不选”"><a href="#思路-A：从输入角度——“当前元素选不选”" class="headerlink" title="思路 A：从输入角度——“当前元素选不选”"></a>思路 A：从输入角度——“当前元素选不选”</h3><ul>
<li>每个输入元素对应一层决策：<strong>选 &#x2F; 不选</strong></li>
<li>决策树通常是二叉树</li>
<li><strong>答案通常在叶子节点收集</strong></li>
</ul>
<h3 id="思路-B：从答案角度——“当前位置选哪个元素”"><a href="#思路-B：从答案角度——“当前位置选哪个元素”" class="headerlink" title="思路 B：从答案角度——“当前位置选哪个元素”"></a>思路 B：从答案角度——“当前位置选哪个元素”</h3><ul>
<li>每一层表示“答案的当前位选什么元素”</li>
<li>用 <code>startIndex</code> 控制下一层枚举起点，避免重复</li>
<li><strong>答案通常在节点收集</strong>（因为走到任意节点都代表一个合法子集）</li>
</ul>
<blockquote>
<p>两种思路都能做 78 子集；<br> 哪个更顺手取决于题型，有时“答案角度”的树更小，有时“选不选”更直观。</p>
</blockquote>
<hr>
<h2 id="5-画树：回溯卡住时最有效的解法"><a href="#5-画树：回溯卡住时最有效的解法" class="headerlink" title="5. 画树：回溯卡住时最有效的解法"></a>5. 画树：回溯卡住时最有效的解法</h2><p>当你对“递归参数是什么、何时收集答案、怎么剪枝”不明确时：</p>
<ul>
<li>先画出<strong>决策树</strong></li>
<li>每一层代表什么？</li>
<li>每条边代表什么选择？</li>
<li>哪些节点是合法答案？</li>
</ul>
<blockquote>
<p><strong>画树能直接定位：答案在哪里收集 + 哪一步需要回溯。</strong></p>
</blockquote>
<hr>
<h2 id="6-结合题目：78-子集（两种思路）"><a href="#6-结合题目：78-子集（两种思路）" class="headerlink" title="6. 结合题目：78 子集（两种思路）"></a>6. 结合题目：78 子集（两种思路）</h2><h3 id="6-1-解法-1：枚举输入元素选不选（叶子收集答案）"><a href="#6-1-解法-1：枚举输入元素选不选（叶子收集答案）" class="headerlink" title="6.1 解法 1：枚举输入元素选不选（叶子收集答案）"></a>6.1 解法 1：枚举输入元素选不选（叶子收集答案）</h3><blockquote>
<p>特点：二叉决策树；当 <code>i == nums.length</code> 才表示一条路径完全确定，因此在叶子收集。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int i, int[] nums, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans) &#123;</span><br><span class="line">    // 递归边界：输入枚举完了，path 是一种完整选择</span><br><span class="line">    if (i == nums.length) &#123;</span><br><span class="line">        ans.add(new ArrayList&lt;&gt;(path)); // 注意要拷贝</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1) 不选 nums[i]</span><br><span class="line">    dfs(i + 1, nums, path, ans);</span><br><span class="line"></span><br><span class="line">    // 2) 选 nums[i]</span><br><span class="line">    path.add(nums[i]);</span><br><span class="line">    dfs(i + 1, nums, path, ans);</span><br><span class="line">    path.removeLast(); // 恢复现场</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><strong>叶子收集</strong>：因为只有到 <code>i==n</code> 才能确定“每个元素选没选”</li>
<li><strong>必须拷贝 path</strong>：否则 ans 里存的是同一个引用，后续回滚会影响已保存答案</li>
<li><strong>恢复现场</strong>：每次 add 后都要 removeLast</li>
</ul>
<hr>
<h3 id="6-2-解法-2：枚举第-i-个答案选哪个元素（节点收集答案）"><a href="#6-2-解法-2：枚举第-i-个答案选哪个元素（节点收集答案）" class="headerlink" title="6.2 解法 2：枚举第 i 个答案选哪个元素（节点收集答案）"></a>6.2 解法 2：枚举第 i 个答案选哪个元素（节点收集答案）</h3><blockquote>
<p>特点：每个节点都是一个子集，因此走到节点就可记录；用 <code>startIndex</code> 防止重复。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int start, int[] nums, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path) &#123;</span><br><span class="line">    // 由于每个节点都是一个合法子集，所以直接记录当前 path</span><br><span class="line">    ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">    // 枚举下一位选哪个元素：只能从 start 往后选，保证不出现 (2,1) 这种重复顺序</span><br><span class="line">    for (int j = start; j &lt; nums.length; j++) &#123;</span><br><span class="line">        path.add(nums[j]);</span><br><span class="line">        dfs(j + 1, nums, ans, path);</span><br><span class="line">        path.removeLast(); // 回滚</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>你需要牢记的点：</strong></p>
<ul>
<li><strong>节点收集</strong>：因为任何时刻的 <code>path</code> 都是一个合法子集</li>
<li><strong>startIndex 是去重本质</strong>：规定递增选取顺序，避免同一组合的不同排列</li>
<li>这类写法也是“组合类题”通用模板（如组合总和、组合数等）</li>
</ul>
<hr>
<h2 id="7-String-join：在回溯里怎么用？和-StringBuilder-有什么关系？"><a href="#7-String-join：在回溯里怎么用？和-StringBuilder-有什么关系？" class="headerlink" title="7. String.join：在回溯里怎么用？和 StringBuilder 有什么关系？"></a>7. String.join：在回溯里怎么用？和 StringBuilder 有什么关系？</h2><p>在题解中看到有人用了 <code>String.join()</code>，它很适合把结果“输出成字符串”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; path = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">String s = String.join(&quot;-&quot;, path); // &quot;a-b-c&quot;</span><br></pre></td></tr></table></figure>

<p>但需要注意它和 <code>StringBuilder / StringJoiner</code> 的定位不同：</p>
<ul>
<li><strong>String.join</strong>：一次性把已有的字符串集合拼起来（更像“格式化输出”）</li>
<li><strong>StringBuilder</strong>：回溯过程中不断 append &#x2F; delete（更像“构造过程中的状态”）</li>
<li><strong>StringJoiner</strong>：更偏“带前后缀的 join”，比如 <code>&quot;[a,b,c]&quot;</code></li>
</ul>
<p>在回溯题中一般推荐：</p>
<ul>
<li>构造过程：用 <strong>StringBuilder</strong>（append + deleteCharAt 回滚）</li>
<li>输出阶段：需要展示路径时用 <strong>String.join</strong>（更清爽）</li>
</ul>
<hr>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><h3 id="模板-1（选不选，叶子收集）"><a href="#模板-1（选不选，叶子收集）" class="headerlink" title="模板 1（选不选，叶子收集）"></a>模板 1（选不选，叶子收集）</h3><ul>
<li>参数：<code>i</code></li>
<li>收集：<code>i == n</code></li>
<li>结构：先不选，再选（选完要回滚）</li>
</ul>
<h3 id="模板-2（答案角度，节点收集）"><a href="#模板-2（答案角度，节点收集）" class="headerlink" title="模板 2（答案角度，节点收集）"></a>模板 2（答案角度，节点收集）</h3><ul>
<li>参数：<code>start</code></li>
<li>收集：进入 dfs 就收集</li>
<li>结构：for 从 start 枚举，递归 dfs(start +1)，回滚</li>
</ul>
<hr>
<h2 id="9-心得体会"><a href="#9-心得体会" class="headerlink" title="9. 心得体会"></a>9. 心得体会</h2><ul>
<li>回溯的本质是<strong>DFS 遍历决策树</strong>，<code>path</code> 记录当前路径，<code>ans</code> 收集答案。</li>
<li>回溯一定伴随<strong>恢复现场</strong>：add → dfs → removeLast。</li>
<li>子集型题最常用两种建模：<ul>
<li><strong>选不选（叶子收集）</strong></li>
<li><strong>选哪个（节点收集 + startIndex 去重）</strong></li>
</ul>
</li>
<li>思路不清楚时，<strong>画树是最高效的破局方法</strong>。</li>
<li><code>String.join</code> 更适合输出拼接；回溯构造过程更推荐 <code>StringBuilder</code> 做状态并回滚。</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/06/algorithms/backtracking/2026-1-6-backtracking-subset/" data-id="cmkbbdw1b000k5w8tgt0a8h94" data-title="子集型回溯（2026-01-06）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MyBatis/">MyBatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MyBatis/ssm/">ssm</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/">递归</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/">链表</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/" rel="tag">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL%E4%BC%98%E5%8C%96/" rel="tag">SQL优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/druid/" rel="tag">druid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/" rel="tag">jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis-plus/" rel="tag">mybatis-plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml%E6%98%A0%E5%B0%84/" rel="tag">xml映射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" rel="tag">事务原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F/" rel="tag">先序、中序、后序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/" rel="tag">删除链表节点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81mysql/" rel="tag">动态mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" rel="tag">反转链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" rel="tag">学习计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">层序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" rel="tag">快慢指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" rel="tag">数据库锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/" rel="tag">时间复杂度优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" rel="tag">深度优先遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">由遍历序列生成二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%86%E5%9B%BE/" rel="tag">视图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" rel="tag">触发器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 10px;">SQL优化</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/druid/" style="font-size: 10px;">druid</a> <a href="/tags/jdbc/" style="font-size: 12.5px;">jdbc</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/mybatis-plus/" style="font-size: 10px;">mybatis-plus</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/xml%E6%98%A0%E5%B0%84/" style="font-size: 10px;">xml映射</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" style="font-size: 10px;">事务原理</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 20px;">二叉树</a> <a href="/tags/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F/" style="font-size: 12.5px;">先序、中序、后序</a> <a href="/tags/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/" style="font-size: 10px;">删除链表节点</a> <a href="/tags/%E5%8A%A8%E6%80%81mysql/" style="font-size: 10px;">动态mysql</a> <a href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">反转链表</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 17.5px;">回溯</a> <a href="/tags/%E5%AD%90%E9%9B%86/" style="font-size: 12.5px;">子集</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 10px;">学习计划</a> <a href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">层序遍历</a> <a href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" style="font-size: 10px;">快慢指针</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%8E%92%E5%88%97/" style="font-size: 10px;">排列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" style="font-size: 10px;">数据库锁</a> <a href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/" style="font-size: 10px;">时间复杂度优化</a> <a href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" style="font-size: 10px;">最近公共祖先</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" style="font-size: 12.5px;">深度优先遍历</a> <a href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">热部署</a> <a href="/tags/%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">由遍历序列生成二叉树</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%84%E5%90%88/" style="font-size: 10px;">组合</a> <a href="/tags/%E8%A7%86%E5%9B%BE/" style="font-size: 10px;">视图</a> <a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" style="font-size: 10px;">触发器</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 12.5px;">记录</a> <a href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" style="font-size: 12.5px;">记忆化搜索</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 17.5px;">递归</a> <a href="/tags/%E9%80%92%E6%8E%A8/" style="font-size: 12.5px;">递推</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">配置</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">一月 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">十二月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/">Spring Boot 配置与测试实战复盘</a>
          </li>
        
          <li>
            <a href="/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/">从回溯到记忆化搜索到递推：动态规划巩固练习</a>
          </li>
        
          <li>
            <a href="/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/">动态规划：从回溯到记忆化搜索，再到递推</a>
          </li>
        
          <li>
            <a href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/">排列型回溯</a>
          </li>
        
          <li>
            <a href="/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/">回溯总结篇</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 Tingfeng Li<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>