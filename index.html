<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>廷风的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="记录 Java 后端学习与项目实践的技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="廷风的技术博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="廷风的技术博客">
<meta property="og:description" content="记录 Java 后端学习与项目实践的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tingfeng Li">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="廷风的技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">廷风的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java 后端开发</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-algorithms/backtracking/2026-1-10-Permutation-backtracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/" class="article-date">
  <time class="dt-published" datetime="2026-01-10T05:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/">排列型回溯</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>排列型回溯的本质是「<strong>每一层都可以从所有未使用的元素中重新选择</strong>」，顺序不同即视为不同答案，通常通过 <strong>used &#x2F; flag 数组</strong> 来记录当前路径中已使用的元素。</p>
</blockquote>
<hr>
<h2 id="一、什么是排列型回溯？"><a href="#一、什么是排列型回溯？" class="headerlink" title="一、什么是排列型回溯？"></a>一、什么是排列型回溯？</h2><p>在回溯问题中，<strong>排列型问题</strong>有一个非常鲜明的特征：</p>
<ul>
<li><strong>元素相同，但顺序不同，算作不同答案</strong></li>
<li>例如：<ul>
<li><code>[1, 2]</code> 和 <code>[2, 1]</code> 是 <strong>两个不同的解</strong></li>
</ul>
</li>
</ul>
<p>这与我们之前做过的两类问题形成了清晰对比：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否关心顺序</th>
<th>是否允许重复选</th>
</tr>
</thead>
<tbody><tr>
<td>子集型</td>
<td>❌ 不关心</td>
<td>每个元素只选 &#x2F; 不选</td>
</tr>
<tr>
<td>组合型</td>
<td>❌ 不关心</td>
<td>对于选或不选有约束条件</td>
</tr>
<tr>
<td><strong>排列型</strong></td>
<td>✅ 关心</td>
<td><strong>每一轮可选任意当前轮次未使用元素</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="二、排列型回溯的核心思想"><a href="#二、排列型回溯的核心思想" class="headerlink" title="二、排列型回溯的核心思想"></a>二、排列型回溯的核心思想</h2><p>从「<strong>枚举答案的角度</strong>」来看，排列型回溯有两个关键点：</p>
<h3 id="每一层都在“选位置”，而不是“选元素范围”"><a href="#每一层都在“选位置”，而不是“选元素范围”" class="headerlink" title="每一层都在“选位置”，而不是“选元素范围”"></a>每一层都在“选位置”，而不是“选元素范围”</h3><ul>
<li>第 0 位选谁？</li>
<li>第 1 位选谁？</li>
<li>第 2 位选谁？</li>
</ul>
<p>每一层都可以从 <strong>当前轮所有尚未使用的元素中选择</strong></p>
<hr>
<h3 id="必须显式记录「当前路径中已使用的元素」"><a href="#必须显式记录「当前路径中已使用的元素」" class="headerlink" title="必须显式记录「当前路径中已使用的元素」"></a>必须显式记录「当前路径中已使用的元素」</h3><p>因此，排列型回溯 <strong>一定需要</strong> 一个 <code>used / flag</code> 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">used[i] = true  → nums[i] 已经在当前排列中使用过</span><br><span class="line">used[i] = false → 当前轮次仍可选择 nums[i]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、基础题目分析"><a href="#三、基础题目分析" class="headerlink" title="三、基础题目分析"></a>三、基础题目分析</h2><h3 id="46-全排列（Permutations）"><a href="#46-全排列（Permutations）" class="headerlink" title="46. 全排列（Permutations）"></a>46. 全排列（Permutations）</h3><h4 id="问题特征"><a href="#问题特征" class="headerlink" title="问题特征"></a>问题特征</h4><ul>
<li>目标：生成数组的所有排列</li>
<li>终止条件：<strong>当前路径长度 &#x3D;&#x3D; nums.length</strong></li>
<li>每一层：从所有 <code>used[i] == false</code> 的元素中选一个</li>
</ul>
<hr>
<h4 id="核心实现思路"><a href="#核心实现思路" class="headerlink" title="核心实现思路"></a>核心实现思路</h4><ol>
<li>使用 <code>path</code> 记录当前排列</li>
<li>使用 <code>used[]</code> 标记哪些元素已被选</li>
<li>当 <code>path.size() == nums.length</code> 时，记录答案</li>
<li>回溯时恢复现场（<code>used[i] = false</code>）</li>
</ol>
<hr>
<h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><ul>
<li><strong>排列的深度 &#x3D; nums.length</strong></li>
<li><strong>叶子节点数量 &#x3D; n!</strong></li>
<li><code>used[]</code> 的作用是：<strong>保证每个元素在同一条路径中只出现一次</strong></li>
</ul>
<hr>
<h3 id="51-N-皇后（N-Queens）"><a href="#51-N-皇后（N-Queens）" class="headerlink" title="51. N 皇后（N-Queens）"></a>51. N 皇后（N-Queens）</h3><p>这是一个<strong>非常经典的“受限排列问题”</strong>。</p>
<hr>
<h4 id="问题拆解"><a href="#问题拆解" class="headerlink" title="问题拆解"></a>问题拆解</h4><ul>
<li>每一行只能放一个皇后</li>
<li>每一列只能放一个皇后</li>
<li>皇后不能在同一条对角线上</li>
</ul>
<hr>
<h4 id="建模方式（非常关键）"><a href="#建模方式（非常关键）" class="headerlink" title="建模方式（非常关键）"></a>建模方式（非常关键）</h4><p>用一个一维数组 <code>queens</code> 表示棋盘状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queens[row] = col</span><br></pre></td></tr></table></figure>

<p>含义是：</p>
<ul>
<li>第 <code>row</code> 行</li>
<li>第 <code>col</code> 列</li>
<li>放置了一个皇后</li>
</ul>
<hr>
<h4 id="为什么这是一个排列问题？"><a href="#为什么这是一个排列问题？" class="headerlink" title="为什么这是一个排列问题？"></a>为什么这是一个排列问题？</h4><ul>
<li>行天然不重复（递归层数保证）</li>
<li>列不能重复 → <code>queens</code> 本质是一个 <strong>列索引的全排列</strong></li>
<li>对角线限制 → 给这个全排列 <strong>增加合法性约束</strong></li>
</ul>
<hr>
<h4 id="对角线判断条件"><a href="#对角线判断条件" class="headerlink" title="对角线判断条件"></a>对角线判断条件</h4><p>若两个皇后在 <code>(r1, c1)</code> 和 <code>(r2, c2)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|r1 - r2| == |c1 - c2| → 在同一对角线</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="本质总结"><a href="#本质总结" class="headerlink" title="本质总结"></a>本质总结</h4><blockquote>
<p><strong>N 皇后 &#x3D; 带约束条件的全排列问题</strong></p>
</blockquote>
<hr>
<h2 id="四、扩展题目"><a href="#四、扩展题目" class="headerlink" title="四、扩展题目"></a>四、扩展题目</h2><h3 id="357-统计各位数字都不同的数字个数"><a href="#357-统计各位数字都不同的数字个数" class="headerlink" title="357. 统计各位数字都不同的数字个数"></a>357. 统计各位数字都不同的数字个数</h3><p>这道题虽然形式不同，但本质仍然是：</p>
<ul>
<li>在每一位上选数字</li>
<li>同一个数字不能重复使用</li>
<li>位数不同，形成不同答案</li>
</ul>
<p>本质是 <strong>多层排列 + 剪枝计数</strong>，而不是生成具体排列。</p>
<hr>
<h2 id="五、排列型回溯的时间复杂度"><a href="#五、排列型回溯的时间复杂度" class="headerlink" title="五、排列型回溯的时间复杂度"></a>五、排列型回溯的时间复杂度</h2><p>排列问题的时间复杂度通常非常直观：</p>
<ul>
<li><p><strong>等于叶子节点数量</strong></p>
</li>
<li><p>对于 n 个元素的全排列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度 = O(n!) // 画树分析节点数量得到</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这是排列问题不可避免的代价，因此：</p>
<ul>
<li>剪枝尤为重要</li>
<li>约束条件越多，搜索空间越小</li>
</ul>
<hr>
<h2 id="六、心得体会与方法论总结"><a href="#六、心得体会与方法论总结" class="headerlink" title="六、心得体会与方法论总结"></a>六、心得体会与方法论总结</h2><h3 id="排列型回溯的固定模板"><a href="#排列型回溯的固定模板" class="headerlink" title="排列型回溯的固定模板"></a>排列型回溯的固定模板</h3><ol>
<li>路径长度固定（通常等于元素个数）</li>
<li>每一层从 <strong>所有未使用元素中选择</strong></li>
<li>使用 <code>used[] / flag[]</code> 记录使用状态</li>
<li>回溯时一定要 <strong>恢复现场</strong></li>
</ol>
<hr>
<h3 id="与前两类回溯的根本区别"><a href="#与前两类回溯的根本区别" class="headerlink" title="与前两类回溯的根本区别"></a>与前两类回溯的根本区别</h3><blockquote>
<p><strong>是否允许在下一层重新选择之前没选过的元素</strong></p>
</blockquote>
<ul>
<li>子集 &#x2F; 组合：「之前轮次选过，就不能再选」</li>
<li>排列：「只要当前路径没用过，就可以选」</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/" data-id="cmk8gbsq8000eiw8t2vvxcegw" data-title="排列型回溯" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-10-backtracking-summary" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/" class="article-date">
  <time class="dt-published" datetime="2026-01-10T05:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/">回溯总结篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在系统完成回溯相关题型后，本篇博客旨在对 <strong>回溯（Backtracking）这一类算法思想进行统一分析与方法论总结</strong>，帮助建立稳定的解题模型。</p>
</blockquote>
<hr>
<h2 id="一、什么是回溯？"><a href="#一、什么是回溯？" class="headerlink" title="一、什么是回溯？"></a>一、什么是回溯？</h2><p><strong>回溯不是一种具体算法，而是一种搜索思想。</strong></p>
<p>从直观角度理解，回溯可以看作是「<strong>悔棋</strong>」：</p>
<ul>
<li>当前选择了一条路往下走</li>
<li>发现这条路走不通，或者已经走完</li>
<li><strong>退回到上一个状态</strong></li>
<li>改选另一条路继续尝试</li>
</ul>
<hr>
<h3 id="回溯与-DFS-的关系"><a href="#回溯与-DFS-的关系" class="headerlink" title="回溯与 DFS 的关系"></a>回溯与 DFS 的关系</h3><p>回溯通常通过 <strong>递归 + 深度优先遍历（DFS）</strong> 实现。</p>
<ul>
<li>DFS 负责：<strong>一路向下探索</strong></li>
<li>回溯负责：<strong>返回时撤销选择，恢复到上一个状态</strong></li>
</ul>
<p>如果把搜索过程看作一棵树：</p>
<ul>
<li>向子节点走 → 递归深入</li>
<li>回到父节点 → 回溯</li>
<li>访问兄弟节点 → 新的选择</li>
</ul>
<hr>
<h3 id="什么是「增量构造答案」？"><a href="#什么是「增量构造答案」？" class="headerlink" title="什么是「增量构造答案」？"></a>什么是「增量构造答案」？</h3><blockquote>
<p><strong>增量构造答案</strong>：<br> 答案不是一开始就完整出现的，而是<strong>在搜索过程中一步步被“拼”出来的</strong>。</p>
</blockquote>
<p>以集合 <code>(1, 2, 3)</code> 的子集问题为例：</p>
<ul>
<li>我们不会一开始就知道一个完整子集</li>
<li>而是：<ol>
<li>先决定：要不要 <code>1</code></li>
<li>再决定：要不要 <code>2</code></li>
<li>再决定：要不要 <code>3</code></li>
</ol>
</li>
<li>每一次选择，都会在当前路径上 <strong>“增加一点信息”</strong></li>
</ul>
<p>因此：</p>
<ul>
<li>当前路径 <code>path</code> 始终是一个 <strong>“未完成的答案”</strong></li>
<li>只有当满足终止条件时，它才成为一个 <strong>完整答案</strong></li>
</ul>
<p>这也是<strong>剪枝能成立的根本原因</strong>：</p>
<blockquote>
<p>如果在“构造过程中”已经不满足条件，就没必要继续往下走。</p>
</blockquote>
<hr>
<h2 id="二、回溯三问（解题核心视角）"><a href="#二、回溯三问（解题核心视角）" class="headerlink" title="二、回溯三问（解题核心视角）"></a>二、回溯三问（解题核心视角）</h2><p>在写回溯代码前，几乎所有题目都可以先回答这三个问题。</p>
<p>以 <strong>电话号码的字母组合</strong> 为例（用 <code>path</code> 记录路径）：</p>
<hr>
<h3 id="问题一：当前在做什么？"><a href="#问题一：当前在做什么？" class="headerlink" title="问题一：当前在做什么？"></a>问题一：当前在做什么？</h3><blockquote>
<p>当前这一层，我要决定什么？</p>
</blockquote>
<ul>
<li>决定 <code>path[i]</code> 填什么字母</li>
</ul>
<hr>
<h3 id="问题二：子问题是什么？"><a href="#问题二：子问题是什么？" class="headerlink" title="问题二：子问题是什么？"></a>问题二：子问题是什么？</h3><blockquote>
<p>在当前选择之后，还剩下什么问题没解决？</p>
</blockquote>
<ul>
<li>构造字符串中 <strong>索引 ≥ i 的部分</strong></li>
</ul>
<hr>
<h3 id="问题三：递归如何推进？"><a href="#问题三：递归如何推进？" class="headerlink" title="问题三：递归如何推进？"></a>问题三：递归如何推进？</h3><blockquote>
<p>当前层和下一层的关系是什么？</p>
</blockquote>
<ul>
<li>当前决定第 <code>i</code> 位</li>
<li>递归进入第 <code>i + 1</code> 位</li>
</ul>
<p><strong>只要这三点清楚，回溯的递归结构自然就出来了</strong></p>
<hr>
<h2 id="三、恢复现场（回溯的关键）"><a href="#三、恢复现场（回溯的关键）" class="headerlink" title="三、恢复现场（回溯的关键）"></a>三、恢复现场（回溯的关键）</h2><p>在 DFS + 回溯过程中，我们通常会经历：</p>
<ol>
<li>做出一个选择（加入 <code>path</code>）</li>
<li>递归深入</li>
<li>返回时 <strong>撤销这个选择</strong></li>
</ol>
<p>如果不撤销，就会导致：</p>
<ul>
<li>当前路径“污染”后续分支</li>
<li>结果错误或重复</li>
</ul>
<hr>
<h3 id="常见的两种恢复现场方式"><a href="#常见的两种恢复现场方式" class="headerlink" title="常见的两种恢复现场方式"></a>常见的两种恢复现场方式</h3><h4 id="回撤（push-pop）"><a href="#回撤（push-pop）" class="headerlink" title="回撤（push + pop）"></a>回撤（push + pop）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.add(x);</span><br><span class="line">dfs();</span><br><span class="line">path.remove(path.size() - 1);</span><br></pre></td></tr></table></figure>

<p>适合 <code>path</code> 长度不固定的情况。</p>
<hr>
<h4 id="覆盖（固定长度数组）"><a href="#覆盖（固定长度数组）" class="headerlink" title="覆盖（固定长度数组）"></a>覆盖（固定长度数组）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path[index] = x;</span><br><span class="line">dfs(index + 1);</span><br></pre></td></tr></table></figure>

<p>适合：</p>
<ul>
<li>全排列</li>
<li>固定长度字符串构造</li>
</ul>
<hr>
<h2 id="四、回溯的三种典型类型"><a href="#四、回溯的三种典型类型" class="headerlink" title="四、回溯的三种典型类型"></a>四、回溯的三种典型类型</h2><p>回溯题目并不是杂乱无章的，大多数都可以归入以下三类。</p>
<p>以数组 <code>[1, 2, 3]</code> 为例：</p>
<hr>
<h3 id="子集型回溯（选-不选）"><a href="#子集型回溯（选-不选）" class="headerlink" title="子集型回溯（选 &#x2F; 不选）"></a>子集型回溯（选 &#x2F; 不选）</h3><p><strong>核心问题</strong>：</p>
<blockquote>
<p>每个元素，选还是不选？</p>
</blockquote>
<h4 id="两种视角"><a href="#两种视角" class="headerlink" title="两种视角"></a>两种视角</h4><ul>
<li><strong>从输入视角</strong>：<ul>
<li>对每个元素做「选 &#x2F; 不选」决策</li>
<li>搜索树是 <strong>严格二叉树</strong></li>
<li>答案通常在叶子节点产生</li>
</ul>
</li>
<li><strong>从答案构造视角</strong>：<ul>
<li>枚举第 <code>i</code> 个答案位置选哪个元素</li>
<li>搜索树是 <strong>多叉树</strong></li>
<li>答案可以在每个节点产生</li>
</ul>
</li>
</ul>
<hr>
<h3 id="组合型回溯（子集-约束）"><a href="#组合型回溯（子集-约束）" class="headerlink" title="组合型回溯（子集 + 约束）"></a>组合型回溯（子集 + 约束）</h3><p>组合型回溯本质上是：</p>
<blockquote>
<p><strong>对子集型回溯增加“合法性约束 + 剪枝”</strong></p>
</blockquote>
<p>常见约束包括：</p>
<ul>
<li>选 <code>k</code> 个数</li>
<li>和等于 <code>target</code></li>
</ul>
<hr>
<h4 id="为什么可以剪枝？"><a href="#为什么可以剪枝？" class="headerlink" title="为什么可以剪枝？"></a>为什么可以剪枝？</h4><p>因为答案是<strong>增量构造的</strong>：</p>
<ul>
<li>如果当前路径已经：<ul>
<li>选多了</li>
<li>和超了</li>
<li>剩余元素不可能满足条件</li>
</ul>
</li>
<li>那么继续向下递归 <strong>一定不可能得到合法答案</strong></li>
</ul>
<p>可以提前返回，剪掉整棵子树。</p>
<hr>
<h3 id="排列型回溯（顺序不同即不同）"><a href="#排列型回溯（顺序不同即不同）" class="headerlink" title="排列型回溯（顺序不同即不同）"></a>排列型回溯（顺序不同即不同）</h3><p>排列型回溯的核心特征：</p>
<ul>
<li><strong>顺序敏感</strong></li>
<li><code>[1,2]</code> 和 <code>[2,1]</code> 是不同答案</li>
</ul>
<hr>
<h4 id="与前两类的本质区别"><a href="#与前两类的本质区别" class="headerlink" title="与前两类的本质区别"></a>与前两类的本质区别</h4><ul>
<li><p>子集 &#x2F; 组合：</p>
<blockquote>
<p>之前选过的元素，后面不能再选</p>
</blockquote>
</li>
<li><p>排列：</p>
<blockquote>
<p><strong>只要当前路径没用过，就可以选</strong></p>
</blockquote>
</li>
</ul>
<p>因此需要：</p>
<ul>
<li>一个 <code>used / flag</code> 数组</li>
<li>表示当前路径中哪些元素已经使用过</li>
</ul>
<hr>
<h2 id="五、统一的回溯伪代码模板"><a href="#五、统一的回溯伪代码模板" class="headerlink" title="五、统一的回溯伪代码模板"></a>五、统一的回溯伪代码模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        记录答案;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：当前层可选的所有选项) &#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtracking(下一层参数);</span><br><span class="line">        撤销选择; // 恢复现场</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、心得总结"><a href="#六、心得总结" class="headerlink" title="六、心得总结"></a>六、心得总结</h2><ul>
<li><p>回溯问题 <strong>不一定是“选或不选”</strong></p>
</li>
<li><p>但一定是 <strong>“做选择 → 走一条路 → 回退 → 换一条路”</strong></p>
</li>
<li><p>本质是：</p>
<blockquote>
<p><strong>在状态空间中系统性地枚举所有可能解</strong></p>
</blockquote>
</li>
</ul>
<p>一旦你能：</p>
<ul>
<li>明确「当前层在决定什么」</li>
<li>明确「路径代表什么」</li>
<li>明确「什么时候可以停、什么时候该剪」</li>
</ul>
<p>那么回溯题目就不再是“凭感觉写代码”，而是一个<strong>高度可复用的方法论问题</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/" data-id="cmk8gbsqa000liw8tfib1hq1z" data-title="回溯总结篇" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/ssm/springboot/2026-1-10-springboot-day02 " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/" class="article-date">
  <time class="dt-published" datetime="2026-01-09T16:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/">Spring Boot + SSMP 基础实战与问题复盘</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文基于一次完整的 Spring Boot 基础项目实践，总结了从<strong>实体类 → 数据层 → 业务层 → 表现层 → 前后端联调</strong>的开发流程，并重点记录了在整合 MyBatis-Plus、JUnit、分页插件等过程中遇到的典型问题及解决方案，作为后续复盘与查错参考。</p>
</blockquote>
<p>项目采用 <strong>单体架构（非前后端分离）</strong>，以熟悉 Spring Boot + MyBatis-Plus 的基础开发模式为目标。</p>
<h2 id="一、实体类开发（Entity）"><a href="#一、实体类开发（Entity）" class="headerlink" title="一、实体类开发（Entity）"></a>一、实体类开发（Entity）</h2><h3 id="1-数据库准备"><a href="#1-数据库准备" class="headerlink" title="1. 数据库准备"></a>1. 数据库准备</h3><ul>
<li>创建业务表（如 <code>tbl_book</code>）</li>
<li>初始化测试数据</li>
</ul>
<h3 id="2-实体类创建"><a href="#2-实体类创建" class="headerlink" title="2. 实体类创建"></a>2. 实体类创建</h3><ul>
<li>根据表结构创建实体类</li>
<li>使用 <strong>Lombok</strong> 简化样板代码（getter &#x2F; setter &#x2F; toString 等）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Book &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、数据层开发（CRUD）"><a href="#二、数据层开发（CRUD）" class="headerlink" title="二、数据层开发（CRUD）"></a>二、数据层开发（CRUD）</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>ORM 框架：<strong>MyBatis-Plus</strong></li>
<li>数据源：<strong>Druid</strong></li>
<li>测试框架：JUnit</li>
</ul>
<h3 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h3><ol>
<li>引入 MyBatis-Plus Starter</li>
<li>配置数据库连接信息</li>
<li>配置 MP 相关属性<ul>
<li>表名前缀（<code>table-prefix</code>）</li>
<li>主键策略（<code>id-type</code>）</li>
<li>SQL 日志（<code>log-impl</code>）</li>
</ul>
</li>
<li>使用 <code>BaseMapper&lt;T&gt;</code> 快速完成 CRUD</li>
<li>使用 <code>@Mapper</code> 或 <code>@MapperScan</code> 交给 Spring 管理</li>
<li>编写 Mapper 测试类验证功能</li>
</ol>
<hr>
<h2 id="三、问题复盘-①：测试类能运行，测试方法却报-NoSuchMethodError"><a href="#三、问题复盘-①：测试类能运行，测试方法却报-NoSuchMethodError" class="headerlink" title="三、问题复盘 ①：测试类能运行，测试方法却报 NoSuchMethodError"></a>三、问题复盘 ①：测试类能运行，测试方法却报 <code>NoSuchMethodError</code></h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><ul>
<li>直接运行测试类 ✔</li>
<li>单独运行测试方法 ❌ 报错：<code>NoSuchMethodError</code></li>
</ul>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ul>
<li><strong>Classpath 中存在多个 JUnit 版本</strong></li>
<li>Spring Boot 默认引入的测试依赖与本地环境冲突</li>
</ul>
<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><ul>
<li>尝试在 <code>pom.xml</code> 中强制覆盖 JUnit 版本 → ❌ 无效</li>
<li><strong>最终解决方案：降低 Spring Boot 版本</strong></li>
</ul>
<p>从 <strong>Spring Boot 4.x 降级到 Spring Boot 3.x</strong> 后问题消失</p>
<blockquote>
<p>结论：<br> <strong>测试相关问题优先排查：Spring Boot 版本 × Starter 版本 × IDE 运行方式</strong></p>
</blockquote>
<hr>
<h2 id="四、问题复盘-②：Spring-Boot-3-MyBatis-Plus-启动时报-Mapper-Bean-异常"><a href="#四、问题复盘-②：Spring-Boot-3-MyBatis-Plus-启动时报-Mapper-Bean-异常" class="headerlink" title="四、问题复盘 ②：Spring Boot 3 + MyBatis-Plus 启动时报 Mapper Bean 异常"></a>四、问题复盘 ②：Spring Boot 3 + MyBatis-Plus 启动时报 Mapper Bean 异常</h2><h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid bean definition with name &#x27;xxxMapper&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ul>
<li><code>@Mapper</code> ✔</li>
<li><code>@MapperScan</code> ✔</li>
<li>包路径无误 ✔</li>
</ul>
<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p><strong>Spring Boot 3 与 MyBatis-Plus Starter 版本不兼容</strong></p>
<h3 id="正确依赖方式"><a href="#正确依赖方式" class="headerlink" title="正确依赖方式"></a>正确依赖方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring Boot 2.x --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Spring Boot 3.x --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：<br> <strong>Spring Boot 3 必须使用 boot3 专用的 MyBatis-Plus Starter</strong></p>
</blockquote>
<hr>
<h2 id="五、问题复盘-③：配置了-IdType-AUTO，却生成了“雪花-ID”"><a href="#五、问题复盘-③：配置了-IdType-AUTO，却生成了“雪花-ID”" class="headerlink" title="五、问题复盘 ③：配置了 IdType.AUTO，却生成了“雪花 ID”"></a>五、问题复盘 ③：配置了 <code>IdType.AUTO</code>，却生成了“雪花 ID”</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><ul>
<li>实体类主键配置为 <code>IdType.AUTO</code></li>
<li>插入后 ID 却像雪花算法生成</li>
</ul>
<h3 id="真正原因"><a href="#真正原因" class="headerlink" title="真正原因"></a>真正原因</h3><p>并非 AUTO 失效，而是：</p>
<ul>
<li>之前使用过 <strong>雪花 ID 策略</strong></li>
<li>删除数据后，<strong>数据库的 <code>AUTO_INCREMENT</code> 未重置</strong></li>
<li>产生了“脏 ID ”</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_book AUTO_INCREMENT = 1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：<br> <strong>主键策略问题，一定要同时检查：代码配置 + 数据库状态</strong></p>
</blockquote>
<hr>
<h2 id="六、数据层开发（分页功能）"><a href="#六、数据层开发（分页功能）" class="headerlink" title="六、数据层开发（分页功能）"></a>六、数据层开发（分页功能）</h2><h3 id="MyBatis-Plus-分页-API"><a href="#MyBatis-Plus-分页-API" class="headerlink" title="MyBatis-Plus 分页 API"></a>MyBatis-Plus 分页 API</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testGetPage()&#123;</span><br><span class="line">    IPage&lt;Book&gt; page = new Page&lt;&gt;(2, 5);</span><br><span class="line">    bookMapper.selectPage(page, null);</span><br><span class="line"></span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页参数说明"><a href="#分页参数说明" class="headerlink" title="分页参数说明"></a>分页参数说明</h3><ul>
<li>当前页码</li>
<li>每页条数</li>
</ul>
<h3 id="必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）"><a href="#必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）" class="headerlink" title="必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）"></a>必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MPConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、问题复盘-④：分页不生效"><a href="#七、问题复盘-④：分页不生效" class="headerlink" title="七、问题复盘 ④：分页不生效"></a>七、问题复盘 ④：分页不生效</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>MyBatis-Plus <strong>将分页能力拆分为插件</strong></li>
<li>未引入解析 SQL 的依赖</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-jsqlparser&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.15&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、数据层开发（条件查询）"><a href="#八、数据层开发（条件查询）" class="headerlink" title="八、数据层开发（条件查询）"></a>八、数据层开发（条件查询）</h2><h3 id="普通条件构造（存在风险）"><a href="#普通条件构造（存在风险）" class="headerlink" title="普通条件构造（存在风险）"></a>普通条件构造（存在风险）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;Book&gt; qw = new QueryWrapper&lt;&gt;();</span><br><span class="line">qw.like(&quot;name&quot;, &quot;Spring&quot;);</span><br><span class="line">bookMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<p>❌ 问题：字段名是字符串，<strong>编译期无法检查</strong></p>
<hr>
<h3 id="Lambda-条件构造（推荐）"><a href="#Lambda-条件构造（推荐）" class="headerlink" title="Lambda 条件构造（推荐）"></a>Lambda 条件构造（推荐）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lqw.like(name != null, Book::getName, name);</span><br><span class="line">bookMapper.selectList(lqw);</span><br></pre></td></tr></table></figure>

<p>✅ 优点：</p>
<ul>
<li>编译期安全</li>
<li>支持条件开关</li>
<li>重构友好</li>
</ul>
<hr>
<h2 id="九、业务层开发（Service）"><a href="#九、业务层开发（Service）" class="headerlink" title="九、业务层开发（Service）"></a>九、业务层开发（Service）</h2><p>业务层职责：</p>
<blockquote>
<p><strong>组织业务逻辑，对数据层进行封装调用</strong></p>
</blockquote>
<p>开发步骤：</p>
<ol>
<li>定义 Service 接口</li>
<li>编写 ServiceImpl</li>
<li>注入 Mapper</li>
<li>编写测试验证逻辑正确性</li>
</ol>
<hr>
<h2 id="十、表现层开发（Controller）"><a href="#十、表现层开发（Controller）" class="headerlink" title="十、表现层开发（Controller）"></a>十、表现层开发（Controller）</h2><h3 id="核心工作"><a href="#核心工作" class="headerlink" title="核心工作"></a>核心工作</h3><ul>
<li>编写 REST Controller</li>
<li>接收参数</li>
<li>调用业务层</li>
<li>返回统一结果</li>
</ul>
<h3 id="参数接收注意点"><a href="#参数接收注意点" class="headerlink" title="参数接收注意点"></a>参数接收注意点</h3><ul>
<li>JSON 实体：<code>@RequestBody</code></li>
<li>路径变量：<code>@PathVariable</code></li>
</ul>
<p>使用 <strong>ApiFox</strong> 进行接口测试与调试。</p>
<hr>
<h2 id="十一、统一返回结果设计"><a href="#十一、统一返回结果设计" class="headerlink" title="十一、统一返回结果设计"></a>十一、统一返回结果设计</h2><p>为保证前后端交互一致性：</p>
<ul>
<li>封装统一响应对象</li>
<li>包含：<ul>
<li><code>code</code></li>
<li><code>data</code></li>
<li><code>msg</code></li>
</ul>
</li>
<li>同时考虑异常场景</li>
</ul>
<hr>
<h2 id="十二、前后端联调"><a href="#十二、前后端联调" class="headerlink" title="十二、前后端联调"></a>十二、前后端联调</h2><ul>
<li><p>将前端静态资源拷贝到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resources/static</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring Boot 自动托管静态资源</p>
</li>
<li><p>实现简单的前后端一体化访问</p>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次 Spring Boot 基础实战，我完成了：</p>
<ul>
<li>一条完整的 <strong>SSMP 开发链路</strong></li>
<li>多个 <strong>真实问题的排查与解决</strong></li>
<li>对 <strong>版本兼容性、插件机制、主键策略</strong> 的深入理解</li>
</ul>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/" data-id="cmk8gbsqi001diw8t3zp14308" data-title="Spring Boot + SSMP 基础实战与问题复盘" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis-plus/" rel="tag">mybatis-plus</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-9-Combinatorial backtracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/" class="article-date">
  <time class="dt-published" datetime="2026-01-09T04:00:00.000Z" itemprop="datePublished">2026-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/">组合型回溯 + 剪枝：从子集枚举到条件收敛</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="组合型回溯-剪枝"><a href="#组合型回溯-剪枝" class="headerlink" title="组合型回溯 + 剪枝"></a>组合型回溯 + 剪枝</h1><blockquote>
<p><strong>一句话总结</strong>：<br> 组合型回溯本质仍是子集型回溯，但通过“组合约束 + 单调性剪枝”，将指数级搜索空间大幅收缩，只遍历“有可能成为答案”的分支。</p>
</blockquote>
<hr>
<h2 id="一、什么是组合型回溯？"><a href="#一、什么是组合型回溯？" class="headerlink" title="一、什么是组合型回溯？"></a>一、什么是组合型回溯？</h2><p>在回溯问题中，我们通常会遇到两类经典模型：</p>
<ul>
<li><strong>子集型回溯</strong>：<br> 枚举所有可能的子集（选 &#x2F; 不选），不关心长度或数值约束</li>
<li><strong>组合型回溯</strong>：<br> 在子集枚举的基础上，<strong>只保留满足条件的组合</strong></li>
</ul>
<p>常见的组合约束包括：</p>
<ul>
<li>固定长度（如选 k 个数）</li>
<li>固定和（如和为 target）</li>
<li>结构合法性（如括号匹配、IP 段合法）</li>
</ul>
<p>因此，<strong>组合型回溯 &#x3D; 子集型回溯 + 条件约束 + 剪枝</strong>。</p>
<hr>
<h2 id="二、组合型回溯的核心思想"><a href="#二、组合型回溯的核心思想" class="headerlink" title="二、组合型回溯的核心思想"></a>二、组合型回溯的核心思想</h2><p>组合型回溯的关键并不在「怎么枚举」，而在于：</p>
<blockquote>
<p><strong>当前状态已经不可能构成合法解时，要尽早停止搜索</strong></p>
</blockquote>
<p>这正是剪枝的价值所在。</p>
<h3 id="常见剪枝维度"><a href="#常见剪枝维度" class="headerlink" title="常见剪枝维度"></a>常见剪枝维度</h3><ol>
<li><strong>数量剪枝</strong><ul>
<li>剩余可选元素 &lt; 还需要选的数量 → 直接返回</li>
</ul>
</li>
<li><strong>数值剪枝（选择元素为正）</strong><ul>
<li>当前和已经超过 target</li>
<li>即使选最大值，也无法达到 target</li>
</ul>
</li>
<li><strong>结构剪枝</strong><ul>
<li>不满足合法结构（如右括号多于左括号）</li>
</ul>
</li>
</ol>
<p>这些剪枝往往都依赖于一个核心性质：</p>
<blockquote>
<p><strong>单调性</strong>：<br> 当前状态不满足条件，向下扩展只会更不满足。</p>
</blockquote>
<hr>
<h2 id="三、典型题目拆解与剪枝思路"><a href="#三、典型题目拆解与剪枝思路" class="headerlink" title="三、典型题目拆解与剪枝思路"></a>三、典型题目拆解与剪枝思路</h2><h3 id="77-组合（Combinations）"><a href="#77-组合（Combinations）" class="headerlink" title="77. 组合（Combinations）"></a>77. 组合（Combinations）</h3><p><strong>目标</strong>：从 <code>[1…n]</code> 中选 <code>k</code> 个数</p>
<h4 id="关键剪枝"><a href="#关键剪枝" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ul>
<li><strong>数量剪枝</strong><ul>
<li>剩余数字个数 &lt; 还需要选择的数量 → 直接返回</li>
</ul>
</li>
<li><strong>提前返回</strong><ul>
<li>当已选数量 &#x3D;&#x3D; k，记录答案，不再向下搜索</li>
</ul>
</li>
</ul>
<h4 id="本质理解"><a href="#本质理解" class="headerlink" title="本质理解"></a>本质理解</h4><p>这是一个<strong>固定长度的组合问题</strong>，搜索树深度是确定的，剪枝点非常清晰。</p>
<hr>
<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h3><p><strong>目标</strong>：从 <code>[1…9]</code> 中选 <code>k</code> 个数，和为 <code>n</code></p>
<h4 id="关键剪枝-1"><a href="#关键剪枝-1" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ol>
<li><code>leftTarget &lt; 0</code><ul>
<li>所有数均为正数，后续必然无解</li>
</ul>
</li>
<li><code>leftTarget &gt; 剩余可选数字的最大可能和</code><ul>
<li>即使全选最大值，也无法凑够</li>
</ul>
</li>
<li>剩余数字个数 &lt; 还需要选择的数量</li>
</ol>
<h4 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h4><ul>
<li>同时利用了「<strong>一大一小</strong>」两种剪枝方向</li>
<li>体现出数值约束与数量约束的对称性</li>
</ul>
<hr>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><p><strong>目标</strong>：生成 <code>n</code> 对合法括号</p>
<h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><ul>
<li><code>left</code>：已使用左括号数量</li>
<li><code>right</code>：已使用右括号数量</li>
</ul>
<h4 id="剪枝规则"><a href="#剪枝规则" class="headerlink" title="剪枝规则"></a>剪枝规则</h4><ul>
<li><code>left &gt; n</code> → 非法</li>
<li><code>right &gt; left</code> → 非法</li>
</ul>
<h4 id="本质理解-1"><a href="#本质理解-1" class="headerlink" title="本质理解"></a>本质理解</h4><p>这道题可以视为一种<strong>带结构约束的组合回溯</strong>：</p>
<ul>
<li>“选” → 加左括号</li>
<li>“不选” → 加右括号（但有条件）</li>
</ul>
<p>本质不是排列，而是<strong>合法结构的组合生成</strong>。</p>
<hr>
<h3 id="39-组合总和（可重复选择）"><a href="#39-组合总和（可重复选择）" class="headerlink" title="39. 组合总和（可重复选择）"></a>39. 组合总和（可重复选择）</h3><p><strong>目标</strong>：元素可重复选，和为 target</p>
<h4 id="关键剪枝-2"><a href="#关键剪枝-2" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ol>
<li><p><code>leftTarget &lt; 0</code> → 直接返回</p>
</li>
<li><p><code>leftTarget == 0</code> → 记录答案并返回</p>
</li>
<li><p><strong>排序 + 剪枝</strong></p>
<p>若当前元素 &gt; <code>leftTarget</code>，后续元素更大，可直接 break</p>
</li>
</ol>
<h4 id="可重复选择的表达"><a href="#可重复选择的表达" class="headerlink" title="可重复选择的表达"></a>可重复选择的表达</h4><ul>
<li>使用 <code>dfs(i)</code> 表示<strong>当前元素可再次选择</strong></li>
<li>通过起始索引控制是否允许重复</li>
</ul>
<hr>
<h3 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a>93. 复原 IP 地址</h3><p><strong>目标</strong>：将字符串分割为 4 段合法 IP</p>
<h4 id="强剪枝条件"><a href="#强剪枝条件" class="headerlink" title="强剪枝条件"></a>强剪枝条件</h4><ol>
<li><p><strong>字符数量剪枝</strong></p>
<p>剩余字符数 ∉ <code>[剩余段数, 剩余段数 * 3]</code></p>
</li>
<li><p><strong>数值剪枝</strong></p>
<p>当前段 &gt; 255</p>
</li>
<li><p><strong>前导零剪枝</strong></p>
<p>段以 <code>0</code> 开头但长度 &gt; 1</p>
</li>
</ol>
<h4 id="补充思路"><a href="#补充思路" class="headerlink" title="补充思路"></a>补充思路</h4><ul>
<li>由于段数固定为 4</li>
<li>该题也可以用 <strong>三重循环</strong> 实现</li>
<li>但回溯解法在结构上更统一、可复用性更强</li>
</ul>
<hr>
<h2 id="四、方法论总结：如何写好组合型回溯？"><a href="#四、方法论总结：如何写好组合型回溯？" class="headerlink" title="四、方法论总结：如何写好组合型回溯？"></a>四、方法论总结：如何写好组合型回溯？</h2><h3 id="推荐解题步骤"><a href="#推荐解题步骤" class="headerlink" title="推荐解题步骤"></a>推荐解题步骤</h3><ol>
<li><p><strong>先不剪枝，写出正确解</strong></p>
</li>
<li><p>明确以下要素：</p>
<p>状态变量（路径、索引、剩余目标）</p>
<p>终止条件</p>
</li>
<li><p>回看搜索树，问自己：</p>
<p>当前状态已经不可能成功了吗？</p>
</li>
<li><p>将「不可能成功」的情况提前 return</p>
</li>
</ol>
<h3 id="一个重要认知"><a href="#一个重要认知" class="headerlink" title="一个重要认知"></a>一个重要认知</h3><blockquote>
<p>剪枝为了利用题目的<strong>单调性</strong>。</p>
</blockquote>
<ul>
<li>当前不满足 → 未来一定不满足</li>
<li>才是可以安全剪枝的前提</li>
</ul>
<hr>
<h2 id="五、个人心得体会"><a href="#五、个人心得体会" class="headerlink" title="五、个人心得体会"></a>五、个人心得体会</h2><ul>
<li><p><strong>组合型回溯并不是新的模型</strong><br> 它只是对子集型回溯的“<strong>条件收敛</strong>”</p>
</li>
<li><p>实战中：</p>
<p>先保证正确性、再逐步加剪枝，思路更清晰</p>
</li>
<li><p>多数高质量剪枝，都来源于：</p>
<ul>
<li>数量边界</li>
<li>数值上下界</li>
<li>结构合法性</li>
</ul>
</li>
</ul>
<p>当你能一眼看出「当前状态是否还有希望」，回溯题就不再是暴力搜索，而是<strong>受控的状态枚举</strong>。</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/" data-id="cmk8gbsqd000uiw8t1fwz3apb" data-title="组合型回溯 + 剪枝：从子集枚举到条件收敛" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/ssm/springboot/2026-1-9-springboot-day01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/09/backend/ssm/springboot/2026-1-9-springboot-day01/" class="article-date">
  <time class="dt-published" datetime="2026-01-08T16:00:00.000Z" itemprop="datePublished">2026-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/09/backend/ssm/springboot/2026-1-9-springboot-day01/">Spring Boot 基础入门与整合实践</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文记录了我在学习 Spring Boot 基础与整合 MyBatis、Druid 过程中的核心知识点，以及一次完整、真实的排错过程。<br>重点不在于“配置怎么写”，而在于<strong>理解 Spring Boot 自动配置的工作机制</strong>。</p>
</blockquote>
<hr>
<h2 id="一、Spring-Boot-简介"><a href="#一、Spring-Boot-简介" class="headerlink" title="一、Spring Boot 简介"></a>一、Spring Boot 简介</h2><p>Spring Boot 是由 Pivotal 团队提供的快速开发框架，目标是：</p>
<ul>
<li>简化 Spring 应用的初始搭建</li>
<li>减少繁琐的 XML &#x2F; Java 配置</li>
<li>通过 <strong>自动配置（Auto Configuration）+ Starter 机制</strong> 提升开发效率</li>
</ul>
<hr>
<h2 id="二、Spring-Boot-入门方式"><a href="#二、Spring-Boot-入门方式" class="headerlink" title="二、Spring Boot 入门方式"></a>二、Spring Boot 入门方式</h2><h3 id="2-1-创建方式说明"><a href="#2-1-创建方式说明" class="headerlink" title="2.1 创建方式说明"></a>2.1 创建方式说明</h3><ul>
<li>使用 IDEA &#x2F; 官网 &#x2F; 阿里云脚手架：<strong>需要联网</strong></li>
<li>手动创建 Maven 项目：<ul>
<li>继承 <code>spring-boot-starter-parent</code></li>
<li>手动编写启动类</li>
<li><strong>不需要联网</strong>（前提是本地仓库已有依赖）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="三、parent-与-starter-的作用区分"><a href="#三、parent-与-starter-的作用区分" class="headerlink" title="三、parent 与 starter 的作用区分"></a>三、<code>parent</code> 与 <code>starter</code> 的作用区分</h2><h3 id="3-1-parent：统一依赖版本管理"><a href="#3-1-parent：统一依赖版本管理" class="headerlink" title="3.1 parent：统一依赖版本管理"></a>3.1 parent：统一依赖版本管理</h3><p><code>spring-boot-starter-parent</code> 的作用是：</p>
<ul>
<li>统一管理常用依赖的版本</li>
<li>避免版本冲突</li>
<li>简化 pom 文件</li>
</ul>
<blockquote>
<p><strong>注意</strong>：<br> parent 只“管理版本”，并不会实际引入任何依赖。</p>
</blockquote>
<hr>
<h3 id="3-2-starter：功能级依赖集合"><a href="#3-2-starter：功能级依赖集合" class="headerlink" title="3.2 starter：功能级依赖集合"></a>3.2 starter：功能级依赖集合</h3><p>starter 的作用是：</p>
<ul>
<li>一次性引入某个技术栈所需的依赖</li>
<li>通过<strong>依赖传递</strong>减少配置成本</li>
</ul>
<p>例如：</p>
<ul>
<li><code>spring-boot-starter-web</code></li>
<li><code>spring-boot-starter-jdbc</code></li>
<li><code>mybatis-spring-boot-starter</code></li>
</ul>
<blockquote>
<p>parent + starter 解决的是 <strong>“配置复杂度”问题</strong></p>
</blockquote>
<hr>
<h2 id="四、Spring-Boot-启动类"><a href="#四、Spring-Boot-启动类" class="headerlink" title="四、Spring Boot 启动类"></a>四、Spring Boot 启动类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot01QuickstartApplication &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot01QuickstartApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动类的作用"><a href="#启动类的作用" class="headerlink" title="启动类的作用"></a>启动类的作用</h3><ul>
<li>标识这是一个 Spring Boot 应用</li>
<li>启动 Spring 容器</li>
<li>扫描当前包及其子包下的 Bean</li>
<li>返回值是 <code>ApplicationContext</code></li>
</ul>
<hr>
<h2 id="五、内嵌-Web-容器机制"><a href="#五、内嵌-Web-容器机制" class="headerlink" title="五、内嵌 Web 容器机制"></a>五、内嵌 Web 容器机制</h2><p>在引入 <code>spring-boot-starter-web</code> 后：</p>
<ul>
<li>默认内嵌 Tomcat</li>
<li>Spring 会创建并管理一个 Tomcat 对象</li>
<li>启动应用时自动启动 Web 服务器</li>
</ul>
<p>Spring Boot 也支持 Jetty、Undertow 等内嵌容器。</p>
<hr>
<h2 id="六、基础配置文件"><a href="#六、基础配置文件" class="headerlink" title="六、基础配置文件"></a>六、基础配置文件</h2><h3 id="6-1-配置文件类型与优先级"><a href="#6-1-配置文件类型与优先级" class="headerlink" title="6.1 配置文件类型与优先级"></a>6.1 配置文件类型与优先级</h3><p>Spring Boot 支持：</p>
<ul>
<li><code>application.properties</code></li>
<li><code>application.yml</code></li>
<li><code>application.yaml</code></li>
</ul>
<p>优先级（从高到低）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">properties &gt; yml &gt; yaml</span><br></pre></td></tr></table></figure>

<p>相同配置高优先级覆盖，未冲突配置全部生效。</p>
<hr>
<h3 id="6-2-为什么推荐-YAML"><a href="#6-2-为什么推荐-YAML" class="headerlink" title="6.2 为什么推荐 YAML"></a>6.2 为什么推荐 YAML</h3><ul>
<li>层级清晰</li>
<li>可读性更好</li>
<li>更适合复杂配置</li>
</ul>
<h4 id="YAML-核心规则"><a href="#YAML-核心规则" class="headerlink" title="YAML 核心规则"></a>YAML 核心规则</h4><ul>
<li>大小写敏感</li>
<li>缩进表示层级（只能用空格）</li>
<li><code>key: value</code> 中冒号后必须有空格</li>
<li><code>#</code> 表示注释</li>
</ul>
<hr>
<h3 id="6-3-YAML-数据绑定方式"><a href="#6-3-YAML-数据绑定方式" class="headerlink" title="6.3 YAML 数据绑定方式"></a>6.3 YAML 数据绑定方式</h3><h4 id="方式一：-Value"><a href="#方式一：-Value" class="headerlink" title="方式一：@Value"></a>方式一：<code>@Value</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;enterprise.name&#125;&quot;)</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure>

<h4 id="方式二：Environment"><a href="#方式二：Environment" class="headerlink" title="方式二：Environment"></a>方式二：<code>Environment</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment.getProperty(&quot;enterprise.name&quot;);</span><br></pre></td></tr></table></figure>

<h4 id="方式三（推荐）：-ConfigurationProperties"><a href="#方式三（推荐）：-ConfigurationProperties" class="headerlink" title="方式三（推荐）：@ConfigurationProperties"></a>方式三（推荐）：<code>@ConfigurationProperties</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;enterprise&quot;)</span><br><span class="line">@Data</span><br><span class="line">public class Enterprise &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private String tel;</span><br><span class="line">    private String[] hobby;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>本质：<br> Spring Boot 内部大量使用这种方式完成第三方组件的<strong>自动配置</strong></p>
</blockquote>
<hr>
<h2 id="七、整合第三方技术"><a href="#七、整合第三方技术" class="headerlink" title="七、整合第三方技术"></a>七、整合第三方技术</h2><h3 id="7-1-Spring-Boot-整合-JUnit"><a href="#7-1-Spring-Boot-整合-JUnit" class="headerlink" title="7.1 Spring Boot 整合 JUnit"></a>7.1 Spring Boot 整合 JUnit</h3><ul>
<li>自动引入测试 starter</li>
<li>使用 <code>@SpringBootTest</code></li>
<li>测试类不在启动类包下时需指定 <code>classes</code></li>
</ul>
<hr>
<h3 id="7-2-Spring-Boot-整合-MyBatis"><a href="#7-2-Spring-Boot-整合-MyBatis" class="headerlink" title="7.2 Spring Boot 整合 MyBatis"></a>7.2 Spring Boot 整合 MyBatis</h3><p>MyBatis 主要涉及两类配置：</p>
<ol>
<li><strong>全局配置</strong>（数据源）</li>
<li><strong>映射配置</strong>（XML &#x2F; 注解）</li>
</ol>
<p>基本步骤：</p>
<ul>
<li>引入 MyBatis Starter</li>
<li>配置数据源</li>
<li>定义 Mapper 接口</li>
<li>注入 Mapper 测试</li>
</ul>
<hr>
<h3 id="7-3-Spring-Boot-整合-Druid"><a href="#7-3-Spring-Boot-整合-Druid" class="headerlink" title="7.3 Spring Boot 整合 Druid"></a>7.3 Spring Boot 整合 Druid</h3><ul>
<li>引入 Druid Starter</li>
<li>配置 Druid 专属配置项</li>
<li>验证 DataSource 类型</li>
</ul>
<hr>
<h2 id="八、整合过程中的问题与排错总结（重点）"><a href="#八、整合过程中的问题与排错总结（重点）" class="headerlink" title="八、整合过程中的问题与排错总结（重点）"></a>八、整合过程中的问题与排错总结（重点）</h2><h3 id="问题一：UserDao-无法注入"><a href="#问题一：UserDao-无法注入" class="headerlink" title="问题一：UserDao 无法注入"></a>问题一：<code>UserDao</code> 无法注入</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No qualifying bean of type &#x27;tingfeng.mapper.UserDao&#x27; available</span><br></pre></td></tr></table></figure>

<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul>
<li>Mapper 接口未被 Spring 扫描</li>
<li><code>@Mapper</code> 只对 MyBatis 生效</li>
</ul>
<h4 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;tingfeng.mapper&quot;)</span><br><span class="line">public class Quickstart03Application &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="关键认知"><a href="#关键认知" class="headerlink" title="关键认知"></a>关键认知</h4><blockquote>
<p><strong>@Mapper 是 MyBatis 的，@MapperScan 才是 Spring 的</strong></p>
</blockquote>
<hr>
<h3 id="问题二：Mapper-能扫描，但报-sqlSessionFactory-缺失"><a href="#问题二：Mapper-能扫描，但报-sqlSessionFactory-缺失" class="headerlink" title="问题二：Mapper 能扫描，但报 sqlSessionFactory 缺失"></a>问题二：Mapper 能扫描，但报 <code>sqlSessionFactory</code> 缺失</h3><h4 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Property &#x27;sqlSessionFactory&#x27; or &#x27;sqlSessionTemplate&#x27; are required</span><br></pre></td></tr></table></figure>

<h4 id="定位结论"><a href="#定位结论" class="headerlink" title="定位结论"></a>定位结论</h4><ul>
<li>Mapper 已创建</li>
<li>SqlSessionFactory 未生成</li>
<li>SqlSessionFactory 依赖 DataSource</li>
</ul>
<h4 id="实际解决方式"><a href="#实际解决方式" class="headerlink" title="实际解决方式"></a>实际解决方式</h4><blockquote>
<p><strong>将 <code>mybatis-spring-boot-starter</code> 从 3.0.4 升级至 4.0.2</strong></p>
</blockquote>
<h4 id="根因分析（重要）"><a href="#根因分析（重要）" class="headerlink" title="根因分析（重要）"></a>根因分析（重要）</h4><p>新版本调整了：</p>
<ul>
<li>Mapper 初始化时机</li>
<li>SqlSessionFactory 校验逻辑</li>
</ul>
<p>避免在 DataSource 尚未完全初始化时进行强校验，从而绕开了该异常路径。</p>
<blockquote>
<p>⚠️ 注意：<br> 这并不代表 DataSource 问题“消失”，而是<strong>校验时机发生了变化</strong></p>
</blockquote>
<hr>
<h2 id="九、总结与反思"><a href="#九、总结与反思" class="headerlink" title="九、总结与反思"></a>九、总结与反思</h2><p>这次学习和排错过程中，我最大的收获不是“配置记住了多少”，而是：</p>
<ul>
<li>理解了 <strong>Starter 才是自动配置的触发条件</strong></li>
<li>明白了 <strong>异常信息可能并不是根因</strong></li>
<li>学会从 <strong>DataSource → SqlSessionFactory → Mapper</strong> 反向排查</li>
<li>认识到 <strong>版本升级可能改变行为，而非修复根因</strong></li>
</ul>
<hr>
<h2 id="十、一句话总结"><a href="#十、一句话总结" class="headerlink" title="十、一句话总结"></a>十、一句话总结</h2><blockquote>
<p>Spring Boot 整合 MyBatis 与数据源时，<br> 问题往往不在 Mapper 本身，<br> 而在自动配置链路是否完整、以及校验时机是否合理。</p>
</blockquote>
<hr>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/09/backend/ssm/springboot/2026-1-9-springboot-day01/" data-id="cmk8gbsqk001kiw8thgmb1eil" data-title="Spring Boot 基础入门与整合实践" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/druid/" rel="tag">druid</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-8-backtracking-subset-practice" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/08/algorithms/backtracking/2026-1-8-backtracking-subset-practice/" class="article-date">
  <time class="dt-published" datetime="2026-01-08T04:00:00.000Z" itemprop="datePublished">2026-01-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/08/algorithms/backtracking/2026-1-8-backtracking-subset-practice/">子集型回溯方法论得应用（2026-01-08）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一、输入角度的子集型回溯"><a href="#一、输入角度的子集型回溯" class="headerlink" title="一、输入角度的子集型回溯"></a>一、输入角度的子集型回溯</h2><p>子集型回溯是一类<strong>通过枚举每个元素“选 or 不选”来构造答案集合</strong>的回溯问题。<br> 其核心思想是：</p>
<blockquote>
<p>对输入集合中的每一个元素，都做一次“是否加入当前解”的选择，通过递归枚举所有可能的子集。</p>
</blockquote>
<p>由于每个元素只有两种状态（选 &#x2F; 不选），因此这类问题<strong>天然覆盖所有可能情况，不会重、不漏</strong>。</p>
<hr>
<h2 id="二、子集型回溯的统一模板"><a href="#二、子集型回溯的统一模板" class="headerlink" title="二、子集型回溯的统一模板"></a>二、子集型回溯的统一模板</h2><p>子集型回溯的 DFS 过程通常包含三个核心要素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(i, 输入集合，当前状态)</span>:</span><br><span class="line">	<span class="comment">// n 为输入集合长度</span></span><br><span class="line">    <span class="keyword">if</span> i == n:</span><br><span class="line">		<span class="comment">// 说明当前轮枚举完了输入集合</span></span><br><span class="line">        更新答案</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不选第 i 个元素</span></span><br><span class="line">    dfs(i + <span class="number">1</span>, 输入集合，当前状态)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选第 i 个元素（有条件）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_">check</span><span class="params">(i, 当前状态)</span>:</span><br><span class="line">        选择 i</span><br><span class="line">        <span class="title function_">dfs</span><span class="params">(i + <span class="number">1</span>, 输入集合，新状态)</span></span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><code>i</code>：当前处理到第 i 个元素</li>
<li><code>当前状态</code>：路径（已选元素 &#x2F; 剩余资源 &#x2F; 当前得分等）</li>
<li><code>check</code>：是否允许“选”的条件判断（<strong>条件回溯的关键</strong>）</li>
</ul>
<hr>
<h2 id="三、扩展题目统一拆解"><a href="#三、扩展题目统一拆解" class="headerlink" title="三、扩展题目统一拆解"></a>三、扩展题目统一拆解</h2><p>下面 6 道题，本质上都可以<strong>统一为「子集型回溯 + 条件判断」</strong>。</p>
<hr>
<h3 id="LCP51-烹饪料理"><a href="#LCP51-烹饪料理" class="headerlink" title="LCP51. 烹饪料理"></a>LCP51. 烹饪料理</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>枚举第 i 道料理：做 or 不做</li>
<li>选的条件：材料足够</li>
</ul>
<p><strong>状态维护</strong>：</p>
<ul>
<li>剩余材料数组</li>
</ul>
<p>典型的「<strong>资源约束型子集回溯</strong>」</p>
<hr>
<h3 id="2397-被列覆盖的最多行数"><a href="#2397-被列覆盖的最多行数" class="headerlink" title="2397. 被列覆盖的最多行数"></a>2397. 被列覆盖的最多行数</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>枚举第 i 列：选 or 不选</li>
<li>选的条件：已选列数 ≤ numSelect</li>
</ul>
<p><strong>关键剪枝</strong>：</p>
<ul>
<li>如果 <code>剩余列数 ≤ 剩余可选数</code> → <strong>必须全选</strong></li>
</ul>
<p>子集型回溯 + <strong>强剪枝</strong></p>
<hr>
<h3 id="1239-串联字符串的最大长度"><a href="#1239-串联字符串的最大长度" class="headerlink" title="1239. 串联字符串的最大长度"></a>1239. 串联字符串的最大长度</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>枚举每个字符串：选 or 不选</li>
</ul>
<p><strong>选的条件</strong>：</p>
<ol>
<li>字符串内部不能有重复字符</li>
<li>与当前已选字符串字符集不能冲突</li>
</ol>
<p><strong>状态设计</strong>：</p>
<ul>
<li>使用 boolean[26] 维护字符占用情况</li>
</ul>
<p> 典型的「<strong>集合冲突约束型回溯</strong>」</p>
<hr>
<h3 id="2212-射箭比赛中的最大得分"><a href="#2212-射箭比赛中的最大得分" class="headerlink" title="2212. 射箭比赛中的最大得分"></a>2212. 射箭比赛中的最大得分</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>枚举每个得分区间是否争夺</li>
</ul>
<p><strong>选的条件</strong>：</p>
<ul>
<li>剩余箭数 ≥ alice[i] + 1</li>
</ul>
<p><strong>状态维护</strong>：</p>
<ul>
<li>剩余箭数</li>
<li>当前得分</li>
</ul>
<p>本质是 <strong>资源分配 + 子集枚举</strong></p>
<hr>
<h3 id="2698-求一个整数的惩罚数"><a href="#2698-求一个整数的惩罚数" class="headerlink" title="2698. 求一个整数的惩罚数"></a>2698. 求一个整数的惩罚数</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>对 <code>i²</code> 的字符串进行切割</li>
<li>每一刀：切 or 不切</li>
</ul>
<p><strong>选的条件</strong>：</p>
<ul>
<li>当前分割出的数字之和 ≤ i</li>
</ul>
<p>本质是 <strong>字符串分割型子集回溯</strong></p>
<hr>
<h3 id="93-复原-IP-地址（从答案角度分析）"><a href="#93-复原-IP-地址（从答案角度分析）" class="headerlink" title="93. 复原 IP 地址（从答案角度分析）"></a>93. 复原 IP 地址（从答案角度分析）</h3><p><strong>建模方式</strong>：</p>
<ul>
<li>字符串分割，一共分割为 4 段</li>
</ul>
<ul>
<li>枚举第 i 段从哪里分割</li>
</ul>
<p><strong>隐含条件（关键）</strong>：</p>
<ol>
<li>必须切成 <strong>4 段</strong></li>
<li>每段 ∈ [0,255]</li>
<li>不能有前导 0</li>
</ol>
<p>带<strong>分割约束</strong>的字符串回溯</p>
<hr>
<h2 id="五、子集型回溯的优化与剪枝"><a href="#五、子集型回溯的优化与剪枝" class="headerlink" title="五、子集型回溯的优化与剪枝"></a>五、子集型回溯的优化与剪枝</h2><h3 id="条件剪枝（最常见）"><a href="#条件剪枝（最常见）" class="headerlink" title="条件剪枝（最常见）"></a>条件剪枝（最常见）</h3><ul>
<li>选之前判断是否合法</li>
<li>不合法直接跳过</li>
</ul>
<h3 id="提前终止（上界剪枝）"><a href="#提前终止（上界剪枝）" class="headerlink" title="提前终止（上界剪枝）"></a>提前终止（上界剪枝）</h3><ul>
<li>剩余元素即使全选，也不可能更优</li>
<li>直接 return</li>
</ul>
<h3 id="强制选择"><a href="#强制选择" class="headerlink" title="强制选择"></a>强制选择</h3><ul>
<li>剩余元素数 ≤ 剩余配额</li>
<li>不再分支，直接全选</li>
</ul>
<hr>
<h2 id="六、心得体会与方法论总结"><a href="#六、心得体会与方法论总结" class="headerlink" title="六、心得体会与方法论总结"></a>六、心得体会与方法论总结</h2><ul>
<li>子集型回溯本质是一种<strong>暴力但系统的枚举方法</strong></li>
<li>通过“选 &#x2F; 不选”两条分支，可以<strong>完整覆盖解空间</strong></li>
<li>时间复杂度通常为 <code>O(2^n)</code>，但<strong>剪枝决定了实际性能</strong></li>
<li>带条件的子集回溯，核心是：<ul>
<li><strong>把“是否能选”的逻辑抽离成 check</strong></li>
<li>让 DFS 结构保持干净、统一</li>
</ul>
</li>
<li>很多看似不同的题（资源分配、字符串切割、组合选择），<strong>在建模层面是同一类问题</strong></li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/08/algorithms/backtracking/2026-1-8-backtracking-subset-practice/" data-id="cmk8gbsqc000riw8t2sp35oaj" data-title="子集型回溯方法论得应用（2026-01-08）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-6-backtracking-subset" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/06/algorithms/backtracking/2026-1-6-backtracking-subset/" class="article-date">
  <time class="dt-published" datetime="2026-01-06T05:00:00.000Z" itemprop="datePublished">2026-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/06/algorithms/backtracking/2026-1-6-backtracking-subset/">子集型回溯（2026-01-06）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>子集型回溯应用范围：子集&#x2F;组合&#x2F;切分字符串&#x2F;按位选择等“枚举所有可能”的题。</p>
</blockquote>
<h3 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h3><ul>
<li>子集</li>
<li>电话号码字母组合</li>
<li>分割回文串</li>
</ul>
<h3 id="扩展题目"><a href="#扩展题目" class="headerlink" title="扩展题目"></a>扩展题目</h3><ul>
<li>二叉树的所有路径</li>
<li>路径总和 II </li>
<li>字母大小写全排列</li>
</ul>
<hr>
<h2 id="1-什么是回溯？"><a href="#1-什么是回溯？" class="headerlink" title="1. 什么是回溯？"></a>1. 什么是回溯？</h2><p>以集合 <code>(1,2,3)</code> 的子集为例：我们可以选择 <code>1</code>，也可以“退回去”不选 <code>1</code> 改选 <code>2</code>，再选 <code>3</code>。<br> 这种<strong>在构造答案的过程中回退到上一步、去探索其它分支</strong>的现象就是回溯。</p>
<p>回溯通常伴随递归，而不是循环：</p>
<ul>
<li>循环适合固定层数（例如 2 层、3 层嵌套）。</li>
<li>但回溯题的“层数”往往<strong>未知或很深</strong>（例如字符串切分、树路径、排列组合），循环表达能力有限。</li>
<li>递归天然对应一棵“决策树”的深度优先遍历（DFS），更适合回溯。</li>
</ul>
<hr>
<h2 id="2-用“树”和“路径”理解回溯"><a href="#2-用“树”和“路径”理解回溯" class="headerlink" title="2. 用“树”和“路径”理解回溯"></a>2. 用“树”和“路径”理解回溯</h2><p>把回溯理解成 <strong>DFS 遍历一棵决策树</strong>最直观：</p>
<ul>
<li>每走到一个节点，我们都处于一条“根 → 当前节点”的路径上</li>
<li>用 <code>path</code> 维护这条路径</li>
<li>当到达满足条件的位置（通常是叶子，或某些题的节点），把 <code>path</code> 记录到 <code>ans</code></li>
</ul>
<p>关键点：<strong>回溯 &#x3D; 递归返回 + 恢复现场</strong></p>
<hr>
<h2 id="3-恢复现场：为什么必须做？"><a href="#3-恢复现场：为什么必须做？" class="headerlink" title="3. 恢复现场：为什么必须做？"></a>3. 恢复现场：为什么必须做？</h2><p>在 DFS 过程中我们经常会：</p>
<ol>
<li>把一个选择加入 <code>path</code></li>
<li>递归深入</li>
<li>返回时必须撤销这个选择，否则 <code>path</code> 会“污染”后续分支</li>
</ol>
<p>常见的两种恢复方式：</p>
<ul>
<li><strong>数据覆盖</strong>：适用于“固定长度答案”（常用数组保存）</li>
<li><strong>回滚（removeLast）</strong>：适用于 <code>List</code> &#x2F; <code>StringBuilder</code> 这种动态结构</li>
</ul>
<blockquote>
<p><strong>add → dfs → removeLast</strong><br> 只要你“改变了状态”，回来的时候就要“撤销状态”。</p>
</blockquote>
<hr>
<h2 id="4-子集型回溯的两大思路"><a href="#4-子集型回溯的两大思路" class="headerlink" title="4. 子集型回溯的两大思路"></a>4. 子集型回溯的两大思路</h2><p>回溯题通常两种建模方式：</p>
<h3 id="思路-A：从输入角度——“当前元素选不选”"><a href="#思路-A：从输入角度——“当前元素选不选”" class="headerlink" title="思路 A：从输入角度——“当前元素选不选”"></a>思路 A：从输入角度——“当前元素选不选”</h3><ul>
<li>每个输入元素对应一层决策：<strong>选 &#x2F; 不选</strong></li>
<li>决策树通常是二叉树</li>
<li><strong>答案通常在叶子节点收集</strong></li>
</ul>
<h3 id="思路-B：从答案角度——“当前位置选哪个元素”"><a href="#思路-B：从答案角度——“当前位置选哪个元素”" class="headerlink" title="思路 B：从答案角度——“当前位置选哪个元素”"></a>思路 B：从答案角度——“当前位置选哪个元素”</h3><ul>
<li>每一层表示“答案的当前位选什么元素”</li>
<li>用 <code>startIndex</code> 控制下一层枚举起点，避免重复</li>
<li><strong>答案通常在节点收集</strong>（因为走到任意节点都代表一个合法子集）</li>
</ul>
<blockquote>
<p>两种思路都能做 78 子集；<br> 哪个更顺手取决于题型，有时“答案角度”的树更小，有时“选不选”更直观。</p>
</blockquote>
<hr>
<h2 id="5-画树：回溯卡住时最有效的解法"><a href="#5-画树：回溯卡住时最有效的解法" class="headerlink" title="5. 画树：回溯卡住时最有效的解法"></a>5. 画树：回溯卡住时最有效的解法</h2><p>当你对“递归参数是什么、何时收集答案、怎么剪枝”不明确时：</p>
<ul>
<li>先画出<strong>决策树</strong></li>
<li>每一层代表什么？</li>
<li>每条边代表什么选择？</li>
<li>哪些节点是合法答案？</li>
</ul>
<blockquote>
<p><strong>画树能直接定位：答案在哪里收集 + 哪一步需要回溯。</strong></p>
</blockquote>
<hr>
<h2 id="6-结合题目：78-子集（两种思路）"><a href="#6-结合题目：78-子集（两种思路）" class="headerlink" title="6. 结合题目：78 子集（两种思路）"></a>6. 结合题目：78 子集（两种思路）</h2><h3 id="6-1-解法-1：枚举输入元素选不选（叶子收集答案）"><a href="#6-1-解法-1：枚举输入元素选不选（叶子收集答案）" class="headerlink" title="6.1 解法 1：枚举输入元素选不选（叶子收集答案）"></a>6.1 解法 1：枚举输入元素选不选（叶子收集答案）</h3><blockquote>
<p>特点：二叉决策树；当 <code>i == nums.length</code> 才表示一条路径完全确定，因此在叶子收集。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int i, int[] nums, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; ans) &#123;</span><br><span class="line">    // 递归边界：输入枚举完了，path 是一种完整选择</span><br><span class="line">    if (i == nums.length) &#123;</span><br><span class="line">        ans.add(new ArrayList&lt;&gt;(path)); // 注意要拷贝</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1) 不选 nums[i]</span><br><span class="line">    dfs(i + 1, nums, path, ans);</span><br><span class="line"></span><br><span class="line">    // 2) 选 nums[i]</span><br><span class="line">    path.add(nums[i]);</span><br><span class="line">    dfs(i + 1, nums, path, ans);</span><br><span class="line">    path.removeLast(); // 恢复现场</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><strong>叶子收集</strong>：因为只有到 <code>i==n</code> 才能确定“每个元素选没选”</li>
<li><strong>必须拷贝 path</strong>：否则 ans 里存的是同一个引用，后续回滚会影响已保存答案</li>
<li><strong>恢复现场</strong>：每次 add 后都要 removeLast</li>
</ul>
<hr>
<h3 id="6-2-解法-2：枚举第-i-个答案选哪个元素（节点收集答案）"><a href="#6-2-解法-2：枚举第-i-个答案选哪个元素（节点收集答案）" class="headerlink" title="6.2 解法 2：枚举第 i 个答案选哪个元素（节点收集答案）"></a>6.2 解法 2：枚举第 i 个答案选哪个元素（节点收集答案）</h3><blockquote>
<p>特点：每个节点都是一个子集，因此走到节点就可记录；用 <code>startIndex</code> 防止重复。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void dfs(int start, int[] nums, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; path) &#123;</span><br><span class="line">    // 由于每个节点都是一个合法子集，所以直接记录当前 path</span><br><span class="line">    ans.add(new ArrayList&lt;&gt;(path));</span><br><span class="line"></span><br><span class="line">    // 枚举下一位选哪个元素：只能从 start 往后选，保证不出现 (2,1) 这种重复顺序</span><br><span class="line">    for (int j = start; j &lt; nums.length; j++) &#123;</span><br><span class="line">        path.add(nums[j]);</span><br><span class="line">        dfs(j + 1, nums, ans, path);</span><br><span class="line">        path.removeLast(); // 回滚</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>你需要牢记的点：</strong></p>
<ul>
<li><strong>节点收集</strong>：因为任何时刻的 <code>path</code> 都是一个合法子集</li>
<li><strong>startIndex 是去重本质</strong>：规定递增选取顺序，避免同一组合的不同排列</li>
<li>这类写法也是“组合类题”通用模板（如组合总和、组合数等）</li>
</ul>
<hr>
<h2 id="7-String-join：在回溯里怎么用？和-StringBuilder-有什么关系？"><a href="#7-String-join：在回溯里怎么用？和-StringBuilder-有什么关系？" class="headerlink" title="7. String.join：在回溯里怎么用？和 StringBuilder 有什么关系？"></a>7. String.join：在回溯里怎么用？和 StringBuilder 有什么关系？</h2><p>在题解中看到有人用了 <code>String.join()</code>，它很适合把结果“输出成字符串”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; path = List.of(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</span><br><span class="line">String s = String.join(&quot;-&quot;, path); // &quot;a-b-c&quot;</span><br></pre></td></tr></table></figure>

<p>但需要注意它和 <code>StringBuilder / StringJoiner</code> 的定位不同：</p>
<ul>
<li><strong>String.join</strong>：一次性把已有的字符串集合拼起来（更像“格式化输出”）</li>
<li><strong>StringBuilder</strong>：回溯过程中不断 append &#x2F; delete（更像“构造过程中的状态”）</li>
<li><strong>StringJoiner</strong>：更偏“带前后缀的 join”，比如 <code>&quot;[a,b,c]&quot;</code></li>
</ul>
<p>在回溯题中一般推荐：</p>
<ul>
<li>构造过程：用 <strong>StringBuilder</strong>（append + deleteCharAt 回滚）</li>
<li>输出阶段：需要展示路径时用 <strong>String.join</strong>（更清爽）</li>
</ul>
<hr>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><h3 id="模板-1（选不选，叶子收集）"><a href="#模板-1（选不选，叶子收集）" class="headerlink" title="模板 1（选不选，叶子收集）"></a>模板 1（选不选，叶子收集）</h3><ul>
<li>参数：<code>i</code></li>
<li>收集：<code>i == n</code></li>
<li>结构：先不选，再选（选完要回滚）</li>
</ul>
<h3 id="模板-2（答案角度，节点收集）"><a href="#模板-2（答案角度，节点收集）" class="headerlink" title="模板 2（答案角度，节点收集）"></a>模板 2（答案角度，节点收集）</h3><ul>
<li>参数：<code>start</code></li>
<li>收集：进入 dfs 就收集</li>
<li>结构：for 从 start 枚举，递归 dfs(start +1)，回滚</li>
</ul>
<hr>
<h2 id="9-心得体会"><a href="#9-心得体会" class="headerlink" title="9. 心得体会"></a>9. 心得体会</h2><ul>
<li>回溯的本质是<strong>DFS 遍历决策树</strong>，<code>path</code> 记录当前路径，<code>ans</code> 收集答案。</li>
<li>回溯一定伴随<strong>恢复现场</strong>：add → dfs → removeLast。</li>
<li>子集型题最常用两种建模：<ul>
<li><strong>选不选（叶子收集）</strong></li>
<li><strong>选哪个（节点收集 + startIndex 去重）</strong></li>
</ul>
</li>
<li>思路不清楚时，<strong>画树是最高效的破局方法</strong>。</li>
<li><code>String.join</code> 更适合输出拼接；回溯构造过程更推荐 <code>StringBuilder</code> 做状态并回滚。</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/06/algorithms/backtracking/2026-1-6-backtracking-subset/" data-id="cmk8gbsqa000niw8t2v2whwzb" data-title="子集型回溯（2026-01-06）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-misc/Spring + Redis 学习计划 V3.1（7天闭环，基于AI）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/06/misc/Spring%20+%20Redis%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%20V3.1%EF%BC%887%E5%A4%A9%E9%97%AD%E7%8E%AF%EF%BC%8C%E5%9F%BA%E4%BA%8EAI%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2026-01-05T15:10:00.000Z" itemprop="datePublished">2026-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/06/misc/Spring%20+%20Redis%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%20V3.1%EF%BC%887%E5%A4%A9%E9%97%AD%E7%8E%AF%EF%BC%8C%E5%9F%BA%E4%BA%8EAI%EF%BC%89/">Spring + Redis 学习计划 V3.1（7天闭环，基于AI）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这篇文章不是 Spring 或 Redis 的教程，而是我在学习过程中逐步形成的一套“以实践触发问题、以问题反推原理”的学习方法论记录。然后和 AI 讨论，让 AI 帮我制定并反复修改的一份学习计划。</p>
<p>这份计划并不是一成不变的清单，而是一个可以根据个人基础和时间不断调整的框架。</p>
<p>如果你打算使用这份计划，建议每天只关注一个问题，不要试图一次性学完所有原理；当你能结合代码回答当天的核心问题时，就可以进入下一天。</p>
<blockquote>
<p>每天固定产出：<strong>代码（可复现）+ 触发问题（至少1个）+ 博客（面试答案）</strong><br>Spring 的 6 问法继续用；Redis 也用同样的“是否学够了”问法。</p>
</blockquote>
<hr>
<h2 id="Day-1：IOC（不该用-Spring-的场景）"><a href="#Day-1：IOC（不该用-Spring-的场景）" class="headerlink" title="Day 1：IOC（不该用 Spring 的场景）"></a>Day 1：IOC（不该用 Spring 的场景）</h2><p><strong>主问题（Spring 6问 #1）</strong>：我什么时候不该用 Spring IOC？</p>
<p><strong>练习</strong>：纯 Java new vs Spring 管理 Bean（最小项目）<br><strong>触发问题</strong>：工具类要不要交给 Spring？过度工程化的代价是什么？<br><strong>博客</strong>：《我什么时候不该用 Spring？IOC 的边界》</p>
<p><strong>原理后置</strong>：Bean 生命周期细节、三级缓存（先不看）</p>
<hr>
<h2 id="Day-2：DI（注入失败与选择规则）"><a href="#Day-2：DI（注入失败与选择规则）" class="headerlink" title="Day 2：DI（注入失败与选择规则）"></a>Day 2：DI（注入失败与选择规则）</h2><p><strong>主问题（Spring 6问 #3）</strong>：DI 为什么会失败？</p>
<p><strong>练习</strong>：多实现类 + @Autowired 不加 @Qualifier，制造 NoUnique<br><strong>触发问题</strong>：Spring 如何选择 Bean？为什么字段注入更“坑”？<br><strong>博客</strong>：《@Autowired 注入失败的真实原因与修复姿势》</p>
<p><strong>原理后置</strong>：装配算法细节（按需）</p>
<hr>
<h2 id="Day-3：AOP（为什么会失效）"><a href="#Day-3：AOP（为什么会失效）" class="headerlink" title="Day 3：AOP（为什么会失效）"></a>Day 3：AOP（为什么会失效）</h2><p><strong>主问题（Spring 6问 #3&#x2F;#4）</strong>：AOP 在哪些情况下会失效？是框架问题还是使用问题？</p>
<p><strong>练习</strong>：private &#x2F; 本类自调用 &#x2F; final 类方法（任选两种复现）<br><strong>触发问题</strong>：Spring 拦截的是谁？为什么必须经过代理？<br><strong>博客</strong>：《AOP 失效：你以为拦截了方法，其实你绕过了代理》</p>
<p><strong>原理后置</strong>：JDK vs CGLIB（只记结论即可）</p>
<hr>
<h2 id="Day-4：事务（事务不是关键字）"><a href="#Day-4：事务（事务不是关键字）" class="headerlink" title="Day 4：事务（事务不是关键字）"></a>Day 4：事务（事务不是关键字）</h2><p><strong>主问题（Spring 6问 #3&#x2F;#6）</strong>：事务为什么失效？事务边界在哪里？</p>
<p><strong>练习</strong>：@Transactional + try-catch + 自调用（至少复现一个失效）<br><strong>触发问题</strong>：为什么 catch 了异常不回滚？为什么自调用不生效？<br><strong>博客</strong>：《@Transactional 失效三件套：自调用 &#x2F; 私有方法 &#x2F; try-catch》</p>
<p><strong>原理后置</strong>：传播行为枚举（后置到面试前）</p>
<hr>
<h2 id="Day-5：Spring-Boot（减法实验：自动配置到底做了啥）"><a href="#Day-5：Spring-Boot（减法实验：自动配置到底做了啥）" class="headerlink" title="Day 5：Spring Boot（减法实验：自动配置到底做了啥）"></a>Day 5：Spring Boot（减法实验：自动配置到底做了啥）</h2><p><strong>主问题（Spring 6问 #2）</strong>：Boot 帮我解决了什么？又引入了什么新复杂度？</p>
<p><strong>练习</strong>：搭 Boot + MVC + MyBatis + JUnit，刻意删配置观察还能跑什么<br><strong>触发问题</strong>：Tomcat 谁起的？Mapper 谁扫的？<br><strong>博客</strong>：《我删了配置还能跑：Spring Boot 自动配置的边界》</p>
<p><strong>原理后置</strong>：自动配置源码（先别啃）</p>
<hr>
<h2 id="Day-6：Redis-进场（Cache-Aside-一致性“必踩坑”）"><a href="#Day-6：Redis-进场（Cache-Aside-一致性“必踩坑”）" class="headerlink" title="Day 6：Redis 进场（Cache Aside + 一致性“必踩坑”）"></a>Day 6：Redis 进场（Cache Aside + 一致性“必踩坑”）</h2><blockquote>
<p>从今天开始，Redis 用同样的“6问法”（尤其是：何时不用、不可避免的不一致、补救策略）</p>
</blockquote>
<p><strong>主问题（Redis 自测 #2&#x2F;#3）</strong>：Redis 与数据库不一致我能不能接受？延迟双删在解决什么？</p>
<p><strong>练习（强工程化）</strong>：</p>
<ul>
<li>先写 <strong>无缓存</strong>：Controller → Service → MyBatis → DB</li>
<li>再加 <strong>旁路缓存 Cache Aside</strong>：<ul>
<li>读：先查 Redis，miss 查 DB 回填</li>
<li>写：更新 DB + 删除缓存（或先删后更），两种都做</li>
</ul>
</li>
<li><strong>刻意制造并发读写</strong>（哪怕用两个线程&#x2F;两次请求）</li>
</ul>
<p><strong>必须触发的问题（至少一个）</strong>：</p>
<ul>
<li>更新 DB 后，读到 Redis 旧值：这允许吗？怎么兜底？</li>
<li>先删缓存还是先更新 DB？各自会出什么问题？</li>
<li>延迟双删的意义是什么？它是在补什么洞？</li>
</ul>
<p><strong>博客（面试级）</strong>：<br>《Cache Aside 不是“套路”：我如何复现并解释一次读到旧值》</p>
<p><strong>原理后置</strong>：Redis 持久化&#x2F;集群（先不学）</p>
<hr>
<h2 id="Day-7：Redis-×-事务-×-AOP（把-Spring-的问题“放大”）"><a href="#Day-7：Redis-×-事务-×-AOP（把-Spring-的问题“放大”）" class="headerlink" title="Day 7：Redis × 事务 × AOP（把 Spring 的问题“放大”）"></a>Day 7：Redis × 事务 × AOP（把 Spring 的问题“放大”）</h2><p><strong>主问题（Spring 6问 #6 + Redis 自测 #4）</strong>：Redis 操作失败，事务该不该回滚？边界在哪里？</p>
<p><strong>练习（触发更高级问题）</strong>：</p>
<ul>
<li>写一个“下单&#x2F;扣库存”伪业务：<ul>
<li>DB：扣库存&#x2F;写订单（事务内）</li>
<li>Redis：删缓存&#x2F;更新缓存（事务内外各做一版）</li>
</ul>
</li>
<li>人为制造 Redis 异常（比如断开连接&#x2F;抛 RuntimeException）</li>
</ul>
<p><strong>必须触发的问题</strong>：</p>
<ul>
<li>DB 回滚了，Redis 没回滚怎么办？</li>
<li>Redis 写成功了，DB 失败了怎么办？</li>
<li>缓存更新到底该放在事务前、事务中、事务后？</li>
</ul>
<p><strong>博客（面试级）</strong>：<br>《Redis 进事务是灾难吗？我用一次“回滚不一致”把边界讲清楚》</p>
<p><strong>原理后置</strong>（可选进阶）：</p>
<ul>
<li>Lua 原子性（如果你想走并发方向，可以作为加分项）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/06/misc/Spring%20+%20Redis%20%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%20V3.1%EF%BC%887%E5%A4%A9%E9%97%AD%E7%8E%AF%EF%BC%8C%E5%9F%BA%E4%BA%8EAI%EF%BC%89/" data-id="cmk8gbspt0000iw8th0do9vpc" data-title="Spring + Redis 学习计划 V3.1（7天闭环，基于AI）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" rel="tag">学习计划</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/binary-tree/2026-1-5-binary-tree-level-order-traversal" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/05/algorithms/binary-tree/2026-1-5-binary-tree-level-order-traversal/" class="article-date">
  <time class="dt-published" datetime="2026-01-05T05:00:00.000Z" itemprop="datePublished">2026-01-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/05/algorithms/binary-tree/2026-1-5-binary-tree-level-order-traversal/">二叉树的层序遍历总结（2026-01-05）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在二叉树相关算法中，<strong>层序遍历（Level Order Traversal）</strong> 是 BFS 的典型应用，在涉及「按层处理」「同一层节点关系」「层级统计」等问题时，几乎是第一选择。同时，通过层序遍历序列构造一颗树很好实现。</p>
<p>本文对我在 2026-01-05 完成的一批层序遍历题目进行一次系统总结，并结合做题过程中补充的 <strong>Java 集合知识点</strong>，形成一份可复盘的学习笔记。</p>
</blockquote>
<h3 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h3><ul>
<li>二叉树的层序遍历</li>
<li>二叉树的锯齿形层序遍历</li>
<li>找树左下角的值</li>
</ul>
<h3 id="扩展题目"><a href="#扩展题目" class="headerlink" title="扩展题目"></a>扩展题目</h3><ul>
<li>二叉树的层序遍历 II</li>
<li>二叉树的最大深度</li>
<li>二叉树的最小深度</li>
<li>二叉树中的第 K 大层和</li>
<li>二叉树的右视图</li>
<li>填充每个节点的下一个右侧节点指针</li>
<li>层数最深叶子节点的和</li>
<li>奇偶树</li>
<li>反转二叉树的奇数层</li>
<li>二叉树的堂兄弟节点 II</li>
</ul>
<hr>
<h2 id="层序遍历的核心识别信号"><a href="#层序遍历的核心识别信号" class="headerlink" title="层序遍历的核心识别信号"></a>层序遍历的核心识别信号</h2><p>在读题时，只要出现以下关键词，就要高度警惕「层序遍历」：</p>
<ul>
<li>“一层一层”</li>
<li>“同一层节点”</li>
<li>“第 k 层 &#x2F; 第 k 大层”</li>
<li>“左视图 &#x2F; 右视图”</li>
<li>“最深一层 &#x2F; 最浅一层”</li>
</ul>
<p><strong>本质：题目要求你按层组织节点，而不是单纯的前序 &#x2F; 中序 &#x2F; 后序。</strong></p>
<hr>
<h2 id="层序遍历的两种经典实现方式"><a href="#层序遍历的两种经典实现方式" class="headerlink" title="层序遍历的两种经典实现方式"></a>层序遍历的两种经典实现方式</h2><h3 id="1-双数组（当前层-下一层）写法（最直观）"><a href="#1-双数组（当前层-下一层）写法（最直观）" class="headerlink" title="1. 双数组（当前层 &#x2F; 下一层）写法（最直观）"></a>1. 双数组（当前层 &#x2F; 下一层）写法（最直观）</h3><p>思路非常清晰：</p>
<ol>
<li>用一个数组保存当前层节点</li>
<li>遍历当前层时，把子节点加入“下一层数组”</li>
<li>当前层处理完后，令 <code>cur = next</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cur = [root]</span><br><span class="line">while cur 非空:</span><br><span class="line">    处理 cur</span><br><span class="line">    next = []</span><br><span class="line">    for node in cur:</span><br><span class="line">        next.add(node.left)</span><br><span class="line">        next.add(node.right)</span><br><span class="line">    cur = next</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>思路清楚，适合初学</li>
<li>非常适合“同层对称处理”的题目（如 2415）</li>
</ul>
<hr>
<h3 id="队列写法（更通用、面试更常见）"><a href="#队列写法（更通用、面试更常见）" class="headerlink" title="队列写法（更通用、面试更常见）"></a>队列写法（更通用、面试更常见）</h3><p><strong>常用</strong>的写法：</p>
<p>核心技巧：<br><strong>在每一轮循环开始时，记录当前队列长度 <code>size</code>，它就代表当前层的节点个数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">queue.offer(root)</span><br><span class="line">while queue 非空:</span><br><span class="line">    size = queue.size()</span><br><span class="line">    for i in range(size):</span><br><span class="line">        node = queue.poll()</span><br><span class="line">        处理 node</span><br><span class="line">        queue.offer(node.left)</span><br><span class="line">        queue.offer(node.right)</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>不需要额外的“当前层数组”</li>
<li>非常适合统计、聚合、视图类问题</li>
</ul>
<hr>
<h2 id="一道典型-Trick：2415-反转二叉树的奇数层"><a href="#一道典型-Trick：2415-反转二叉树的奇数层" class="headerlink" title="一道典型 Trick：2415. 反转二叉树的奇数层"></a>一道典型 Trick：2415. 反转二叉树的奇数层</h2><p>这道题有一个非常重要但容易忽略的点：</p>
<blockquote>
<p><strong>题目要求反转的是“奇数层节点的值”，而不是节点本身。</strong></p>
</blockquote>
<h3 id="关键-insight"><a href="#关键-insight" class="headerlink" title="关键 insight"></a>关键 insight</h3><ul>
<li>二叉树结构 <strong>不能乱改</strong></li>
<li>但交换 <code>node.val</code> 是完全合法的</li>
<li>对称位置的节点只需要交换值即可</li>
</ul>
<p>这是一个**“值操作”替代“结构操作”**的经典思路，后续很多树题都会用到。</p>
<hr>
<h2 id="做题过程中补充的-Java-集合知识"><a href="#做题过程中补充的-Java-集合知识" class="headerlink" title="做题过程中补充的 Java 集合知识"></a>做题过程中补充的 Java 集合知识</h2><p>在实现层序遍历的过程中，我顺带系统补齐了一些 <strong>Java 集合的易混点</strong>。</p>
<h3 id="1-List-of-vs-new-ArrayList"><a href="#1-List-of-vs-new-ArrayList" class="headerlink" title="1. List.of(...) vs new ArrayList&lt;&gt;()"></a>1. <code>List.of(...)</code> vs <code>new ArrayList&lt;&gt;()</code></h3><ul>
<li><code>List.of(...)</code><ul>
<li>创建 <strong>不可变 List</strong></li>
<li>不能增删改</li>
<li>不允许 <code>null</code></li>
<li>引用本身可以重新指向其他 List</li>
</ul>
</li>
<li><code>new ArrayList&lt;&gt;()</code><ul>
<li>可变集合</li>
<li>支持增删改</li>
</ul>
</li>
</ul>
<p>常见用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; a = new ArrayList&lt;&gt;(List.of(1, 2, 3));</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-Collections-reverse-list-vs-list-reversed"><a href="#2-Collections-reverse-list-vs-list-reversed" class="headerlink" title="2. Collections.reverse(list) vs list.reversed()"></a>2. <code>Collections.reverse(list)</code> vs <code>list.reversed()</code></h3><ul>
<li><code>Collections.reverse(list)</code><ul>
<li><strong>就地反转</strong></li>
<li>会修改原 list</li>
<li>list 必须是可变的</li>
</ul>
</li>
<li><code>list.reversed()</code>（Java 21+）<ul>
<li>返回一个 <strong>倒序视图（view）</strong></li>
<li>不修改原 list</li>
<li>O(1) 创建视图</li>
<li>原 list 改变，视图会联动变化</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-Queue-offer-poll-vs-add-remove"><a href="#3-Queue-offer-poll-vs-add-remove" class="headerlink" title="3. Queue.offer / poll vs add / remove"></a>3. <code>Queue.offer / poll</code> vs <code>add / remove</code></h3><p>这是 Queue 接口里非常重要的一组 API 设计差异：</p>
<ul>
<li><code>offer(e)</code>：失败返回 <code>false</code></li>
<li><code>poll()</code>：空队列返回 <code>null</code></li>
<li><code>add(e)</code>：失败抛异常</li>
<li><code>remove()</code>：空队列抛异常</li>
</ul>
<p>实际写算法时，<strong><code>offer + poll</code> 更常用</strong>，避免异常作为控制流。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来看，<strong>层序遍历的思想并不复杂</strong>，但由于它需要我们<strong>显式维护一个队列</strong>，通过不断入队、出队来模拟递归过程，因此：</p>
<ul>
<li>代码相对 DFS 更冗长</li>
<li>但在“同层处理”“层级统计”“视图类问题”中几乎不可替代</li>
</ul>
<p>当题目强调“层”的概念时，应优先考虑层序遍历；而在实现过程中，<strong>对 Java 集合 API 的理解是否扎实，往往直接决定代码是否简洁、健壮</strong>。</p>
<h2 id="构造本地测试用例：用层序数组构造二叉树"><a href="#构造本地测试用例：用层序数组构造二叉树" class="headerlink" title="构造本地测试用例：用层序数组构造二叉树"></a>构造本地测试用例：用层序数组构造二叉树</h2><p>在刷 LeetCode&#x2F;写本地 <code>main</code> 测试时，经常会遇到题目给出的输入形式是：</p>
<ul>
<li><code>root = [5,8,9,2,1,3,7,4,6]</code></li>
<li>或包含缺失节点：<code>root = [1,2,3,null,4]</code></li>
</ul>
<p>这种数组表示其实就是<strong>层序遍历（level order）的序列化结果</strong>：<br> 数组从左到右依次给出每一层的节点，<code>null</code> 表示该位置没有节点。</p>
<p>为了让本地调试更高效，我补齐了一个通用的建树方法：<br><strong>输入 <code>Integer[] levelOrder</code>，输出 <code>TreeNode root</code>（支持 null）</strong></p>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><ul>
<li>用队列保存“等待挂孩子的父节点”</li>
<li>指针 <code>i</code> 从 1 开始扫描数组</li>
<li>每次从队列弹出一个父节点，尝试读取两个位置作为它的 left&#x2F;right</li>
<li>读到 <code>null</code> 就跳过，不创建节点</li>
</ul>
<h3 id="Java-建树模板（支持-null）"><a href="#Java-建树模板（支持-null）" class="headerlink" title="Java 建树模板（支持 null）"></a>Java 建树模板（支持 null）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public static TreeNode buildTree(Integer[] levelOrder) &#123;</span><br><span class="line">    if (levelOrder == null || levelOrder.length == 0 || levelOrder[0] == null) return null;</span><br><span class="line">    </span><br><span class="line">    TreeNode root = new TreeNode(levelOrder[0]);</span><br><span class="line">    Queue&lt;TreeNode&gt; q = new ArrayDeque&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    int i = 1;</span><br><span class="line">    while (i &lt; levelOrder.length &amp;&amp; !q.isEmpty()) &#123;</span><br><span class="line">        TreeNode cur = q.poll();</span><br><span class="line"></span><br><span class="line">        // left</span><br><span class="line">        if (i &lt; levelOrder.length &amp;&amp; levelOrder[i] != null) &#123;</span><br><span class="line">            cur.left = new TreeNode(levelOrder[i]);</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        // right</span><br><span class="line">        if (i &lt; levelOrder.length &amp;&amp; levelOrder[i] != null) &#123;</span><br><span class="line">            cur.right = new TreeNode(levelOrder[i]);</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/05/algorithms/binary-tree/2026-1-5-binary-tree-level-order-traversal/" data-id="cmk8gbsq9000giw8t6bgfamcl" data-title="二叉树的层序遍历总结（2026-01-05）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">层序遍历</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/binary-tree/2026-1-4-lowestCommonAncestor" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/04/algorithms/binary-tree/2026-1-4-lowestCommonAncestor/" class="article-date">
  <time class="dt-published" datetime="2026-01-04T04:00:00.000Z" itemprop="datePublished">2026-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/04/algorithms/binary-tree/2026-1-4-lowestCommonAncestor/">二叉树的最近公共祖先（LCA）问题总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文围绕三道经典 LCA 题目：<br><strong>236. 二叉树的最近公共祖先</strong>、<br><strong>235. 二叉搜索树的最近公共祖先</strong>、<br><strong>1123. 所有最深叶节点的最近公共祖先</strong><br>系统总结最近公共祖先解题思路</p>
<hr>
<h2 id="一、什么是最近公共祖先（LCA）"><a href="#一、什么是最近公共祖先（LCA）" class="headerlink" title="一、什么是最近公共祖先（LCA）"></a>一、什么是最近公共祖先（LCA）</h2><p><strong>最近公共祖先（Lowest Common Ancestor）</strong> 指的是：</p>
<blockquote>
<p>在一棵树中，两个节点 <code>p</code> 和 <code>q</code> 的所有公共祖先中，<strong>离它们最近的那个节点</strong>。</p>
</blockquote>
<p>直观做题时，我们通常是：</p>
<ol>
<li>找到 <code>p</code> 和 <code>q</code></li>
<li>从它们向上回溯</li>
<li>第一个相交的节点就是答案</li>
</ol>
<p>而在代码中，这个“向上回溯”的过程，天然适合用 <strong>递归</strong> 来表达。</p>
<hr>
<h2 id="二、236-二叉树的最近公共祖先（母模板）"><a href="#二、236-二叉树的最近公共祖先（母模板）" class="headerlink" title="二、236. 二叉树的最近公共祖先（母模板）"></a>二、236. 二叉树的最近公共祖先（母模板）</h2><h3 id="一句话思路"><a href="#一句话思路" class="headerlink" title="一句话思路"></a>一句话思路</h3><blockquote>
<p>在左右子树中分别查找 <code>p</code> 和 <code>q</code>，<br> <strong>如果左右都找到了，当前节点就是最近公共祖先</strong>。</p>
</blockquote>
<hr>
<h3 id="递归分类讨论"><a href="#递归分类讨论" class="headerlink" title="递归分类讨论"></a>递归分类讨论</h3><p>对于当前节点 <code>root</code>：</p>
<ol>
<li><p><strong><code>root == null</code></strong></p>
<ul>
<li>返回 <code>null</code>（没找到）</li>
</ul>
</li>
<li><p><strong><code>root == p</code> 或 <code>root == q</code></strong></p>
<ul>
<li>直接返回当前节点</li>
<li>因为最近公共祖先不可能在它的子树下面</li>
</ul>
</li>
<li><p><strong>递归左右子树</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">left = LCA(root.left)</span><br><span class="line">right = LCA(root.right)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>left != null &amp;&amp; right != null</code><br>  <code>p</code>、<code>q</code> 分别在左右子树中，<code>root</code> 就是 LCA</li>
<li>只有一边非空：表示 q、p 都在非空边，直接返回非空节点，即是答案</li>
</ul>
</li>
</ol>
<hr>
<h3 id="本质理解"><a href="#本质理解" class="headerlink" title="本质理解"></a>本质理解</h3><ul>
<li><strong>递（向下）</strong>：定位 <code>p</code>、<code>q</code></li>
<li><strong>归（向上）</strong>：判断当前节点是否“第一次同时覆盖目标”</li>
</ul>
<p> 这是后面所有 LCA 题目的<strong>核心模板</strong></p>
<hr>
<h2 id="三、235-二叉搜索树的最近公共祖先（BST-优化）"><a href="#三、235-二叉搜索树的最近公共祖先（BST-优化）" class="headerlink" title="三、235. 二叉搜索树的最近公共祖先（BST 优化）"></a>三、235. 二叉搜索树的最近公共祖先（BST 优化）</h2><h3 id="与-236-的关键区别"><a href="#与-236-的关键区别" class="headerlink" title="与 236 的关键区别"></a>与 236 的关键区别</h3><p>235 给的是 <strong>二叉搜索树（BST）</strong>，多了一个重要信息：</p>
<blockquote>
<p>左子树所有值 &lt; 根节点 &lt; 右子树所有值</p>
</blockquote>
<hr>
<h3 id="利用-BST-性质剪枝"><a href="#利用-BST-性质剪枝" class="headerlink" title="利用 BST 性质剪枝"></a>利用 BST 性质剪枝</h3><p>设当前节点为 <code>root</code>：</p>
<ol>
<li><code>root.val &gt; p.val &amp;&amp; root.val &gt; q.val</code><br> 两个节点一定在 <strong>左子树</strong></li>
<li><code>root.val &lt; p.val &amp;&amp; root.val &lt; q.val</code><br> 两个节点一定在 <strong>右子树</strong></li>
<li>否则<br> 一个在左，一个在右（或 root 本身）<br> 当前节点就是最近公共祖先</li>
</ol>
<hr>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th>题目</th>
<th>是否需要遍历整棵树</th>
<th>关键依据</th>
</tr>
</thead>
<tbody><tr>
<td>236</td>
<td>是</td>
<td>普通二叉树</td>
</tr>
<tr>
<td>235</td>
<td>否</td>
<td>BST 有序性</td>
</tr>
</tbody></table>
<p> <strong>235 是 236 在 BST 场景下的剪枝优化版</strong></p>
<hr>
<h2 id="四、1123-所有最深叶节点的最近公共祖先（难点）"><a href="#四、1123-所有最深叶节点的最近公共祖先（难点）" class="headerlink" title="四、1123. 所有最深叶节点的最近公共祖先（难点）"></a>四、1123. 所有最深叶节点的最近公共祖先（难点）</h2><h3 id="初始直觉（两次遍历）"><a href="#初始直觉（两次遍历）" class="headerlink" title="初始直觉（两次遍历）"></a>初始直觉（两次遍历）</h3><p>我的第一反应是：</p>
<ol>
<li>先遍历整棵树，找到所有最深的叶子节点</li>
<li>再利用 236 的思路，求这些节点的最近公共祖先</li>
</ol>
<p>这个思路<strong>完全正确</strong>，但本质是 <strong>两次遍历</strong>，并不优雅。</p>
<hr>
<h3 id="思路优化"><a href="#思路优化" class="headerlink" title="思路优化"></a>思路优化</h3><p>在查看参考答案后，我意识到：</p>
<ul>
<li>如果最深叶节点只存在于左子树：最近公共祖先一定在左子树</li>
<li>如果左右子树都存在最深叶节点，且深度相同：当前节点才可能成为答案</li>
</ul>
<p>这说明：</p>
<blockquote>
<p><strong>答案一在递归过程中就可以产生的</strong></p>
</blockquote>
<hr>
<h2 id="五、两种递归设计思路"><a href="#五、两种递归设计思路" class="headerlink" title="五、两种递归设计思路"></a>五、两种递归设计思路</h2><h3 id="思路一：自顶向下（参数传递）"><a href="#思路一：自顶向下（参数传递）" class="headerlink" title="思路一：自顶向下（参数传递）"></a>思路一：自顶向下（参数传递）</h3><ul>
<li>向下递归时传递当前深度</li>
<li>使用全局变量维护最大深度</li>
<li>当左右子树深度相等，且等于全局最大深度时，更新答案（这里的答案会变，因为随着遍历最大深度会变）</li>
</ul>
<hr>
<h3 id="思路二（推荐）：自底向上（返回值回溯）"><a href="#思路二（推荐）：自底向上（返回值回溯）" class="headerlink" title="思路二（推荐）：自底向上（返回值回溯）"></a>思路二（推荐）：自底向上（返回值回溯）</h3><p>进一步抽象问题后，可以把 1123 完全转化为一个<strong>分治问题</strong>：</p>
<blockquote>
<p>每棵子树只需要向父节点返回两件事：</p>
<ol>
<li>子树的最大深度</li>
<li>子树中最深叶节点的最近公共祖先</li>
</ol>
</blockquote>
<hr>
<h2 id="六、自底向上的核心合并逻辑（重点）"><a href="#六、自底向上的核心合并逻辑（重点）" class="headerlink" title="六、自底向上的核心合并逻辑（重点）"></a>六、自底向上的核心合并逻辑（重点）</h2><p>设当前节点 <code>root</code>：</p>
<ul>
<li>左子树返回 <code>(depthL, lcaL)</code></li>
<li>右子树返回 <code>(depthR, lcaR)</code></li>
</ul>
<blockquote>
<p>返回值表示当前节点为根的树的深度与最深叶子节点的最近公共祖先节点</p>
</blockquote>
<h3 id="情况-1：左子树更深"><a href="#情况-1：左子树更深" class="headerlink" title="情况 1：左子树更深"></a>情况 1：左子树更深</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depthL &gt; depthR</span><br></pre></td></tr></table></figure>

<p>所有最深叶节点都在左子树</p>
<p>最近公共祖先也一定在左子树</p>
<p>返回 <code>(depthL + 1, lcaL)</code></p>
<hr>
<h3 id="情况-2：左右子树深度相等"><a href="#情况-2：左右子树深度相等" class="headerlink" title="情况 2：左右子树深度相等"></a>情况 2：左右子树深度相等</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depthL == depthR</span><br></pre></td></tr></table></figure>

<ul>
<li>最深叶节点分布在左右子树</li>
<li>当前节点是第一次“同时覆盖”它们的节点</li>
<li>当前节点就是最近公共祖先</li>
<li>返回 <code>(depthL + 1, root)</code></li>
</ul>
<hr>
<h2 id="七、为什么要用-Pair-二元组，而不是-Map？"><a href="#七、为什么要用-Pair-二元组，而不是-Map？" class="headerlink" title="七、为什么要用 Pair &#x2F; 二元组，而不是 Map？"></a>七、为什么要用 Pair &#x2F; 二元组，而不是 Map？</h2><p>在 1123 的自底向上实现中，递归函数需要返回：</p>
<ul>
<li>一个 <strong>int（深度）</strong></li>
<li>一个 <strong>TreeNode（最近公共祖先）</strong></li>
</ul>
<p>这两个值：</p>
<ul>
<li>没有 key → value 的映射关系</li>
<li>但 <strong>有固定顺序和明确语义</strong></li>
</ul>
<p>因此它们本质上是一个 <strong>有位置关系的二元组</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(depth, lca)</span><br></pre></td></tr></table></figure>

<p>使用 <code>Pair</code>（或自定义类）比 <code>Map</code> 更贴合问题本质，也更清晰、简洁。</p>
<hr>
<h2 id="八、从-236-到-1123：思路的统一"><a href="#八、从-236-到-1123：思路的统一" class="headerlink" title="八、从 236 到 1123：思路的统一"></a>八、从 236 到 1123：思路的统一</h2><p>可以这样理解：</p>
<ul>
<li><strong>236</strong>：判断左右子树是否分别找到了 <code>p</code> 和 <code>q</code></li>
<li><strong>1123</strong>：判断左右子树是否分别包含“最深叶节点”</li>
</ul>
<p>本质上，1123 是对 236 思路的<strong>自然推广</strong>：</p>
<blockquote>
<p>把“是否找到目标节点”升级成了“子树是否达到最深深度”</p>
</blockquote>
<hr>
<h2 id="九、递归设计的两大核心原则（重要总结）"><a href="#九、递归设计的两大核心原则（重要总结）" class="headerlink" title="九、递归设计的两大核心原则（重要总结）"></a>九、递归设计的两大核心原则（重要总结）</h2><h3 id="向下传递-——-参数传递法（递）"><a href="#向下传递-——-参数传递法（递）" class="headerlink" title="向下传递 —— 参数传递法（递）"></a>向下传递 —— 参数传递法（递）</h3><p><strong>适用场景</strong></p>
<ul>
<li>深度</li>
<li>路径状态</li>
<li>累计信息</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>信息从父节点流向子节点</li>
<li>子节点无法反向影响父节点</li>
</ul>
<hr>
<h3 id="向上返回-——-返回值回溯法（归）"><a href="#向上返回-——-返回值回溯法（归）" class="headerlink" title="向上返回 —— 返回值回溯法（归）"></a>向上返回 —— 返回值回溯法（归）</h3><p><strong>适用场景</strong></p>
<ul>
<li>子树高度</li>
<li>子树统计信息</li>
<li>最近公共祖先</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>信息从子节点汇总到父节点</li>
<li>父节点基于左右子树返回值做决策</li>
</ul>
<hr>
<h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><ul>
<li><strong>236</strong>：最近公共祖先的母模板，理解递归回溯的经典题</li>
<li><strong>235</strong>：利用 BST 性质进行剪枝优化</li>
<li><strong>1123</strong>：递归设计能力的分水岭，考验信息如何在递归中流动</li>
</ul>
<blockquote>
<p><strong>二叉树问题的核心，不是“怎么写递归”，<br> 而是“你希望子树返回什么信息”</strong></p>
</blockquote>
<p>一旦子问题定义清晰，答案就会在回溯过程中自然浮现。</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/04/algorithms/binary-tree/2026-1-4-lowestCommonAncestor/" data-id="cmk8gbsq7000aiw8tbts0h009" data-title="二叉树的最近公共祖先（LCA）问题总结" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MyBatis/">MyBatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MyBatis/ssm/">ssm</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/">递归</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/">链表</a></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/" rel="tag">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL%E4%BC%98%E5%8C%96/" rel="tag">SQL优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/druid/" rel="tag">druid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/" rel="tag">jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis-plus/" rel="tag">mybatis-plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml%E6%98%A0%E5%B0%84/" rel="tag">xml映射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" rel="tag">事务原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F/" rel="tag">先序、中序、后序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/" rel="tag">删除链表节点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81mysql/" rel="tag">动态mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" rel="tag">反转链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" rel="tag">学习计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">层序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" rel="tag">快慢指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" rel="tag">数据库锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/" rel="tag">时间复杂度优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" rel="tag">深度优先遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">由遍历序列生成二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%86%E5%9B%BE/" rel="tag">视图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" rel="tag">触发器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 10px;">SQL优化</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/druid/" style="font-size: 10px;">druid</a> <a href="/tags/jdbc/" style="font-size: 12.5px;">jdbc</a> <a href="/tags/maven/" style="font-size: 10px;">maven</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/mybatis-plus/" style="font-size: 10px;">mybatis-plus</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/xml%E6%98%A0%E5%B0%84/" style="font-size: 10px;">xml映射</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" style="font-size: 10px;">事务原理</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 20px;">二叉树</a> <a href="/tags/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F/" style="font-size: 12.5px;">先序、中序、后序</a> <a href="/tags/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/" style="font-size: 10px;">删除链表节点</a> <a href="/tags/%E5%8A%A8%E6%80%81mysql/" style="font-size: 10px;">动态mysql</a> <a href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">反转链表</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 17.5px;">回溯</a> <a href="/tags/%E5%AD%90%E9%9B%86/" style="font-size: 12.5px;">子集</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 10px;">学习计划</a> <a href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">层序遍历</a> <a href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" style="font-size: 10px;">快慢指针</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%8E%92%E5%88%97/" style="font-size: 10px;">排列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" style="font-size: 10px;">数据库锁</a> <a href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/" style="font-size: 10px;">时间复杂度优化</a> <a href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" style="font-size: 10px;">最近公共祖先</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" style="font-size: 12.5px;">深度优先遍历</a> <a href="/tags/%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">由遍历序列生成二叉树</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%84%E5%90%88/" style="font-size: 10px;">组合</a> <a href="/tags/%E8%A7%86%E5%9B%BE/" style="font-size: 10px;">视图</a> <a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" style="font-size: 10px;">触发器</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 12.5px;">记录</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 17.5px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">一月 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">十二月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/">排列型回溯</a>
          </li>
        
          <li>
            <a href="/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/">回溯总结篇</a>
          </li>
        
          <li>
            <a href="/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/">Spring Boot + SSMP 基础实战与问题复盘</a>
          </li>
        
          <li>
            <a href="/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/">组合型回溯 + 剪枝：从子集枚举到条件收敛</a>
          </li>
        
          <li>
            <a href="/2026/01/09/backend/ssm/springboot/2026-1-9-springboot-day01/">Spring Boot 基础入门与整合实践</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 Tingfeng Li<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>