<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>廷风的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="记录 Java 后端学习与项目实践的技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="廷风的技术博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="廷风的技术博客">
<meta property="og:description" content="记录 Java 后端学习与项目实践的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tingfeng Li">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="廷风的技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">廷风的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java 后端开发</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-misc/git-开发工具整理总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/14/misc/git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2026-01-14T06:20:00.000Z" itemprop="datePublished">2026-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/14/misc/git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/">git 开发工具整理总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文是在学习过程中，零星对 git 的学习的总结与汇总。</p>
</blockquote>
<h2 id="什么是-Git"><a href="#什么是-Git" class="headerlink" title="什么是 Git"></a>什么是 Git</h2><p>git 是基于 c 语言的分布式版本控制系统，与之对应的是集中式版本控制系统。这两者的不同：</p>
<ul>
<li>集中式版本控制系统：版本库存放在中央服务器，必须联网才能从中央服务器拉取最新版本，推送新版本到中央服务器。</li>
<li>分布式版本控制系统：没有中央服务器，每个人的电脑都有一个完整的版本库。多人协作的实现是通过将各自修改的内容推送给对方。实际应用中，通常用一台电脑充当“中央服务器”，这个服务器只用来交换大家的修改信息，不存放版本库。</li>
</ul>
<p>git 的优势不单单是不必联网，还有强大的分支管理</p>
<hr>
<h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2><p>版本库又名仓库（Repository），可以理解为一个目录，这个目录中的所有文件受 git 管理，每个文件的增删改，git 都能跟踪，以便根据需求还原。</p>
<p>创建版本库非常简单，在需要交给 git 管理的目录下，执行 <code>git init</code> 命令即可。</p>
<blockquote>
<p>需要注意的是，目录名尽量不要包含中文。</p>
</blockquote>
<p>所有的版本控制系统，其实都只是跟踪文本文件的改动，例如 txt 文件、程序代码等等，不能监控图片、视频这种二进制文件（只能监控大小的改变，内容的改变不能监控）。</p>
<h3 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h3><p>在 git 管理的目录下，通过 <code>git add &lt;filename&gt;</code> 添加文件到版本库，再通过 <code>git commit -m &quot;msg&quot;</code> 命令把文件提交到仓库。<code>git status</code> 命令可以查看仓库当前状态，会提示修改过的文件，以及准备提交的文件（add 的文件）。<code>git diff</code> 命令可以对比文件哪些地方变化了。</p>
<p>注意添加和提交是两个操作。</p>
<h3 id="小结（目前最常用命令）"><a href="#小结（目前最常用命令）" class="headerlink" title="小结（目前最常用命令）"></a>小结（目前最常用命令）</h3><ul>
<li><code>git init</code>：将当前目录交给 git 管理</li>
<li><code>git add &lt;filename&gt;</code>：将指定文件添加到版本库中</li>
<li><code>git commit -m &quot;msg&quot;</code>：提交本次修改，msg 是对本次提交的说明</li>
<li><code>git status</code>：查看仓库当前状态，哪些文件被修改了，哪些文件添加到版本库中但是还没有提交</li>
<li><code>git diff</code>：查看文件修改内容</li>
</ul>
<hr>
<h2 id="时光穿梭"><a href="#时光穿梭" class="headerlink" title="时光穿梭"></a>时光穿梭</h2><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>同一仓库，经过多次提交后，难免记不清哪个版本修改了什么内容，所以在进行版本回退前，可以通过 <code>git log</code> 命令查看历史记录，可以看到包含了每次提交的 commit id：364… 以及谁提交的，以及日期和每次提交的说明。</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/1.png" alt="1"></p>
<p>此外，我们还需要当前版本的信息，head 指向的就是当前版本，然后就可以定位需要回退的版本，通过 <code>git reset</code> 命令进行回退</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>^ 表示上个版本，多个版本可用 <del>， HEAD</del>100 表示回退 100  个版本。</p>
<p>–hard 参数表示回退上个版本的已提交状态，–soft 表示回退到上个版本的未提交状态，–mixed 回到上个版本已添加但是为提交的状态。</p>
<p>也可以通过 <code>git reset --hard f35ed</code> 回退到具体版本，或者穿梭到未来的版本，注意这里 commit id 不用写全，只要让 git 能够找到唯一的版本即可。<code>git reflog</code> 命令显示 git 记录的每一次命令，通过这个可用查看版本号。</p>
<blockquote>
<p>git 的版本回退速度非常快，因为 git 内部有个指向当前版本的 HEAD 指针，回退版本时，仅仅是将 HEAD 指向指定版本</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>git reset --hard HEAD^/指定版本号</code>：回退到当前版本的上个版本或回退到指定版本号的版本</li>
<li><code>git log</code> 与 <code>git reflog</code> ：命令查看历史记录，来找到需要回退的版本或版本号</li>
</ul>
<h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h3><p>工作区，就是电脑中实际操作的目录。</p>
<p>版本库，是工作区中的隐藏目录 .git，其中存储 git 进行版本控制的很多信息，最重要的就是暂存区（stage）和 git 自动创建的 master 分支，以及指向 master 分支的 HEAD 指针。</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/2.png" alt="2"></p>
<ul>
<li><code>git add</code> 就是将<strong>文件修改</strong>添加到暂存区</li>
<li><code>git commit</code> 就是将暂存区的所有内容添加到当前分支</li>
</ul>
<blockquote>
<p>可以理解为：需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
</blockquote>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>git 管理的是对文件的修改而非文件，怎么理解？例如，在文件中新增一个 ‘a’ 字符，然后 <code>git add</code> 后又将字符改为了 ‘b’，暂存区中只知道你将新增了一个字符 ‘a’，而不知道它改为了 ‘b’，这是一个很好的证明 git 管理的是修改而非文件本身。</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>撤销修改有三种情形：</p>
<ul>
<li><p>只是对工作区进行了修改，还没有 add 与 commit：直接通过 <code>git restore &lt;file&gt;</code> 撤销修改</p>
</li>
<li><p>对工作区的修改，添加到了暂存区：通过 <code>git restore --staged &lt;file&gt;</code> 命令将文件从暂存区删除，然后通过  <code>git restore &lt;file&gt;</code> 撤销修改。 </p>
</li>
<li><p>对工作区的修改不仅添加到了缓存区，还提交到了分支当中：<code>git reset HEAD^</code> 进行版本回退。</p>
</li>
</ul>
<blockquote>
<p>git checkout –filename 命令是让文件回到最近一次 add 或 commit 时的状态</p>
</blockquote>
<h3 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h3><p>仓库中的文件的删除也是一次修改操作，git 会记录下来。如果想在 git 仓库中也实现文件的永久删除，可以用 <code>git rm filename</code> 命令，也可以用 <code>git add filename</code> 将这次修改提交到暂存区，然后再提交。</p>
<p>如果要撤销这次删除操作，只需要用到上一节介绍的 <code>git checkout --filename</code> 命令</p>
<blockquote>
<p>这里需要注意的就是：没有被添加到仓库中的文件，git 是无法控制的</p>
</blockquote>
<hr>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>以上的功能，集中版本控制系统也能做到。真正体现 git 优势的是远程仓库，简单来说，就是将本地仓库托管到服务器上每天 24 小时开机，也可以从服务器中拉取别人的仓库，还能将提交推送到服务器上。</p>
<p>GitHub 就是提供 Git 仓库托管服务的，你需要告诉远程仓库你的身份信息，谁都可以修改你的远程仓库。本地Git仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以需要先设置 SSH 密钥。</p>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>在 github 上创建好远程仓库后，需要将它与本地仓库关联：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:tingfeng-worK/project.git</span><br></pre></td></tr></table></figure>

<p>如果没有设置 SSH 密钥这一步，本地推送就推送不到远程仓库，相当于没有登录。命令中的 origin 是默认的远程仓库名，将本地仓库的内容推送到远程仓库，用命令 <code>git push</code>，实际上是将当前分支 master 推送到远程库，第一次推送时需要加上 <code>-u</code> 参数，它表示 git 不但会把本地的 master 分支推送到远程库中新的 master 分支，还会将它们关联起来，以后推送或拉取时就可以简化命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>上述添加远程库是将本地已有的仓库添加并关联到远程仓库，而将远程仓库拉取到本地用到的 git 命令是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:tingfeng-worK/project.git <span class="comment"># ssh 协议</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tingfeng-work/project.git <span class="comment"># https 协议</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Git 支持多协议，可以使用 https，但是使用 ssh 最快</p>
</blockquote>
<hr>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git 的分支管理是它的优势之一，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<p>分支管理就好比在一个项目中，你与队友并行在不同的分支上开发不同的功能，在这个分支上你想提交就提交，不会影响主分支，在功能完成后，将分支合并到主分支上，项目就同时具备了你俩开发的功能。</p>
<h3 id="分支的创建与合并"><a href="#分支的创建与合并" class="headerlink" title="分支的创建与合并"></a>分支的创建与合并</h3><p>每次提交，git 都会 将它们串联为一条时间线，这个时间线就是一个分支，目前为止用到的都是 git 默认为我们常见的主分支 master，HEAD 严格来说不是指向提交，而是指向 master，而 master 指向每一次提交，如图所示：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/3.png" alt="3"></p>
<p>每次提交，master 分支都会向前移动一次，HEAD 指针也随之移动。</p>
<p>当我们创建新的分支 dev 时，相当于创建了一个新的时间线，Git 会创建一个 dev 指针，指向 master 相同的提交，再把 HEAD 指向 dev，就表示当前分支在 dev 上：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/4.png" alt="4"></p>
<p>这也解释了为什么 git 新建分支很快，它只是新建了一个指针，同时更改了 HEAD 的指向。现在对工作区的修改提交之后，就是 dev 指针移动，而 master 指针不变了：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/5.png" alt="5"></p>
<p>在<code>dev</code>上的工作完成后，就可以把<code>dev</code>合并到<code>master</code>上。这种单时间线的合并最简单，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并。相关指令：</p>
<ul>
<li><code>git branch</code>：查看有哪些分支</li>
<li><code>git branch &lt;name&gt;</code> ：新建分支</li>
<li><code>git checkout &lt;name&gt;</code> 或 <code>git switch &lt;name&gt;</code>：切换分支</li>
<li><code>git checkout -b &lt;name&gt;</code> 或 <code>git switch -c &lt;name&gt;</code>：创建并切换到新建的分支</li>
<li><code>git merger &lt;name&gt;</code>：合并某分支到当前分支</li>
<li><code>git branch -d &lt;name&gt;</code>：删除分支</li>
</ul>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>上面描述最简单的单时间线的分支合并，考虑合并两个时间线的分支，这种情况下，git 无法执行快速合并，只能试着把各自的修改合并起来：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/6.png" alt="6"></p>
<p>但是，这种合并可能会有冲突，假设这两次提交针对文件的同一地方进行了修改，合并分支时就会产生冲突，这也很好理解，git 不知道到底要怎么修改，所以必须手动解决冲突后再提交，也就是明确告诉 git 要怎么改。手动解决后，再合并就会变为：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/7.png" alt="7"></p>
<p>可以看到这种合并会创建一次新的提交，这也很好理解，因为这是对文件的一次修改。</p>
<ul>
<li><code>git log --graph --pretty=oneline --abbrev-commit</code>：可以看到分支合并情况。</li>
</ul>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ul>
<li>从远程仓库拉取分支进行本地修改</li>
<li>修改后从本地推送分支，如果推送失败，说明远程仓库中已经有人对操作 1 中拉取的分支进行了修改，并提交到远程仓库了，这时需要需要进行合并。</li>
<li>如果合并失败，就在本地解决冲突，然后再提交。</li>
</ul>
<p>这个过程会用到的指令：</p>
<ul>
<li><p><code>git remote -v</code>：查看远程仓库信息</p>
</li>
<li><p><code>git pull</code>：拉取并合并远程基于当前分支的提交，这个命令执行的前提是远程仓库上的分支与当前分支建立了联系。</p>
</li>
<li><p><code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>：将远程仓库中的分支与本地分支建立联系</p>
</li>
<li><p><code>git push origin &lt;branch-name&gt;</code>：从本地推送分支到远程仓库</p>
</li>
<li><p><code>git checkout -b branch-name origin/branch-name</code></p>
</li>
</ul>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>将本地未 push 的分叉提交历史整理为一条分支（一条直线）</p>
<hr>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签就相当于一个有名字的不会动的指针，指向某一个 commit，方便进行版本控制。如果没有标签，想要跳转到指定的版本，需要通过 git log 找 commit 的 id，而且 id 还很长，所以标签就起到了快速找到指定版本的作用。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>切换到需要打标签的提交，通过 <code>git tag &lt;name&gt;</code>，就实现打标签了，也可以指定 commit id 的方式打标签，同时指定 <code>git tag -a &lt;name&gt; -m &quot;msg&quot;</code> 参数可以对创建标签进行说明。<code>git tag</code> 查看所有标签，<code>git show &lt;tagname&gt;</code>查看指定标签。</p>
<blockquote>
<p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
</blockquote>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<hr>
<h2 id="GitHub-开源项目"><a href="#GitHub-开源项目" class="headerlink" title="GitHub 开源项目"></a>GitHub 开源项目</h2><p>在 GitHub 上，利用 Git 强大的克隆和分支功能，可以实现自由参与各种开源项目了。</p>
<p>对于开源项目，先 fork 到自己的远程仓库，再从自己的远程仓库中克隆到本地仓库。对本地仓库的修改，再提交到自己的远程仓库，如果希望自己的修改被项目方接受，需要在 GitHub 上发起 pull request，最终取决于对方是否接受。</p>
<hr>
<h2 id="学习-Git-的网站"><a href="#学习-Git-的网站" class="headerlink" title="学习 Git 的网站"></a>学习 Git 的网站</h2><p><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/14/misc/git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/" data-id="cmkdskc910004ww8t2dd02e9o" data-title="git 开发工具整理总结" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01背包与完全背包模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/13/algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2026-01-13T04:30:00.000Z" itemprop="datePublished">2026-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/13/algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/">DP 模型：从回溯语义到 0-1 背包与完全背包（2026-01-13）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文通过 494、322、2915 三道典型题目，总结 <strong>0-1 背包与完全背包的统一建模方式</strong>。重点在于<strong>如何从回溯语义自然推导出动态规划模型</strong>。</p>
</blockquote>
<p><strong>基础题目</strong>：01背包、完全背包</p>
<p><strong>01背包变形</strong>：</p>
<p>494.目标和、2915.和为目标值的最长子序列的长度</p>
<p><strong>完全背包变形</strong>：</p>
<p>322.零钱兑换</p>
<hr>
<h2 id="一、为什么要从“回溯语义”入手理解-DP？"><a href="#一、为什么要从“回溯语义”入手理解-DP？" class="headerlink" title="一、为什么要从“回溯语义”入手理解 DP？"></a>一、为什么要从“回溯语义”入手理解 DP？</h2><p>在学习动态规划的过程中，我一度陷入这样的问题：</p>
<ul>
<li>明明知道这是 DP 题</li>
<li>但一到写 <code>dp[i][j]</code> 就容易：<ul>
<li>不知道从何下手</li>
<li>理解错误状态含义</li>
<li>写错初始化</li>
</ul>
</li>
</ul>
<p>后来我解题循序渐进旨在加深对回溯与DP的理解：</p>
<blockquote>
<p><strong>所有 DP 题，先用 <code>dfs(i, j)</code> 把“语义”想清楚，再翻译成 DP。</strong></p>
</blockquote>
<p>这篇博客正是围绕这一方法，总结 <strong>0-1 背包与完全背包</strong> 这两类最常见的 DP 模型。</p>
<hr>
<h2 id="二、统一视角：什么是“背包模型”？"><a href="#二、统一视角：什么是“背包模型”？" class="headerlink" title="二、统一视角：什么是“背包模型”？"></a>二、统一视角：什么是“背包模型”？</h2><p>从抽象层面看，背包问题的本质只有一句话：</p>
<blockquote>
<p><strong>枚举每个输入元素，决定“选或不选”，并维护一个容量约束。</strong></p>
</blockquote>
<h3 id="0-1-背包模型"><a href="#0-1-背包模型" class="headerlink" title="0-1 背包模型"></a>0-1 背包模型</h3><p><strong>问题描述</strong></p>
<ul>
<li>有 <code>n</code> 个物品</li>
<li>第 <code>i</code> 个物品体积 <code>w[i]</code>，价值 <code>v[i]</code></li>
<li>每个物品最多选一次</li>
<li>在容量 <code>capacity</code> 内，求最大价值和</li>
</ul>
<h3 id="回溯语义三问（非常重要）"><a href="#回溯语义三问（非常重要）" class="headerlink" title="回溯语义三问（非常重要）"></a>回溯语义三问（非常重要）</h3><ul>
<li>当前操作：枚举第 i 个物品选或不选：不选，剩余容量不变；选，容量减少 w[i]</li>
<li>子问题：剩余容量为 c 时，前 i 个物品中的最大价值和</li>
<li>下一个子问题：分类讨论：<ul>
<li>当前操作不选：剩余容量 c 从前 i-1 个物品中得到的最大价值</li>
<li>当前操作选：剩余容量 c - w[i] 从前 i-1 个物品得到的最大价值</li>
</ul>
</li>
</ul>
<h3 id="回溯表达式"><a href="#回溯表达式" class="headerlink" title="回溯表达式"></a>回溯表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int i, int c, int[] w, int[] v) &#123;</span><br><span class="line">    if (i &lt; 0) return 0;</span><br><span class="line">    if (w[i] &gt; c) &#123;</span><br><span class="line">        return dfs(i - 1, c, w, v);</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(</span><br><span class="line">        dfs(i - 1, c, w, v),                 // 不选</span><br><span class="line">        dfs(i - 1, c - w[i], w, v) + v[i]    // 选</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一旦写出这段递归，DP 就已经成功了一半。</strong></p>
<hr>
<h3 id="完全背包模型"><a href="#完全背包模型" class="headerlink" title="完全背包模型"></a>完全背包模型</h3><p>完全背包与 0-1 背包只有一个本质区别：</p>
<blockquote>
<p><strong>当前物品是否允许在同一层决策中被再次使用</strong></p>
</blockquote>
<h4 id="回溯表达式-1"><a href="#回溯表达式-1" class="headerlink" title="回溯表达式"></a>回溯表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfs(i, c) = max(</span><br><span class="line">    dfs(i - 1, c),          // 不选</span><br><span class="line">    dfs(i, c - w[i]) + v[i] // 选，并且还能继续选 i</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="一个非常容易困惑的问题"><a href="#一个非常容易困惑的问题" class="headerlink" title="一个非常容易困惑的问题"></a>一个非常容易困惑的问题</h4><blockquote>
<p>为什么不需要写 <code>dfs(i - 1, c - w[i])</code>？即选了一次后不在选了</p>
</blockquote>
<p>原因在于：</p>
<ul>
<li><code>dfs(i, c - w[i])</code> 中，下一层仍然可以选择“不选”，自然会递归到 <code>dfs(i - 1, c - w[i])</code></li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>“选一次就不再选”这个语义，已经被递归本身隐式表达了。</strong></p>
</blockquote>
<p>这是我在完全背包中收获最大的一个认知点。</p>
<hr>
<h2 id="三、常见背包问题的分类方式"><a href="#三、常见背包问题的分类方式" class="headerlink" title="三、常见背包问题的分类方式"></a>三、常见背包问题的分类方式</h2><p>在做题时，我会优先判断两个维度：</p>
<h3 id="1-装不装满？"><a href="#1-装不装满？" class="headerlink" title="1. 装不装满？"></a>1. 装不装满？</h3><ul>
<li><strong>至多装 capacity</strong></li>
<li><strong>恰好装 capacity</strong></li>
<li><strong>至少装 capacity</strong></li>
</ul>
<h3 id="2-求什么？"><a href="#2-求什么？" class="headerlink" title="2. 求什么？"></a>2. 求什么？</h3><ul>
<li>方案数</li>
<li>最大价值</li>
<li>最小价值</li>
</ul>
<blockquote>
<p>大部分 LeetCode 背包题，都可以被放入这个二维分类表中。</p>
</blockquote>
<hr>
<h2 id="四、结合具体题目分析"><a href="#四、结合具体题目分析" class="headerlink" title="四、结合具体题目分析"></a>四、结合具体题目分析</h2><h3 id="494-目标和-——-0-1-背包（恰好装满，求方案数）"><a href="#494-目标和-——-0-1-背包（恰好装满，求方案数）" class="headerlink" title="494. 目标和 —— 0-1 背包（恰好装满，求方案数）"></a>494. 目标和 —— 0-1 背包（恰好装满，求方案数）</h3><h4 id="建模思路"><a href="#建模思路" class="headerlink" title="建模思路"></a>建模思路</h4><ul>
<li>每个数只能用一次 → <strong>0-1 背包</strong></li>
<li>每个数选或不选 → 枚举符号</li>
<li>本质是：<strong>恰好凑出 target 的方案数</strong></li>
</ul>
<h4 id="回溯语义"><a href="#回溯语义" class="headerlink" title="回溯语义"></a>回溯语义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i, t)：使用前 i 个数，凑出和为 t 的方案数</span><br></pre></td></tr></table></figure>

<h4 id="转移关系"><a href="#转移关系" class="headerlink" title="转移关系"></a>转移关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(i, t) = dfs(i - 1, t)           // 不选 nums[i]</span><br><span class="line">          + dfs(i - 1, t - nums[i]) // 选 nums[i]</span><br></pre></td></tr></table></figure>

<p>在实现时，我采用了：</p>
<ol>
<li>回溯 + 记忆化搜索</li>
<li>翻译为二维 DP</li>
<li>再做空间优化</li>
</ol>
<blockquote>
<p>这道题让我深刻体会到：<br> <strong><code>dp[i][j]</code> 的含义，必须和 dfs(i, j) 的返回值一一对应。</strong></p>
</blockquote>
<hr>
<h3 id="322-零钱兑换-——-完全背包（恰好装满，求最小价值）"><a href="#322-零钱兑换-——-完全背包（恰好装满，求最小价值）" class="headerlink" title="322. 零钱兑换 —— 完全背包（恰好装满，求最小价值）"></a>322. 零钱兑换 —— 完全背包（恰好装满，求最小价值）</h3><h4 id="模型映射"><a href="#模型映射" class="headerlink" title="模型映射"></a>模型映射</h4><table>
<thead>
<tr>
<th>零钱兑换</th>
<th>背包模型</th>
</tr>
</thead>
<tbody><tr>
<td>amount</td>
<td>capacity</td>
</tr>
<tr>
<td>coin 面值</td>
<td>物品体积</td>
</tr>
<tr>
<td>使用枚数</td>
<td>价值（每次 +1）</td>
</tr>
</tbody></table>
<h4 id="为什么是完全背包？"><a href="#为什么是完全背包？" class="headerlink" title="为什么是完全背包？"></a>为什么是完全背包？</h4><p>因为：<strong>同一种硬币，在同一轮决策中可以被重复使用</strong></p>
<h4 id="转移方程（核心）——-经过回溯、空间优化的结果"><a href="#转移方程（核心）——-经过回溯、空间优化的结果" class="headerlink" title="转移方程（核心）—— 经过回溯、空间优化的结果"></a>转移方程（核心）—— 经过回溯、空间优化的结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = min(</span><br><span class="line">    dp[j],              // 不使用当前硬币</span><br><span class="line">    dp[j - coin] + 1    // 使用一次当前硬币</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2915-和为目标值的最长子序列-——-0-1-背包（恰好装满，求最大价值）"><a href="#2915-和为目标值的最长子序列-——-0-1-背包（恰好装满，求最大价值）" class="headerlink" title="2915. 和为目标值的最长子序列 —— 0-1 背包（恰好装满，求最大价值）"></a>2915. 和为目标值的最长子序列 —— 0-1 背包（恰好装满，求最大价值）</h3><h4 id="抽象方式"><a href="#抽象方式" class="headerlink" title="抽象方式"></a>抽象方式</h4><ul>
<li>每个元素只能选一次 → <strong>0-1 背包</strong></li>
<li>nums[i] 作为“体积”</li>
<li>每选一个元素，价值 +1</li>
</ul>
<h4 id="语义定义"><a href="#语义定义" class="headerlink" title="语义定义"></a>语义定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]：和为 j 时，能得到的最大长度</span><br></pre></td></tr></table></figure>

<p>这道题让我意识到：</p>
<blockquote>
<p><strong>“价值”不一定是题目直接给的，而可以从题目中转化。</strong></p>
</blockquote>
<hr>
<h2 id="五、空间优化：理解即可，不必强求"><a href="#五、空间优化：理解即可，不必强求" class="headerlink" title="五、空间优化：理解即可，不必强求"></a>五、空间优化：理解即可，不必强求</h2><p>在这三道题中，状态转移均只依赖于：</p>
<ul>
<li>上一层 <code>i - 1</code></li>
<li>或当前层更小的 <code>j</code></li>
</ul>
<p>因此可以：</p>
<ol>
<li><code>dp[n][target] → dp[2][target]</code></li>
<li>再进一步压缩为一维数组</li>
</ol>
<p>但我目前的态度是：</p>
<blockquote>
<p><strong>空间优化属于锦上添花，优先保证语义正确。</strong></p>
</blockquote>
<p>如果一维 DP 的依赖方向一时想不清楚，我会选择保留二维。</p>
<hr>
<h2 id="六、总结与反思"><a href="#六、总结与反思" class="headerlink" title="六、总结与反思"></a>六、总结与反思</h2><p>通过这几道题，我对动态规划的理解有了一个明显转变：</p>
<ul>
<li>DP 的核心不在公式</li>
<li>而在 <strong>状态含义 + 转移语义</strong></li>
</ul>
<p>我目前仍然习惯：<strong>先写 dfs(i, j)，再翻译成 dp</strong></p>
<p>但我也希望，随着练习的增多，能够逐渐做到：</p>
<ul>
<li>直接从问题 → 状态定义 → 转移方程</li>
<li>减少对回溯的依赖</li>
</ul>
<p>这是我接下来刻意训练的方向。</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/13/algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/" data-id="cmkdskca80051ww8thyrkfx74" data-title="DP 模型：从回溯语义到 0-1 背包与完全背包（2026-01-13）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/01%E8%83%8C%E5%8C%85/" rel="tag">01背包</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" rel="tag">完全背包</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/project/2026-1-13-project-day01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/13/backend/project/2026-1-13-project-day01/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T16:00:00.000Z" itemprop="datePublished">2026-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/13/backend/project/2026-1-13-project-day01/">项目结构搭建：从系统结构图到多模块 Maven 项目设计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文记录了我在餐饮管理系统项目中，从系统结构图设计到多模块 Maven 项目搭建的完整思考过程。</p>
</blockquote>
<hr>
<h2 id="一、从产品原型到系统结构图"><a href="#一、从产品原型到系统结构图" class="headerlink" title="一、从产品原型到系统结构图"></a>一、从产品原型到系统结构图</h2><p>在项目初期，我根据产品原型首先尝试绘制系统结构图，用于梳理系统的整体模块划分。</p>
<h3 id="初版结构图的问题"><a href="#初版结构图的问题" class="headerlink" title="初版结构图的问题"></a>初版结构图的问题</h3><p>最初绘制的结构图中，各个模块是<strong>平级关系</strong>，主要关注功能划分，而忽略了：</p>
<ul>
<li>模块之间的 <strong>层级关系</strong></li>
<li>模块之间的 <strong>依赖方向</strong></li>
<li>不同模块在工程中的 <strong>关注重点</strong></li>
</ul>
<p>在这一阶段，我逐渐意识到：<br> <strong>系统结构图不只是“模块列表”，而是模块间关系的表达。</strong></p>
<hr>
<h3 id="结构图的逐步演进"><a href="#结构图的逐步演进" class="headerlink" title="结构图的逐步演进"></a>结构图的逐步演进</h3><p>在不断调整后，我对结构图提出了更明确的目标：</p>
<ul>
<li>能体现 <strong>调用层级</strong></li>
<li>能反映 <strong>依赖方向</strong></li>
<li>能提示 <strong>开发过程中的关键关注点</strong>（如高并发、事务敏感、高频读等）</li>
</ul>
<p>在这一原则下，结构图经历了多次迭代，最终形成了第三版系统结构图，用于指导后续的工程搭建。</p>
<hr>
<h2 id="二、从系统结构图到项目模块规划"><a href="#二、从系统结构图到项目模块规划" class="headerlink" title="二、从系统结构图到项目模块规划"></a>二、从系统结构图到项目模块规划</h2><p>基于最终的系统结构图，我开始尝试将设计落地为实际的项目结构。</p>
<h3 id="初始拆分思路"><a href="#初始拆分思路" class="headerlink" title="初始拆分思路"></a>初始拆分思路</h3><p>最初的出发点是：</p>
<ul>
<li>结构清晰</li>
<li>各层职责独立</li>
</ul>
<p>因此，我按照经典的三层架构，将项目拆分为三个 Maven Module：</p>
<ul>
<li>controller</li>
<li>service</li>
<li>dao</li>
</ul>
<p>从“概念理解”的角度看，这样的拆分似乎是合理的。</p>
<hr>
<h2 id="三、对照教学案例后的关键反思"><a href="#三、对照教学案例后的关键反思" class="headerlink" title="三、对照教学案例后的关键反思"></a>三、对照教学案例后的关键反思</h2><p>在对照教学案例（如 sky-take-out）后，我发现一个非常明显的差异：</p>
<h3 id="教学案例的模块划分方式"><a href="#教学案例的模块划分方式" class="headerlink" title="教学案例的模块划分方式"></a>教学案例的模块划分方式</h3><p>案例项目并 <strong>没有</strong> 将 controller &#x2F; service &#x2F; dao 拆分为独立 Maven Module，而是采用了：</p>
<ul>
<li><strong>pojo</strong>：实体类与数据模型模块</li>
<li><strong>common</strong>：通用常量、工具类、公共定义</li>
<li><strong>server</strong>：业务模块（包含 controller &#x2F; service &#x2F; mapper）</li>
</ul>
<p>并且：<strong>所有模块由一个 parent pom 统一管理</strong></p>
<hr>
<h3 id="我的拆分方式存在的问题"><a href="#我的拆分方式存在的问题" class="headerlink" title="我的拆分方式存在的问题"></a>我的拆分方式存在的问题</h3><p>对比之后，我逐渐意识到自己最初的设计存在以下隐患：</p>
<ol>
<li>controller &#x2F; service &#x2F; dao <strong>强耦合、同步演进</strong></li>
<li>业务变化频繁，模块边界不稳定</li>
<li>缺少统一的实体与通用模块<ul>
<li>实体类、常量、工具类被迫分散在不同模块</li>
<li>不可避免地出现模块间交叉 import</li>
</ul>
</li>
<li>结构复杂，但并未带来工程收益</li>
</ol>
<p><strong>最终结果很可能是：模块越拆越乱。</strong></p>
<hr>
<h2 id="四、什么该拆-Module，什么不该拆"><a href="#四、什么该拆-Module，什么不该拆" class="headerlink" title="四、什么该拆 Module，什么不该拆"></a>四、什么该拆 Module，什么不该拆</h2><h3 id="Maven-Module-≠-逻辑分层"><a href="#Maven-Module-≠-逻辑分层" class="headerlink" title="Maven Module ≠ 逻辑分层"></a>Maven Module ≠ 逻辑分层</h3><p>在这一阶段，我对 Maven Module 的角色有了更清晰的认识：</p>
<blockquote>
<p><strong>Maven Module 的拆分依据不是 MVC 分层，而是工程属性。</strong></p>
</blockquote>
<p>更合理的判断标准是：</p>
<ul>
<li><strong>稳定性</strong>：是否长期稳定、不易变化</li>
<li><strong>复用性</strong>：是否会被多个模块依赖</li>
<li><strong>变化频率</strong>：是否频繁随业务调整</li>
</ul>
<hr>
<h3 id="合理的拆分原则"><a href="#合理的拆分原则" class="headerlink" title="合理的拆分原则"></a>合理的拆分原则</h3><ul>
<li><strong>稳定、通用、可复用的内容</strong><br> → 适合拆为 Maven Module（如 common、pojo）</li>
<li><strong>强耦合、变化频繁的业务逻辑</strong><br> → 更适合作为 package 层次存在（controller &#x2F; service &#x2F; mapper）</li>
</ul>
<p>这一认知也解释了为什么教学案例会选择将 MVC 分层整合在 server 模块中。</p>
<hr>
<h2 id="五、项目搭建：从“能跑”到“规范”"><a href="#五、项目搭建：从“能跑”到“规范”" class="headerlink" title="五、项目搭建：从“能跑”到“规范”"></a>五、项目搭建：从“能跑”到“规范”</h2><p>在统一思路后，我按照案例的工程结构重新搭建了项目，形成了如下多模块 Maven 项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend-catering-management-system</span><br><span class="line">├── common</span><br><span class="line">├── pojo</span><br><span class="line">├── server</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure>

<h3 id="父工程的角色"><a href="#父工程的角色" class="headerlink" title="父工程的角色"></a>父工程的角色</h3><p>父工程（parent pom）主要职责是：</p>
<ul>
<li>统一管理依赖版本</li>
<li>统一插件配置</li>
<li>管理子模块（Aggregator）</li>
</ul>
<p>在这一过程中，我遇到了一个典型的 Maven 报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aggregator projects require &#x27;pom&#x27; as packaging</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="问题与结论"><a href="#问题与结论" class="headerlink" title="问题与结论"></a>问题与结论</h3><p>通过该问题明确了一个关键规则：</p>
<ul>
<li><strong>聚合父工程的 packaging 必须是 <code>pom</code></strong></li>
<li>父工程不参与业务代码编译</li>
<li><strong>只有子模块才是 <code>jar</code></strong></li>
</ul>
<p>这一细节也进一步加深了我对 Maven 多模块项目结构的理解。</p>
<hr>
<h2 id="六、阶段性总结"><a href="#六、阶段性总结" class="headerlink" title="六、阶段性总结"></a>六、阶段性总结</h2><p>通过从系统结构图到项目搭建的完整过程，我对后端工程结构有了更清晰的认识：</p>
<ul>
<li>项目结构不能自由发挥，一切为了方便开发为主</li>
<li>复杂的结构并不一定带来更好的工程效果</li>
<li><strong>知道“为什么不这么拆”，比“我能拆得多细”更重要</strong></li>
</ul>
<hr>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/13/backend/project/2026-1-13-project-day01/" data-id="cmkdskca80056ww8tflxa74na" data-title="项目结构搭建：从系统结构图到多模块 Maven 项目设计" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/ssm/springboot/2026-1-11-springboot-day03 " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T16:00:00.000Z" itemprop="datePublished">2026-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/">Spring Boot 配置与测试实战复盘</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文基于一次完整的学习与踩坑过程，系统复盘 <strong>配置绑定、宽松绑定、属性校验、测试配置覆盖、Web 测试</strong> 等关键机制，重点回答一个问题：<br> <strong>Spring Boot 为什么要这样设计？我在工程中应该如何正确使用？</strong></p>
</blockquote>
<h2 id="一、Spring-Boot-热部署的本质：不是“热更新”，而是-ClassLoader-重启"><a href="#一、Spring-Boot-热部署的本质：不是“热更新”，而是-ClassLoader-重启" class="headerlink" title="一、Spring Boot 热部署的本质：不是“热更新”，而是 ClassLoader 重启"></a>一、Spring Boot 热部署的本质：不是“热更新”，而是 ClassLoader 重启</h2><p>在传统 Java Web 项目中，热部署通常由外置 Web 容器完成；<br>而 Spring Boot 采用 <strong>内嵌容器</strong>，服务器本身运行在 Spring 容器中，因此热部署的实现方式完全不同。</p>
<h3 id="devtools-的核心原理"><a href="#devtools-的核心原理" class="headerlink" title="devtools 的核心原理"></a>devtools 的核心原理</h3><p>Spring Boot 的热部署依赖 <code>spring-boot-devtools</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>其核心并不是 JVM 层面的“代码热替换”，而是 <strong>类加载器分层重启</strong>：</p>
<ul>
<li><strong>base ClassLoader</strong>：加载第三方依赖（jar 包），只加载一次</li>
<li><strong>restart ClassLoader</strong>：加载业务代码，修改后可重新加载</li>
</ul>
<p>热部署的本质是：<strong>重启 restart ClassLoader，而不是整个 JVM</strong>。</p>
<h3 id="为什么线上环境必须关闭热部署？"><a href="#为什么线上环境必须关闭热部署？" class="headerlink" title="为什么线上环境必须关闭热部署？"></a>为什么线上环境必须关闭热部署？</h3><ul>
<li>ClassLoader 重启可能带来状态不一致</li>
<li>与线上稳定性目标冲突</li>
<li>devtools 本身只服务于开发阶段</li>
<li>额外的开销，线上改不了源码，所以也不会启动热部署</li>
</ul>
<p>因此，<strong>热部署是开发工具</strong>。</p>
<hr>
<h2 id="二、-ConfigurationProperties：配置绑定的正确方式"><a href="#二、-ConfigurationProperties：配置绑定的正确方式" class="headerlink" title="二、@ConfigurationProperties：配置绑定的正确方式"></a>二、@ConfigurationProperties：配置绑定的正确方式</h2><h3 id="为什么不推荐大量使用-Value？"><a href="#为什么不推荐大量使用-Value？" class="headerlink" title="为什么不推荐大量使用 @Value？"></a>为什么不推荐大量使用 @Value？</h3><p><code>@Value</code> 属于“点对点注入”，在配置复杂时会带来问题：</p>
<ul>
<li>类型不安全</li>
<li>分散、不可维护</li>
<li>无法集中校验</li>
</ul>
<p>相比之下，<code>@ConfigurationProperties</code> 提供了 <strong>结构化配置绑定</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">servers:</span><br><span class="line">  ip-address: 192.168.0.1</span><br><span class="line">  port: 2345</span><br><span class="line">  timeout: 3h</span><br><span class="line"></span><br><span class="line">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="line">public class ServerConfig &#123;</span><br><span class="line">    private String ipAddress;</span><br><span class="line">    private int port;</span><br><span class="line">    private Duration timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、宽松绑定-≠-配置名可以随便写（第一个踩坑点）"><a href="#三、宽松绑定-≠-配置名可以随便写（第一个踩坑点）" class="headerlink" title="三、宽松绑定 ≠ 配置名可以随便写（第一个踩坑点）"></a>三、宽松绑定 ≠ 配置名可以随便写（第一个踩坑点）</h2><h3 id="我最初的误解"><a href="#我最初的误解" class="headerlink" title="我最初的误解"></a>我最初的误解</h3><blockquote>
<p>Spring Boot 配置支持宽松绑定，忽略大小写、中划线、下划线<br> 那是不是 <code>dataSource</code>、<code>data_source</code>、<code>data-source</code> 都可以？</p>
</blockquote>
<h3 id="实际踩坑现象"><a href="#实际踩坑现象" class="headerlink" title="实际踩坑现象"></a>实际踩坑现象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataSource:</span><br><span class="line">  url: jdbc:mysql://...</span><br></pre></td></tr></table></figure>

<p>启动时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Configuration property name &#x27;dataSource&#x27; is not valid</span><br><span class="line">Canonical names should be kebab-case</span><br></pre></td></tr></table></figure>

<h3 id="3-3-正确理解（非常重要）"><a href="#3-3-正确理解（非常重要）" class="headerlink" title="3.3 正确理解（非常重要）"></a>3.3 正确理解（非常重要）</h3><ul>
<li><strong>宽松绑定发生在：配置项 → Java 字段</strong></li>
<li><strong>但配置 key 本身必须是合法的 canonical 名称</strong></li>
</ul>
<p>正确写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  url: ...</span><br></pre></td></tr></table></figure>

<p>或官方标准写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>宽松绑定解决的是“如何映射”，不是“命名是否合法”。</p>
</blockquote>
<hr>
<h2 id="四、-Validated-是一把“双刃剑”（第二个踩坑点）"><a href="#四、-Validated-是一把“双刃剑”（第二个踩坑点）" class="headerlink" title="四、@Validated 是一把“双刃剑”（第二个踩坑点）"></a>四、@Validated 是一把“双刃剑”（第二个踩坑点）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="line">@Validated</span><br><span class="line">public class ServerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Min(1)</span><br><span class="line">    @Max(1234)</span><br><span class="line">    private int port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在生产环境中的价值"><a href="#在生产环境中的价值" class="headerlink" title="在生产环境中的价值"></a>在生产环境中的价值</h3><ul>
<li>配置非法 → 容器启动失败</li>
<li>fail-fast，避免线上事故</li>
<li>非常符合工程安全性要求</li>
</ul>
<h3 id="在测试环境中被“反杀”"><a href="#在测试环境中被“反杀”" class="headerlink" title="在测试环境中被“反杀”"></a>在测试环境中被“反杀”</h3><p>测试中尝试覆盖配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(properties = &#123;</span><br><span class="line">    &quot;servers.port=8888&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果直接启动失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstraintViolationException</span><br></pre></td></tr></table></figure>

<p>原因：<br> <strong>8888 超出了 @Max(1234)</strong></p>
<h3 id="正确的工程姿势"><a href="#正确的工程姿势" class="headerlink" title="正确的工程姿势"></a>正确的工程姿势</h3><ul>
<li><strong>测试只覆盖 <code>servers.port</code>（Web 端口）</strong></li>
<li>业务配置仍使用合法值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(properties = &#123;</span><br><span class="line">    &quot;servers.port=8888&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试不是绕过校验，而是在合法范围内模拟不同环境。</strong></p>
</blockquote>
<hr>
<h2 id="六、Web-层测试：为什么我选择-MockMvc"><a href="#六、Web-层测试：为什么我选择-MockMvc" class="headerlink" title="六、Web 层测试：为什么我选择 MockMvc"></a>六、Web 层测试：为什么我选择 MockMvc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">class WebTest &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="MockMvc-的优势"><a href="#MockMvc-的优势" class="headerlink" title="MockMvc 的优势"></a>MockMvc 的优势</h3><ul>
<li>不需要真实端口</li>
<li>不依赖网络</li>
<li>执行速度快</li>
<li>适合 CI &#x2F; 自动化测试</li>
</ul>
<h3 id="JSON-断言的工程选择"><a href="#JSON-断言的工程选择" class="headerlink" title="JSON 断言的工程选择"></a>JSON 断言的工程选择</h3><ul>
<li>接口稳定：<code>content().json()</code></li>
<li>接口可能演进：<code>jsonPath()</code></li>
</ul>
<hr>
<h2 id="七、我从这次-Spring-Boot-学习中总结的经验"><a href="#七、我从这次-Spring-Boot-学习中总结的经验" class="headerlink" title="七、我从这次 Spring Boot 学习中总结的经验"></a>七、我从这次 Spring Boot 学习中总结的经验</h2><ol>
<li><strong>配置名是否合法，比是否能绑定更早发生</strong></li>
<li>宽松绑定只解决映射问题，不解决命名问题</li>
<li><code>@Validated</code> 是 fail-fast，不是调试工具</li>
<li>测试配置覆盖必须遵守业务约束</li>
<li>Web 测试优先 MockMvc，而不是启动真实端口</li>
</ol>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/" data-id="cmkdskcab005kww8taq4d6c0z" data-title="Spring Boot 配置与测试实战复盘" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T06:30:00.000Z" itemprop="datePublished">2026-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/">从回溯到记忆化搜索到递推：动态规划巩固练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>今天的练习并不是学习新的 DP 模板，而是<strong>围绕两个最经典的模型：打家劫舍 与 爬楼梯，去做“变形题”的识别与迁移</strong>。</p>
<p>通过这一组题目的训练，我逐渐体会到：</p>
<p>动态规划的关键不在于记公式，而在于识别“本质模型”，并主动把陌生题目转化为熟悉结构。</p>
</blockquote>
<p><strong>基础题目</strong>：198. 打家劫舍</p>
<p><strong>打家劫舍模型变形</strong></p>
<ul>
<li><strong>740. 删除并获得点数</strong></li>
</ul>
<p><strong>爬楼梯模型变形（方案数）</strong></p>
<ul>
<li><strong>2466. 统计构造好字符串的方案数</strong></li>
<li><strong>377. 组合总和 Ⅳ</strong></li>
<li><strong>2266. 统计打字方案数</strong></li>
</ul>
<p><strong>经典二维 DP</strong></p>
<ul>
<li><strong>64. 最小路径和</strong></li>
</ul>
<hr>
<h2 id="核心模型回顾"><a href="#核心模型回顾" class="headerlink" title="核心模型回顾"></a>核心模型回顾</h2><p>在进入具体题目之前，先明确两个核心模型的“<strong>本质约束</strong>”。</p>
<h3 id="1-打家劫舍模型的本质"><a href="#1-打家劫舍模型的本质" class="headerlink" title="1. 打家劫舍模型的本质"></a>1. 打家劫舍模型的本质</h3><ul>
<li>每个元素都有「选 &#x2F; 不选」两种状态</li>
<li><strong>一旦选择某个元素，就会限制相邻元素不能被选择</strong></li>
<li>状态转移通常是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i - 1], dp[i - 2] + value[i])</span><br></pre></td></tr></table></figure>

<p>重点不在“房子”，而在<strong>相邻约束</strong></p>
<hr>
<h3 id="2-爬楼梯模型的本质"><a href="#2-爬楼梯模型的本质" class="headerlink" title="2. 爬楼梯模型的本质"></a>2. 爬楼梯模型的本质</h3><ul>
<li>本质是一个<strong>排列问题</strong></li>
<li><strong>顺序不同 &#x3D; 不同方案</strong></li>
<li>给定一个目标值 <code>target</code></li>
<li>每一步可以选择若干“步长”，问总方案数</li>
</ul>
<p>只要是：</p>
<ul>
<li>「目标值固定」</li>
<li>「每一步可以选择若干选项」</li>
<li>「顺序敏感」</li>
</ul>
<p>都可以往爬楼梯模型上靠</p>
<hr>
<h2 id="结合具体题目分析"><a href="#结合具体题目分析" class="headerlink" title="结合具体题目分析"></a>结合具体题目分析</h2><h3 id="740-删除并获得点数-——-打家劫舍的值域改造"><a href="#740-删除并获得点数-——-打家劫舍的值域改造" class="headerlink" title="740. 删除并获得点数 —— 打家劫舍的值域改造"></a>740. 删除并获得点数 —— 打家劫舍的值域改造</h3><p><strong>题意简述</strong>：<br> 选择一个数 <code>nums[i]</code>，可以获得 <code>nums[i]</code> 的点数，但会删除所有值为 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p>
<h4 id="思路转化"><a href="#思路转化" class="headerlink" title="思路转化"></a>思路转化</h4><p>这道题的难点在于：</p>
<ul>
<li>原数组中，相同数字可能出现多次</li>
<li>删除的是“值相邻”，而不是“位置相邻”</li>
</ul>
<p><strong>关键一步：构造打家劫舍的条件</strong></p>
<p>将数组转为<strong>值域数组</strong></p>
<ul>
<li><code>sums[x]</code>：表示值为 <code>x</code> 的所有元素之和</li>
<li>例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [2,2,3,3,3,4]</span><br><span class="line">sums = [0,0,4,9,4]</span><br></pre></td></tr></table></figure>

<p>此时问题变成：</p>
<blockquote>
<p>在 <code>sums</code> 数组中，选择若干不相邻的元素，使得总和最大</p>
</blockquote>
<p><strong>完全等价于打家劫舍</strong></p>
<hr>
<h3 id="2466-统计构造好字符串的方案数-——-爬楼梯模型"><a href="#2466-统计构造好字符串的方案数-——-爬楼梯模型" class="headerlink" title="2466. 统计构造好字符串的方案数 —— 爬楼梯模型"></a>2466. 统计构造好字符串的方案数 —— 爬楼梯模型</h3><p>这道题表面是字符串问题，但本质非常清晰：</p>
<ul>
<li>当前字符串长度 &#x3D; 已爬的台阶数</li>
<li>每一步可以：<ul>
<li>增加 <code>zero</code> 个字符</li>
<li>或增加 <code>one</code> 个字符</li>
</ul>
</li>
<li>问：长度在 <code>[low, high]</code> 区间内的方案总数</li>
</ul>
<p><strong>这是标准的爬楼梯模型</strong></p>
<ul>
<li><code>dp[i]</code>：构造长度为 <code>i</code> 的方案数</li>
<li>每次从 <code>i - zero</code> 或 <code>i - one</code> 转移而来</li>
</ul>
<hr>
<h3 id="377-组合总和-Ⅳ-——-爬楼梯-顺序敏感"><a href="#377-组合总和-Ⅳ-——-爬楼梯-顺序敏感" class="headerlink" title="377. 组合总和 Ⅳ —— 爬楼梯 + 顺序敏感"></a>377. 组合总和 Ⅳ —— 爬楼梯 + 顺序敏感</h3><p>这道题非常具有代表性：</p>
<ul>
<li>给定 <code>nums</code></li>
<li>目标和 <code>target</code></li>
<li><strong>不同顺序算不同方案</strong></li>
</ul>
<h4 id="本质理解"><a href="#本质理解" class="headerlink" title="本质理解"></a>本质理解</h4><p>可以这样理解：</p>
<blockquote>
<p>爬 <code>target</code> 阶楼梯<br> 每次可以爬 <code>nums[i]</code> 阶<br> 问一共有多少种爬法</p>
</blockquote>
<p>顺序不同 → 不同路径</p>
<hr>
<h3 id="2266-统计打字方案数-——-分组-爬楼梯"><a href="#2266-统计打字方案数-——-分组-爬楼梯" class="headerlink" title="2266. 统计打字方案数 —— 分组 + 爬楼梯"></a>2266. 统计打字方案数 —— 分组 + 爬楼梯</h3><p>这道题本身规则较复杂，但从 DP 角度可以拆解为：</p>
<ol>
<li><strong>按连续相同数字分组</strong></li>
<li>每一组内部：<ul>
<li>是一个「爬楼梯问题」</li>
<li>不同按键允许的最大步长不同</li>
</ul>
</li>
<li><strong>最终答案 &#x3D; 各组方案数相乘</strong></li>
</ol>
<p>这是一个非常典型的：</p>
<blockquote>
<p><strong>局部 DP + 全局组合</strong></p>
</blockquote>
<hr>
<h3 id="64-最小路径和-——-经典二维-DP"><a href="#64-最小路径和-——-经典二维-DP" class="headerlink" title="64. 最小路径和 —— 经典二维 DP"></a>64. 最小路径和 —— 经典二维 DP</h3><p>这是标准的网格 DP：</p>
<ul>
<li><code>dp[i][j]</code> 表示到 <code>(i, j)</code> 的最小路径和</li>
<li>当前状态只依赖：<ul>
<li>上方 <code>(i - 1, j)</code></li>
<li>左方 <code>(i, j - 1)</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</span><br></pre></td></tr></table></figure>

<p>没有变形，但非常适合作为 DP 基础模板反复巩固</p>
<hr>
<h2 id="心得与方法论总结"><a href="#心得与方法论总结" class="headerlink" title="心得与方法论总结"></a>心得与方法论总结</h2><h3 id="1-打家劫舍-≠-偷房子"><a href="#1-打家劫舍-≠-偷房子" class="headerlink" title="1. 打家劫舍 ≠ 偷房子"></a>1. 打家劫舍 ≠ 偷房子</h3><p>打家劫舍的真正核心是：</p>
<blockquote>
<p><strong>选择一个元素，会导致“相邻状态失效”</strong></p>
</blockquote>
<ul>
<li>740 题中，相邻的是「值」</li>
<li>所以我们主动<strong>构造值域数组</strong>，人为制造相邻关系</li>
</ul>
<p><strong>没有条件，就创造条件</strong></p>
<hr>
<h3 id="2-爬楼梯-顺序敏感的方案计数"><a href="#2-爬楼梯-顺序敏感的方案计数" class="headerlink" title="2. 爬楼梯 &#x3D; 顺序敏感的方案计数"></a>2. 爬楼梯 &#x3D; 顺序敏感的方案计数</h3><p>爬楼梯模型特别适合解决：</p>
<ul>
<li>方案数问题</li>
<li>和 &#x2F; 长度固定的问题</li>
<li>顺序不同算不同的情况</li>
</ul>
<p>例如：</p>
<ul>
<li>字符串构造</li>
<li>数字组合</li>
<li>步数累加</li>
</ul>
<p>把「目标值」当成台阶数，把「选择」当成一步能走的距离</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过今天这一组题目的训练，我对动态规划有了一个更重要的认知转变：</p>
<blockquote>
<p><strong>DP 的关键不是记住状态转移方程，而是识别题目的“原型模型”。</strong></p>
</blockquote>
<ul>
<li>看到「相邻不能同时选」 → 想打家劫舍</li>
<li>看到「目标固定 + 多种选择 + 顺序敏感」 → 想爬楼梯</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/" data-id="cmkdskca7004yww8t7jm0e8r9" data-title="从回溯到记忆化搜索到递推：动态规划巩固练习" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-11-dynamicprogramming" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/" class="article-date">
  <time class="dt-published" datetime="2026-01-11T05:30:00.000Z" itemprop="datePublished">2026-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/">动态规划：从回溯到记忆化搜索，再到递推</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><strong>核心思想</strong>：当前状态的最优解，来源于之前状态的最优解</p>
</blockquote>
<p><strong>基础题目</strong>：198. 打家劫舍</p>
<p><strong>扩展题目</strong>：</p>
<ul>
<li>爬楼梯</li>
<li>使用最小花费爬楼梯</li>
<li>爬楼梯 II</li>
<li>打家劫舍 II</li>
</ul>
<hr>
<h2 id="一、什么是动态规划？"><a href="#一、什么是动态规划？" class="headerlink" title="一、什么是动态规划？"></a>一、什么是动态规划？</h2><p>很多人第一次接触动态规划，都会被「状态转移方程」劝退。但实际上，<strong>动态规划并不是一种“新算法”，而是回溯的一种系统性优化</strong>。</p>
<blockquote>
<p>动态规划 &#x3D; 回溯 + 去重 + 自底向上</p>
</blockquote>
<p>理解动态规划，最自然的一条路径是：</p>
<blockquote>
<p><strong>回溯 → 记忆化搜索 → 递推（DP）</strong></p>
</blockquote>
<p>下面我们通过「打家劫舍」这个经典问题，完整走一遍这条路径。</p>
<hr>
<h2 id="二、从回溯开始：暴力-DFS-的本质"><a href="#二、从回溯开始：暴力-DFS-的本质" class="headerlink" title="二、从回溯开始：暴力 DFS 的本质"></a>二、从回溯开始：暴力 DFS 的本质</h2><p>以 <strong>198. 打家劫舍</strong> 为例：</p>
<ul>
<li>每一间房子：<strong>选 or 不选</strong></li>
<li>不能选相邻的房子</li>
</ul>
<p>我们从“最后一个房子”开始思考，定义：</p>
<blockquote>
<p><strong>dfs(i)</strong>：考虑前 <code>i</code> 个房子，能偷到的最大金额</p>
</blockquote>
<p>那么对于第 <code>i</code> 个房子：</p>
<ul>
<li>不偷：最大金额 &#x3D; <code>dfs(i - 1)</code></li>
<li>偷：最大金额 &#x3D; <code>dfs(i - 2) + nums[i]</code></li>
</ul>
<p>得到递归公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i) = max(dfs(i - 1), dfs(i - 2) + nums[i])</span><br></pre></td></tr></table></figure>

<p>但问题也随之而来：<strong>大量重复计算</strong>。</p>
<p><img src="/assets/1.png" alt="1"></p>
<p>可以看到：</p>
<ul>
<li><code>dfs(2)</code> 被计算了多次</li>
<li><code>dfs(1)</code> 被计算了更多次</li>
</ul>
<p>这正是 <strong>动态规划要解决的核心问题：重复子问题</strong></p>
<hr>
<h2 id="三、记忆化搜索：给回溯加“缓存”"><a href="#三、记忆化搜索：给回溯加“缓存”" class="headerlink" title="三、记忆化搜索：给回溯加“缓存”"></a>三、记忆化搜索：给回溯加“缓存”</h2><p>回溯的问题不在于“递归”，而在于 <strong>重复递归</strong>。</p>
<p>解决方法也很直接：</p>
<blockquote>
<p><strong>算过的结果，存下来，下次直接用</strong></p>
</blockquote>
<p>这就是 <strong>记忆化搜索（Memoization）</strong>。</p>
<h3 id="Java-示例"><a href="#Java-示例" class="headerlink" title="Java 示例"></a>Java 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int dfs(int i, int[] nums, int[] cache) &#123;</span><br><span class="line">    if (i &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cache[i] != -1) &#123;</span><br><span class="line">    	// 之前计算过,直接返回</span><br><span class="line">        return cache[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 之前没算过，将当前结果缓存</span><br><span class="line">    cache[i] = Math.max(</span><br><span class="line">        dfs(i - 1, nums, cache),</span><br><span class="line">        dfs(i - 2, nums, cache) + nums[i]</span><br><span class="line">    );</span><br><span class="line">    return cache[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li>时间复杂度：从指数级 ➜ <strong>O(n)</strong></li>
<li>但仍然有：<ul>
<li>递归栈空间</li>
<li>cache 数组空间</li>
</ul>
</li>
</ul>
<p>接下来就是最后一步优化空间复杂度：<strong>递推</strong></p>
<hr>
<h2 id="四、从记忆化搜索到递推（真正的-DP）"><a href="#四、从记忆化搜索到递推（真正的-DP）" class="headerlink" title="四、从记忆化搜索到递推（真正的 DP）"></a>四、从记忆化搜索到递推（真正的 DP）</h2><p>观察记忆化搜索中的递归关系：</p>
<ul>
<li><code>dfs(2)</code> 依赖 <code>dfs(1)</code> 和 <code>dfs(0)</code></li>
<li><code>dfs(3)</code> 依赖 <code>dfs(2)</code> 和 <code>dfs(1)</code></li>
<li>……</li>
</ul>
<p>这说明：</p>
<blockquote>
<p><strong>状态之间的依赖顺序是确定的</strong></p>
</blockquote>
<p>既然如此，我们完全可以：</p>
<ul>
<li>不再“递”</li>
<li>只保留“归”</li>
<li><strong>从小到大计算每一个状态</strong></li>
</ul>
<h3 id="递推（DP）的三要素"><a href="#递推（DP）的三要素" class="headerlink" title="递推（DP）的三要素"></a>递推（DP）的三要素</h3><p>从记忆化搜索到递推，本质上完成了三件事：</p>
<ol>
<li><strong>状态数组（dp）</strong>：<code>dp[i]</code> 记录 <code>dfs(i)</code> 的结果</li>
<li><strong>循环代替递归</strong>：从 <code>i = 0</code> 推到 <code>n</code></li>
<li><strong>初始化代替递归边界</strong>：<code>dp[0]</code>、<code>dp[1]</code> 对应原来的递归边界</li>
</ol>
<h3 id="为什么叫“递推”？"><a href="#为什么叫“递推”？" class="headerlink" title="为什么叫“递推”？"></a>为什么叫“递推”？</h3><blockquote>
<p>因为当前状态是 <strong>由之前状态推导出来的</strong></p>
</blockquote>
<p>在打家劫舍中：</p>
<ul>
<li>偷到第 <code>i</code> 间房子的最大金额<br> <strong>不是只由第 <code>i</code> 间房子决定的</strong></li>
<li>而是由：<ul>
<li>第 <code>i-1</code> 间房子的最优解</li>
<li>第 <code>i-2</code> 间房子的最优解<br> 共同决定</li>
</ul>
</li>
</ul>
<p>这正是动态规划中最核心的结构：</p>
<blockquote>
<p><strong>最优子结构</strong></p>
</blockquote>
<hr>
<h2 id="五、空间优化：从-O-n-到-O-1"><a href="#五、空间优化：从-O-n-到-O-1" class="headerlink" title="五、空间优化：从 O(n) 到 O(1)"></a>五、空间优化：从 O(n) 到 O(1)</h2><p>在打家劫舍中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] 只依赖 dp[i-1] 和 dp[i-2]</span><br></pre></td></tr></table></figure>

<p>因此：</p>
<ul>
<li>不需要完整 dp 数组</li>
<li>只需要保存「前两个状态」</li>
</ul>
<p> 空间复杂度可进一步优化为 <strong>O(1)</strong></p>
<hr>
<h2 id="六、结合具体题目总结-DP-模型"><a href="#六、结合具体题目总结-DP-模型" class="headerlink" title="六、结合具体题目总结 DP 模型"></a>六、结合具体题目总结 DP 模型</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><ul>
<li><strong>状态定义</strong>：<code>dp[i]</code> &#x3D; 爬到第 i 阶的方法数</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化</strong>：<ul>
<li><code>dp[0] = 1</code></li>
<li><code>dp[1] = 1</code></li>
</ul>
</li>
<li><strong>答案</strong>：<code>dp[n]</code></li>
</ul>
<p>本质：<strong>斐波那契数列</strong></p>
<hr>
<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><ul>
<li><strong>状态定义</strong>：<code>dp[i]</code> &#x3D; 到达第 i 阶的最小花费</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i - 1] + cost[i - 1],</span><br><span class="line">            dp[i - 2] + cost[i - 2])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化</strong>：<ul>
<li><code>dp[0] = 0</code></li>
<li><code>dp[1] = 0</code></li>
</ul>
</li>
<li><strong>答案</strong>：<code>dp[n]</code></li>
</ul>
<p>特点： <strong>不是计数，而是最小值优化</strong></p>
<hr>
<h3 id="3693-爬楼梯-II"><a href="#3693-爬楼梯-II" class="headerlink" title="3693. 爬楼梯 II"></a>3693. 爬楼梯 II</h3><ul>
<li>一次可以跳 <strong>1 &#x2F; 2 &#x2F; 3</strong> 阶</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]</span><br></pre></td></tr></table></figure>

<p>本质变化只有：</p>
<blockquote>
<p><strong>当前状态依赖的“历史状态数量”变多了</strong>，计算 cost 的方式不同了</p>
</blockquote>
<hr>
<h3 id="213-打家劫舍-II（环形）"><a href="#213-打家劫舍-II（环形）" class="headerlink" title="213. 打家劫舍 II（环形）"></a>213. 打家劫舍 II（环形）</h3><p>核心难点：</p>
<blockquote>
<p><strong>首尾不能同时选</strong></p>
</blockquote>
<p>经典处理方式：</p>
<ul>
<li>情况一：不偷第 0 间 ➜ 偷 <code>[1 … n-1]</code></li>
<li>情况二：不偷第 n-1 间 ➜ 偷 <code>[0 … n-2]</code></li>
<li>对两种情况分别做 <strong>198 打家劫舍</strong></li>
<li>取最大值</li>
</ul>
<p> <strong>环形 DP → 拆成两个线性 DP</strong></p>
<hr>
<h2 id="七、心得与方法论总结"><a href="#七、心得与方法论总结" class="headerlink" title="七、心得与方法论总结"></a>七、心得与方法论总结</h2><h3 id="动态规划到底“动”在哪？"><a href="#动态规划到底“动”在哪？" class="headerlink" title="动态规划到底“动”在哪？"></a>动态规划到底“动”在哪？</h3><ul>
<li>状态是变化的</li>
<li>当前状态来自之前状态</li>
<li>本质是 <strong>dfs 中的“归”</strong></li>
</ul>
<p>递推，其实就是：</p>
<blockquote>
<p><strong>省略 dfs 的“递”，只保留“归”</strong></p>
</blockquote>
<hr>
<h3 id="想不出递推公式怎么办？"><a href="#想不出递推公式怎么办？" class="headerlink" title="想不出递推公式怎么办？"></a>想不出递推公式怎么办？</h3><p>一个非常实用的技巧：</p>
<blockquote>
<p><strong>回退一步，用回溯 + 记忆化搜索先写出来</strong></p>
</blockquote>
<ul>
<li>回溯天然符合“选 or 不选”</li>
<li>递归公式写出来后</li>
<li>直接“翻译”为 dp 即可</li>
</ul>
<hr>
<h3 id="什么时候应该想到动态规划？"><a href="#什么时候应该想到动态规划？" class="headerlink" title="什么时候应该想到动态规划？"></a>什么时候应该想到动态规划？</h3><p>当题目满足以下特征之一时，<strong>高度警惕 DP</strong>：</p>
<ul>
<li>当前结果依赖之前的结果</li>
<li>有“最优”“最多”“最少”“方案数”等关键词</li>
<li>存在大量重复子问题</li>
<li>能清晰定义「状态」</li>
</ul>
<p>一句话总结：</p>
<blockquote>
<p><strong>只要当前状态是在之前状态的基础上演化而来，就可以尝试动态规划</strong></p>
</blockquote>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>动态规划并不是死记模板，而是一种 <strong>从回溯中抽象出的系统性思维方式</strong>。<br>真正掌握 DP 的标志，不是会写状态转移方程，而是：</p>
<blockquote>
<p><strong>能从回溯自然地推导出递推</strong></p>
</blockquote>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/" data-id="cmkdskca6004rww8tcl6o592h" data-title="动态规划：从回溯到记忆化搜索，再到递推" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-10-Permutation-backtracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/" class="article-date">
  <time class="dt-published" datetime="2026-01-10T05:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/">排列型回溯</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>排列型回溯的本质是「<strong>每一层都可以从所有未使用的元素中重新选择</strong>」，顺序不同即视为不同答案，通常通过 <strong>used &#x2F; flag 数组</strong> 来记录当前路径中已使用的元素。</p>
</blockquote>
<hr>
<h2 id="一、什么是排列型回溯？"><a href="#一、什么是排列型回溯？" class="headerlink" title="一、什么是排列型回溯？"></a>一、什么是排列型回溯？</h2><p>在回溯问题中，<strong>排列型问题</strong>有一个非常鲜明的特征：</p>
<ul>
<li><strong>元素相同，但顺序不同，算作不同答案</strong></li>
<li>例如：<ul>
<li><code>[1, 2]</code> 和 <code>[2, 1]</code> 是 <strong>两个不同的解</strong></li>
</ul>
</li>
</ul>
<p>这与我们之前做过的两类问题形成了清晰对比：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否关心顺序</th>
<th>是否允许重复选</th>
</tr>
</thead>
<tbody><tr>
<td>子集型</td>
<td>❌ 不关心</td>
<td>每个元素只选 &#x2F; 不选</td>
</tr>
<tr>
<td>组合型</td>
<td>❌ 不关心</td>
<td>对于选或不选有约束条件</td>
</tr>
<tr>
<td><strong>排列型</strong></td>
<td>✅ 关心</td>
<td><strong>每一轮可选任意当前轮次未使用元素</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="二、排列型回溯的核心思想"><a href="#二、排列型回溯的核心思想" class="headerlink" title="二、排列型回溯的核心思想"></a>二、排列型回溯的核心思想</h2><p>从「<strong>枚举答案的角度</strong>」来看，排列型回溯有两个关键点：</p>
<h3 id="每一层都在“选位置”，而不是“选元素范围”"><a href="#每一层都在“选位置”，而不是“选元素范围”" class="headerlink" title="每一层都在“选位置”，而不是“选元素范围”"></a>每一层都在“选位置”，而不是“选元素范围”</h3><ul>
<li>第 0 位选谁？</li>
<li>第 1 位选谁？</li>
<li>第 2 位选谁？</li>
</ul>
<p>每一层都可以从 <strong>当前轮所有尚未使用的元素中选择</strong></p>
<hr>
<h3 id="必须显式记录「当前路径中已使用的元素」"><a href="#必须显式记录「当前路径中已使用的元素」" class="headerlink" title="必须显式记录「当前路径中已使用的元素」"></a>必须显式记录「当前路径中已使用的元素」</h3><p>因此，排列型回溯 <strong>一定需要</strong> 一个 <code>used / flag</code> 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">used[i] = true  → nums[i] 已经在当前排列中使用过</span><br><span class="line">used[i] = false → 当前轮次仍可选择 nums[i]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、基础题目分析"><a href="#三、基础题目分析" class="headerlink" title="三、基础题目分析"></a>三、基础题目分析</h2><h3 id="46-全排列（Permutations）"><a href="#46-全排列（Permutations）" class="headerlink" title="46. 全排列（Permutations）"></a>46. 全排列（Permutations）</h3><h4 id="问题特征"><a href="#问题特征" class="headerlink" title="问题特征"></a>问题特征</h4><ul>
<li>目标：生成数组的所有排列</li>
<li>终止条件：<strong>当前路径长度 &#x3D;&#x3D; nums.length</strong></li>
<li>每一层：从所有 <code>used[i] == false</code> 的元素中选一个</li>
</ul>
<hr>
<h4 id="核心实现思路"><a href="#核心实现思路" class="headerlink" title="核心实现思路"></a>核心实现思路</h4><ol>
<li>使用 <code>path</code> 记录当前排列</li>
<li>使用 <code>used[]</code> 标记哪些元素已被选</li>
<li>当 <code>path.size() == nums.length</code> 时，记录答案</li>
<li>回溯时恢复现场（<code>used[i] = false</code>）</li>
</ol>
<hr>
<h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><ul>
<li><strong>排列的深度 &#x3D; nums.length</strong></li>
<li><strong>叶子节点数量 &#x3D; n!</strong></li>
<li><code>used[]</code> 的作用是：<strong>保证每个元素在同一条路径中只出现一次</strong></li>
</ul>
<hr>
<h3 id="51-N-皇后（N-Queens）"><a href="#51-N-皇后（N-Queens）" class="headerlink" title="51. N 皇后（N-Queens）"></a>51. N 皇后（N-Queens）</h3><p>这是一个<strong>非常经典的“受限排列问题”</strong>。</p>
<hr>
<h4 id="问题拆解"><a href="#问题拆解" class="headerlink" title="问题拆解"></a>问题拆解</h4><ul>
<li>每一行只能放一个皇后</li>
<li>每一列只能放一个皇后</li>
<li>皇后不能在同一条对角线上</li>
</ul>
<hr>
<h4 id="建模方式（非常关键）"><a href="#建模方式（非常关键）" class="headerlink" title="建模方式（非常关键）"></a>建模方式（非常关键）</h4><p>用一个一维数组 <code>queens</code> 表示棋盘状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queens[row] = col</span><br></pre></td></tr></table></figure>

<p>含义是：</p>
<ul>
<li>第 <code>row</code> 行</li>
<li>第 <code>col</code> 列</li>
<li>放置了一个皇后</li>
</ul>
<hr>
<h4 id="为什么这是一个排列问题？"><a href="#为什么这是一个排列问题？" class="headerlink" title="为什么这是一个排列问题？"></a>为什么这是一个排列问题？</h4><ul>
<li>行天然不重复（递归层数保证）</li>
<li>列不能重复 → <code>queens</code> 本质是一个 <strong>列索引的全排列</strong></li>
<li>对角线限制 → 给这个全排列 <strong>增加合法性约束</strong></li>
</ul>
<hr>
<h4 id="对角线判断条件"><a href="#对角线判断条件" class="headerlink" title="对角线判断条件"></a>对角线判断条件</h4><p>若两个皇后在 <code>(r1, c1)</code> 和 <code>(r2, c2)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|r1 - r2| == |c1 - c2| → 在同一对角线</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="本质总结"><a href="#本质总结" class="headerlink" title="本质总结"></a>本质总结</h4><blockquote>
<p><strong>N 皇后 &#x3D; 带约束条件的全排列问题</strong></p>
</blockquote>
<hr>
<h2 id="四、扩展题目"><a href="#四、扩展题目" class="headerlink" title="四、扩展题目"></a>四、扩展题目</h2><h3 id="357-统计各位数字都不同的数字个数"><a href="#357-统计各位数字都不同的数字个数" class="headerlink" title="357. 统计各位数字都不同的数字个数"></a>357. 统计各位数字都不同的数字个数</h3><p>这道题虽然形式不同，但本质仍然是：</p>
<ul>
<li>在每一位上选数字</li>
<li>同一个数字不能重复使用</li>
<li>位数不同，形成不同答案</li>
</ul>
<p>本质是 <strong>多层排列 + 剪枝计数</strong>，而不是生成具体排列。</p>
<hr>
<h2 id="五、排列型回溯的时间复杂度"><a href="#五、排列型回溯的时间复杂度" class="headerlink" title="五、排列型回溯的时间复杂度"></a>五、排列型回溯的时间复杂度</h2><p>排列问题的时间复杂度通常非常直观：</p>
<ul>
<li><p><strong>等于叶子节点数量</strong></p>
</li>
<li><p>对于 n 个元素的全排列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度 = O(n!) // 画树分析节点数量得到</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这是排列问题不可避免的代价，因此：</p>
<ul>
<li>剪枝尤为重要</li>
<li>约束条件越多，搜索空间越小</li>
</ul>
<hr>
<h2 id="六、心得体会与方法论总结"><a href="#六、心得体会与方法论总结" class="headerlink" title="六、心得体会与方法论总结"></a>六、心得体会与方法论总结</h2><h3 id="排列型回溯的固定模板"><a href="#排列型回溯的固定模板" class="headerlink" title="排列型回溯的固定模板"></a>排列型回溯的固定模板</h3><ol>
<li>路径长度固定（通常等于元素个数）</li>
<li>每一层从 <strong>所有未使用元素中选择</strong></li>
<li>使用 <code>used[] / flag[]</code> 记录使用状态</li>
<li>回溯时一定要 <strong>恢复现场</strong></li>
</ol>
<hr>
<h3 id="与前两类回溯的根本区别"><a href="#与前两类回溯的根本区别" class="headerlink" title="与前两类回溯的根本区别"></a>与前两类回溯的根本区别</h3><blockquote>
<p><strong>是否允许在下一层重新选择之前没选过的元素</strong></p>
</blockquote>
<ul>
<li>子集 &#x2F; 组合：「之前轮次选过，就不能再选」</li>
<li>排列：「只要当前路径没用过，就可以选」</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/" data-id="cmkdskc920005ww8t2zub1v8f" data-title="排列型回溯" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-10-backtracking-summary" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/" class="article-date">
  <time class="dt-published" datetime="2026-01-10T05:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/">回溯总结篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在系统完成回溯相关题型后，本篇博客旨在对 <strong>回溯（Backtracking）这一类算法思想进行统一分析与方法论总结</strong>，帮助建立稳定的解题模型。</p>
</blockquote>
<hr>
<h2 id="一、什么是回溯？"><a href="#一、什么是回溯？" class="headerlink" title="一、什么是回溯？"></a>一、什么是回溯？</h2><p><strong>回溯不是一种具体算法，而是一种搜索思想。</strong></p>
<p>从直观角度理解，回溯可以看作是「<strong>悔棋</strong>」：</p>
<ul>
<li>当前选择了一条路往下走</li>
<li>发现这条路走不通，或者已经走完</li>
<li><strong>退回到上一个状态</strong></li>
<li>改选另一条路继续尝试</li>
</ul>
<hr>
<h3 id="回溯与-DFS-的关系"><a href="#回溯与-DFS-的关系" class="headerlink" title="回溯与 DFS 的关系"></a>回溯与 DFS 的关系</h3><p>回溯通常通过 <strong>递归 + 深度优先遍历（DFS）</strong> 实现。</p>
<ul>
<li>DFS 负责：<strong>一路向下探索</strong></li>
<li>回溯负责：<strong>返回时撤销选择，恢复到上一个状态</strong></li>
</ul>
<p>如果把搜索过程看作一棵树：</p>
<ul>
<li>向子节点走 → 递归深入</li>
<li>回到父节点 → 回溯</li>
<li>访问兄弟节点 → 新的选择</li>
</ul>
<hr>
<h3 id="什么是「增量构造答案」？"><a href="#什么是「增量构造答案」？" class="headerlink" title="什么是「增量构造答案」？"></a>什么是「增量构造答案」？</h3><blockquote>
<p><strong>增量构造答案</strong>：<br> 答案不是一开始就完整出现的，而是<strong>在搜索过程中一步步被“拼”出来的</strong>。</p>
</blockquote>
<p>以集合 <code>(1, 2, 3)</code> 的子集问题为例：</p>
<ul>
<li>我们不会一开始就知道一个完整子集</li>
<li>而是：<ol>
<li>先决定：要不要 <code>1</code></li>
<li>再决定：要不要 <code>2</code></li>
<li>再决定：要不要 <code>3</code></li>
</ol>
</li>
<li>每一次选择，都会在当前路径上 <strong>“增加一点信息”</strong></li>
</ul>
<p>因此：</p>
<ul>
<li>当前路径 <code>path</code> 始终是一个 <strong>“未完成的答案”</strong></li>
<li>只有当满足终止条件时，它才成为一个 <strong>完整答案</strong></li>
</ul>
<p>这也是<strong>剪枝能成立的根本原因</strong>：</p>
<blockquote>
<p>如果在“构造过程中”已经不满足条件，就没必要继续往下走。</p>
</blockquote>
<hr>
<h2 id="二、回溯三问（解题核心视角）"><a href="#二、回溯三问（解题核心视角）" class="headerlink" title="二、回溯三问（解题核心视角）"></a>二、回溯三问（解题核心视角）</h2><p>在写回溯代码前，几乎所有题目都可以先回答这三个问题。</p>
<p>以 <strong>电话号码的字母组合</strong> 为例（用 <code>path</code> 记录路径）：</p>
<hr>
<h3 id="问题一：当前在做什么？"><a href="#问题一：当前在做什么？" class="headerlink" title="问题一：当前在做什么？"></a>问题一：当前在做什么？</h3><blockquote>
<p>当前这一层，我要决定什么？</p>
</blockquote>
<ul>
<li>决定 <code>path[i]</code> 填什么字母</li>
</ul>
<hr>
<h3 id="问题二：子问题是什么？"><a href="#问题二：子问题是什么？" class="headerlink" title="问题二：子问题是什么？"></a>问题二：子问题是什么？</h3><blockquote>
<p>在当前选择之后，还剩下什么问题没解决？</p>
</blockquote>
<ul>
<li>构造字符串中 <strong>索引 ≥ i 的部分</strong></li>
</ul>
<hr>
<h3 id="问题三：递归如何推进？"><a href="#问题三：递归如何推进？" class="headerlink" title="问题三：递归如何推进？"></a>问题三：递归如何推进？</h3><blockquote>
<p>当前层和下一层的关系是什么？</p>
</blockquote>
<ul>
<li>当前决定第 <code>i</code> 位</li>
<li>递归进入第 <code>i + 1</code> 位</li>
</ul>
<p><strong>只要这三点清楚，回溯的递归结构自然就出来了</strong></p>
<hr>
<h2 id="三、恢复现场（回溯的关键）"><a href="#三、恢复现场（回溯的关键）" class="headerlink" title="三、恢复现场（回溯的关键）"></a>三、恢复现场（回溯的关键）</h2><p>在 DFS + 回溯过程中，我们通常会经历：</p>
<ol>
<li>做出一个选择（加入 <code>path</code>）</li>
<li>递归深入</li>
<li>返回时 <strong>撤销这个选择</strong></li>
</ol>
<p>如果不撤销，就会导致：</p>
<ul>
<li>当前路径“污染”后续分支</li>
<li>结果错误或重复</li>
</ul>
<hr>
<h3 id="常见的两种恢复现场方式"><a href="#常见的两种恢复现场方式" class="headerlink" title="常见的两种恢复现场方式"></a>常见的两种恢复现场方式</h3><h4 id="回撤（push-pop）"><a href="#回撤（push-pop）" class="headerlink" title="回撤（push + pop）"></a>回撤（push + pop）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">path.add(x);</span><br><span class="line">dfs();</span><br><span class="line">path.remove(path.size() - 1);</span><br></pre></td></tr></table></figure>

<p>适合 <code>path</code> 长度不固定的情况。</p>
<hr>
<h4 id="覆盖（固定长度数组）"><a href="#覆盖（固定长度数组）" class="headerlink" title="覆盖（固定长度数组）"></a>覆盖（固定长度数组）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path[index] = x;</span><br><span class="line">dfs(index + 1);</span><br></pre></td></tr></table></figure>

<p>适合：</p>
<ul>
<li>全排列</li>
<li>固定长度字符串构造</li>
</ul>
<hr>
<h2 id="四、回溯的三种典型类型"><a href="#四、回溯的三种典型类型" class="headerlink" title="四、回溯的三种典型类型"></a>四、回溯的三种典型类型</h2><p>回溯题目并不是杂乱无章的，大多数都可以归入以下三类。</p>
<p>以数组 <code>[1, 2, 3]</code> 为例：</p>
<hr>
<h3 id="子集型回溯（选-不选）"><a href="#子集型回溯（选-不选）" class="headerlink" title="子集型回溯（选 &#x2F; 不选）"></a>子集型回溯（选 &#x2F; 不选）</h3><p><strong>核心问题</strong>：</p>
<blockquote>
<p>每个元素，选还是不选？</p>
</blockquote>
<h4 id="两种视角"><a href="#两种视角" class="headerlink" title="两种视角"></a>两种视角</h4><ul>
<li><strong>从输入视角</strong>：<ul>
<li>对每个元素做「选 &#x2F; 不选」决策</li>
<li>搜索树是 <strong>严格二叉树</strong></li>
<li>答案通常在叶子节点产生</li>
</ul>
</li>
<li><strong>从答案构造视角</strong>：<ul>
<li>枚举第 <code>i</code> 个答案位置选哪个元素</li>
<li>搜索树是 <strong>多叉树</strong></li>
<li>答案可以在每个节点产生</li>
</ul>
</li>
</ul>
<hr>
<h3 id="组合型回溯（子集-约束）"><a href="#组合型回溯（子集-约束）" class="headerlink" title="组合型回溯（子集 + 约束）"></a>组合型回溯（子集 + 约束）</h3><p>组合型回溯本质上是：</p>
<blockquote>
<p><strong>对子集型回溯增加“合法性约束 + 剪枝”</strong></p>
</blockquote>
<p>常见约束包括：</p>
<ul>
<li>选 <code>k</code> 个数</li>
<li>和等于 <code>target</code></li>
</ul>
<hr>
<h4 id="为什么可以剪枝？"><a href="#为什么可以剪枝？" class="headerlink" title="为什么可以剪枝？"></a>为什么可以剪枝？</h4><p>因为答案是<strong>增量构造的</strong>：</p>
<ul>
<li>如果当前路径已经：<ul>
<li>选多了</li>
<li>和超了</li>
<li>剩余元素不可能满足条件</li>
</ul>
</li>
<li>那么继续向下递归 <strong>一定不可能得到合法答案</strong></li>
</ul>
<p>可以提前返回，剪掉整棵子树。</p>
<hr>
<h3 id="排列型回溯（顺序不同即不同）"><a href="#排列型回溯（顺序不同即不同）" class="headerlink" title="排列型回溯（顺序不同即不同）"></a>排列型回溯（顺序不同即不同）</h3><p>排列型回溯的核心特征：</p>
<ul>
<li><strong>顺序敏感</strong></li>
<li><code>[1,2]</code> 和 <code>[2,1]</code> 是不同答案</li>
</ul>
<hr>
<h4 id="与前两类的本质区别"><a href="#与前两类的本质区别" class="headerlink" title="与前两类的本质区别"></a>与前两类的本质区别</h4><ul>
<li><p>子集 &#x2F; 组合：</p>
<blockquote>
<p>之前选过的元素，后面不能再选</p>
</blockquote>
</li>
<li><p>排列：</p>
<blockquote>
<p><strong>只要当前路径没用过，就可以选</strong></p>
</blockquote>
</li>
</ul>
<p>因此需要：</p>
<ul>
<li>一个 <code>used / flag</code> 数组</li>
<li>表示当前路径中哪些元素已经使用过</li>
</ul>
<hr>
<h2 id="五、统一的回溯伪代码模板"><a href="#五、统一的回溯伪代码模板" class="headerlink" title="五、统一的回溯伪代码模板"></a>五、统一的回溯伪代码模板</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        记录答案;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：当前层可选的所有选项) &#123;</span><br><span class="line">        做选择;</span><br><span class="line">        backtracking(下一层参数);</span><br><span class="line">        撤销选择; // 恢复现场</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、心得总结"><a href="#六、心得总结" class="headerlink" title="六、心得总结"></a>六、心得总结</h2><ul>
<li><p>回溯问题 <strong>不一定是“选或不选”</strong></p>
</li>
<li><p>但一定是 <strong>“做选择 → 走一条路 → 回退 → 换一条路”</strong></p>
</li>
<li><p>本质是：</p>
<blockquote>
<p><strong>在状态空间中系统性地枚举所有可能解</strong></p>
</blockquote>
</li>
</ul>
<p>一旦你能：</p>
<ul>
<li>明确「当前层在决定什么」</li>
<li>明确「路径代表什么」</li>
<li>明确「什么时候可以停、什么时候该剪」</li>
</ul>
<p>那么回溯题目就不再是“凭感觉写代码”，而是一个<strong>高度可复用的方法论问题</strong>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/algorithms/backtracking/2026-1-10-backtracking-summary/" data-id="cmkdskc920006ww8t0jos6e16" data-title="回溯总结篇" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/ssm/springboot/2026-1-10-springboot-day02 " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/" class="article-date">
  <time class="dt-published" datetime="2026-01-09T16:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/">Spring Boot + SSMP 基础实战与问题复盘</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文基于一次完整的 Spring Boot 基础项目实践，总结了从<strong>实体类 → 数据层 → 业务层 → 表现层 → 前后端联调</strong>的开发流程，并重点记录了在整合 MyBatis-Plus、JUnit、分页插件等过程中遇到的典型问题及解决方案，作为后续复盘与查错参考。</p>
</blockquote>
<p>项目采用 <strong>单体架构（非前后端分离）</strong>，以熟悉 Spring Boot + MyBatis-Plus 的基础开发模式为目标。</p>
<h2 id="一、实体类开发（Entity）"><a href="#一、实体类开发（Entity）" class="headerlink" title="一、实体类开发（Entity）"></a>一、实体类开发（Entity）</h2><h3 id="1-数据库准备"><a href="#1-数据库准备" class="headerlink" title="1. 数据库准备"></a>1. 数据库准备</h3><ul>
<li>创建业务表（如 <code>tbl_book</code>）</li>
<li>初始化测试数据</li>
</ul>
<h3 id="2-实体类创建"><a href="#2-实体类创建" class="headerlink" title="2. 实体类创建"></a>2. 实体类创建</h3><ul>
<li>根据表结构创建实体类</li>
<li>使用 <strong>Lombok</strong> 简化样板代码（getter &#x2F; setter &#x2F; toString 等）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Book &#123;</span><br><span class="line">    private Long id;</span><br><span class="line">    private String type;</span><br><span class="line">    private String name;</span><br><span class="line">    private String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二、数据层开发（CRUD）"><a href="#二、数据层开发（CRUD）" class="headerlink" title="二、数据层开发（CRUD）"></a>二、数据层开发（CRUD）</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul>
<li>ORM 框架：<strong>MyBatis-Plus</strong></li>
<li>数据源：<strong>Druid</strong></li>
<li>测试框架：JUnit</li>
</ul>
<h3 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h3><ol>
<li>引入 MyBatis-Plus Starter</li>
<li>配置数据库连接信息</li>
<li>配置 MP 相关属性<ul>
<li>表名前缀（<code>table-prefix</code>）</li>
<li>主键策略（<code>id-type</code>）</li>
<li>SQL 日志（<code>log-impl</code>）</li>
</ul>
</li>
<li>使用 <code>BaseMapper&lt;T&gt;</code> 快速完成 CRUD</li>
<li>使用 <code>@Mapper</code> 或 <code>@MapperScan</code> 交给 Spring 管理</li>
<li>编写 Mapper 测试类验证功能</li>
</ol>
<hr>
<h2 id="三、问题复盘-①：测试类能运行，测试方法却报-NoSuchMethodError"><a href="#三、问题复盘-①：测试类能运行，测试方法却报-NoSuchMethodError" class="headerlink" title="三、问题复盘 ①：测试类能运行，测试方法却报 NoSuchMethodError"></a>三、问题复盘 ①：测试类能运行，测试方法却报 <code>NoSuchMethodError</code></h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><ul>
<li>直接运行测试类 ✔</li>
<li>单独运行测试方法 ❌ 报错：<code>NoSuchMethodError</code></li>
</ul>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ul>
<li><strong>Classpath 中存在多个 JUnit 版本</strong></li>
<li>Spring Boot 默认引入的测试依赖与本地环境冲突</li>
</ul>
<h3 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h3><ul>
<li>尝试在 <code>pom.xml</code> 中强制覆盖 JUnit 版本 → ❌ 无效</li>
<li><strong>最终解决方案：降低 Spring Boot 版本</strong></li>
</ul>
<p>从 <strong>Spring Boot 4.x 降级到 Spring Boot 3.x</strong> 后问题消失</p>
<blockquote>
<p>结论：<br> <strong>测试相关问题优先排查：Spring Boot 版本 × Starter 版本 × IDE 运行方式</strong></p>
</blockquote>
<hr>
<h2 id="四、问题复盘-②：Spring-Boot-3-MyBatis-Plus-启动时报-Mapper-Bean-异常"><a href="#四、问题复盘-②：Spring-Boot-3-MyBatis-Plus-启动时报-Mapper-Bean-异常" class="headerlink" title="四、问题复盘 ②：Spring Boot 3 + MyBatis-Plus 启动时报 Mapper Bean 异常"></a>四、问题复盘 ②：Spring Boot 3 + MyBatis-Plus 启动时报 Mapper Bean 异常</h2><h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Invalid bean definition with name &#x27;xxxMapper&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ul>
<li><code>@Mapper</code> ✔</li>
<li><code>@MapperScan</code> ✔</li>
<li>包路径无误 ✔</li>
</ul>
<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p><strong>Spring Boot 3 与 MyBatis-Plus Starter 版本不兼容</strong></p>
<h3 id="正确依赖方式"><a href="#正确依赖方式" class="headerlink" title="正确依赖方式"></a>正确依赖方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Spring Boot 2.x --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Spring Boot 3.x --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-spring-boot3-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：<br> <strong>Spring Boot 3 必须使用 boot3 专用的 MyBatis-Plus Starter</strong></p>
</blockquote>
<hr>
<h2 id="五、问题复盘-③：配置了-IdType-AUTO，却生成了“雪花-ID”"><a href="#五、问题复盘-③：配置了-IdType-AUTO，却生成了“雪花-ID”" class="headerlink" title="五、问题复盘 ③：配置了 IdType.AUTO，却生成了“雪花 ID”"></a>五、问题复盘 ③：配置了 <code>IdType.AUTO</code>，却生成了“雪花 ID”</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><ul>
<li>实体类主键配置为 <code>IdType.AUTO</code></li>
<li>插入后 ID 却像雪花算法生成</li>
</ul>
<h3 id="真正原因"><a href="#真正原因" class="headerlink" title="真正原因"></a>真正原因</h3><p>并非 AUTO 失效，而是：</p>
<ul>
<li>之前使用过 <strong>雪花 ID 策略</strong></li>
<li>删除数据后，<strong>数据库的 <code>AUTO_INCREMENT</code> 未重置</strong></li>
<li>产生了“脏 ID ”</li>
</ul>
<h3 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tbl_book AUTO_INCREMENT = 1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：<br> <strong>主键策略问题，一定要同时检查：代码配置 + 数据库状态</strong></p>
</blockquote>
<hr>
<h2 id="六、数据层开发（分页功能）"><a href="#六、数据层开发（分页功能）" class="headerlink" title="六、数据层开发（分页功能）"></a>六、数据层开发（分页功能）</h2><h3 id="MyBatis-Plus-分页-API"><a href="#MyBatis-Plus-分页-API" class="headerlink" title="MyBatis-Plus 分页 API"></a>MyBatis-Plus 分页 API</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testGetPage()&#123;</span><br><span class="line">    IPage&lt;Book&gt; page = new Page&lt;&gt;(2, 5);</span><br><span class="line">    bookMapper.selectPage(page, null);</span><br><span class="line"></span><br><span class="line">    System.out.println(page.getCurrent());</span><br><span class="line">    System.out.println(page.getSize());</span><br><span class="line">    System.out.println(page.getTotal());</span><br><span class="line">    System.out.println(page.getPages());</span><br><span class="line">    System.out.println(page.getRecords());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分页参数说明"><a href="#分页参数说明" class="headerlink" title="分页参数说明"></a>分页参数说明</h3><ul>
<li>当前页码</li>
<li>每页条数</li>
</ul>
<h3 id="必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）"><a href="#必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）" class="headerlink" title="必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）"></a>必须配置分页拦截器（由于分页是方言，为了提高扩展性，通过拦截器的方式实现）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class MPConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;</span><br><span class="line">        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();</span><br><span class="line">        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());</span><br><span class="line">        return interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、问题复盘-④：分页不生效"><a href="#七、问题复盘-④：分页不生效" class="headerlink" title="七、问题复盘 ④：分页不生效"></a>七、问题复盘 ④：分页不生效</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul>
<li>MyBatis-Plus <strong>将分页能力拆分为插件</strong></li>
<li>未引入解析 SQL 的依赖</li>
</ul>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-jsqlparser&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.5.15&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、数据层开发（条件查询）"><a href="#八、数据层开发（条件查询）" class="headerlink" title="八、数据层开发（条件查询）"></a>八、数据层开发（条件查询）</h2><h3 id="普通条件构造（存在风险）"><a href="#普通条件构造（存在风险）" class="headerlink" title="普通条件构造（存在风险）"></a>普通条件构造（存在风险）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;Book&gt; qw = new QueryWrapper&lt;&gt;();</span><br><span class="line">qw.like(&quot;name&quot;, &quot;Spring&quot;);</span><br><span class="line">bookMapper.selectList(qw);</span><br></pre></td></tr></table></figure>

<p>❌ 问题：字段名是字符串，<strong>编译期无法检查</strong></p>
<hr>
<h3 id="Lambda-条件构造（推荐）"><a href="#Lambda-条件构造（推荐）" class="headerlink" title="Lambda 条件构造（推荐）"></a>Lambda 条件构造（推荐）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LambdaQueryWrapper&lt;Book&gt; lqw = new LambdaQueryWrapper&lt;&gt;();</span><br><span class="line">lqw.like(name != null, Book::getName, name);</span><br><span class="line">bookMapper.selectList(lqw);</span><br></pre></td></tr></table></figure>

<p>✅ 优点：</p>
<ul>
<li>编译期安全</li>
<li>支持条件开关</li>
<li>重构友好</li>
</ul>
<hr>
<h2 id="九、业务层开发（Service）"><a href="#九、业务层开发（Service）" class="headerlink" title="九、业务层开发（Service）"></a>九、业务层开发（Service）</h2><p>业务层职责：</p>
<blockquote>
<p><strong>组织业务逻辑，对数据层进行封装调用</strong></p>
</blockquote>
<p>开发步骤：</p>
<ol>
<li>定义 Service 接口</li>
<li>编写 ServiceImpl</li>
<li>注入 Mapper</li>
<li>编写测试验证逻辑正确性</li>
</ol>
<hr>
<h2 id="十、表现层开发（Controller）"><a href="#十、表现层开发（Controller）" class="headerlink" title="十、表现层开发（Controller）"></a>十、表现层开发（Controller）</h2><h3 id="核心工作"><a href="#核心工作" class="headerlink" title="核心工作"></a>核心工作</h3><ul>
<li>编写 REST Controller</li>
<li>接收参数</li>
<li>调用业务层</li>
<li>返回统一结果</li>
</ul>
<h3 id="参数接收注意点"><a href="#参数接收注意点" class="headerlink" title="参数接收注意点"></a>参数接收注意点</h3><ul>
<li>JSON 实体：<code>@RequestBody</code></li>
<li>路径变量：<code>@PathVariable</code></li>
</ul>
<p>使用 <strong>ApiFox</strong> 进行接口测试与调试。</p>
<hr>
<h2 id="十一、统一返回结果设计"><a href="#十一、统一返回结果设计" class="headerlink" title="十一、统一返回结果设计"></a>十一、统一返回结果设计</h2><p>为保证前后端交互一致性：</p>
<ul>
<li>封装统一响应对象</li>
<li>包含：<ul>
<li><code>code</code></li>
<li><code>data</code></li>
<li><code>msg</code></li>
</ul>
</li>
<li>同时考虑异常场景</li>
</ul>
<hr>
<h2 id="十二、前后端联调"><a href="#十二、前后端联调" class="headerlink" title="十二、前后端联调"></a>十二、前后端联调</h2><ul>
<li><p>将前端静态资源拷贝到：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resources/static</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring Boot 自动托管静态资源</p>
</li>
<li><p>实现简单的前后端一体化访问</p>
</li>
</ul>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次 Spring Boot 基础实战，我完成了：</p>
<ul>
<li>一条完整的 <strong>SSMP 开发链路</strong></li>
<li>多个 <strong>真实问题的排查与解决</strong></li>
<li>对 <strong>版本兼容性、插件机制、主键策略</strong> 的深入理解</li>
</ul>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/backend/ssm/springboot/2026-1-10-springboot-day02%20/" data-id="cmkdskcaa005gww8tbry91p2w" data-title="Spring Boot + SSMP 基础实战与问题复盘" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mybatis-plus/" rel="tag">mybatis-plus</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-9-Combinatorial backtracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/" class="article-date">
  <time class="dt-published" datetime="2026-01-09T04:00:00.000Z" itemprop="datePublished">2026-01-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/">组合型回溯 + 剪枝：从子集枚举到条件收敛</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="组合型回溯-剪枝"><a href="#组合型回溯-剪枝" class="headerlink" title="组合型回溯 + 剪枝"></a>组合型回溯 + 剪枝</h1><blockquote>
<p><strong>一句话总结</strong>：<br> 组合型回溯本质仍是子集型回溯，但通过“组合约束 + 单调性剪枝”，将指数级搜索空间大幅收缩，只遍历“有可能成为答案”的分支。</p>
</blockquote>
<hr>
<h2 id="一、什么是组合型回溯？"><a href="#一、什么是组合型回溯？" class="headerlink" title="一、什么是组合型回溯？"></a>一、什么是组合型回溯？</h2><p>在回溯问题中，我们通常会遇到两类经典模型：</p>
<ul>
<li><strong>子集型回溯</strong>：<br> 枚举所有可能的子集（选 &#x2F; 不选），不关心长度或数值约束</li>
<li><strong>组合型回溯</strong>：<br> 在子集枚举的基础上，<strong>只保留满足条件的组合</strong></li>
</ul>
<p>常见的组合约束包括：</p>
<ul>
<li>固定长度（如选 k 个数）</li>
<li>固定和（如和为 target）</li>
<li>结构合法性（如括号匹配、IP 段合法）</li>
</ul>
<p>因此，<strong>组合型回溯 &#x3D; 子集型回溯 + 条件约束 + 剪枝</strong>。</p>
<hr>
<h2 id="二、组合型回溯的核心思想"><a href="#二、组合型回溯的核心思想" class="headerlink" title="二、组合型回溯的核心思想"></a>二、组合型回溯的核心思想</h2><p>组合型回溯的关键并不在「怎么枚举」，而在于：</p>
<blockquote>
<p><strong>当前状态已经不可能构成合法解时，要尽早停止搜索</strong></p>
</blockquote>
<p>这正是剪枝的价值所在。</p>
<h3 id="常见剪枝维度"><a href="#常见剪枝维度" class="headerlink" title="常见剪枝维度"></a>常见剪枝维度</h3><ol>
<li><strong>数量剪枝</strong><ul>
<li>剩余可选元素 &lt; 还需要选的数量 → 直接返回</li>
</ul>
</li>
<li><strong>数值剪枝（选择元素为正）</strong><ul>
<li>当前和已经超过 target</li>
<li>即使选最大值，也无法达到 target</li>
</ul>
</li>
<li><strong>结构剪枝</strong><ul>
<li>不满足合法结构（如右括号多于左括号）</li>
</ul>
</li>
</ol>
<p>这些剪枝往往都依赖于一个核心性质：</p>
<blockquote>
<p><strong>单调性</strong>：<br> 当前状态不满足条件，向下扩展只会更不满足。</p>
</blockquote>
<hr>
<h2 id="三、典型题目拆解与剪枝思路"><a href="#三、典型题目拆解与剪枝思路" class="headerlink" title="三、典型题目拆解与剪枝思路"></a>三、典型题目拆解与剪枝思路</h2><h3 id="77-组合（Combinations）"><a href="#77-组合（Combinations）" class="headerlink" title="77. 组合（Combinations）"></a>77. 组合（Combinations）</h3><p><strong>目标</strong>：从 <code>[1…n]</code> 中选 <code>k</code> 个数</p>
<h4 id="关键剪枝"><a href="#关键剪枝" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ul>
<li><strong>数量剪枝</strong><ul>
<li>剩余数字个数 &lt; 还需要选择的数量 → 直接返回</li>
</ul>
</li>
<li><strong>提前返回</strong><ul>
<li>当已选数量 &#x3D;&#x3D; k，记录答案，不再向下搜索</li>
</ul>
</li>
</ul>
<h4 id="本质理解"><a href="#本质理解" class="headerlink" title="本质理解"></a>本质理解</h4><p>这是一个<strong>固定长度的组合问题</strong>，搜索树深度是确定的，剪枝点非常清晰。</p>
<hr>
<h3 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a>216. 组合总和 III</h3><p><strong>目标</strong>：从 <code>[1…9]</code> 中选 <code>k</code> 个数，和为 <code>n</code></p>
<h4 id="关键剪枝-1"><a href="#关键剪枝-1" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ol>
<li><code>leftTarget &lt; 0</code><ul>
<li>所有数均为正数，后续必然无解</li>
</ul>
</li>
<li><code>leftTarget &gt; 剩余可选数字的最大可能和</code><ul>
<li>即使全选最大值，也无法凑够</li>
</ul>
</li>
<li>剩余数字个数 &lt; 还需要选择的数量</li>
</ol>
<h4 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h4><ul>
<li>同时利用了「<strong>一大一小</strong>」两种剪枝方向</li>
<li>体现出数值约束与数量约束的对称性</li>
</ul>
<hr>
<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h3><p><strong>目标</strong>：生成 <code>n</code> 对合法括号</p>
<h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><ul>
<li><code>left</code>：已使用左括号数量</li>
<li><code>right</code>：已使用右括号数量</li>
</ul>
<h4 id="剪枝规则"><a href="#剪枝规则" class="headerlink" title="剪枝规则"></a>剪枝规则</h4><ul>
<li><code>left &gt; n</code> → 非法</li>
<li><code>right &gt; left</code> → 非法</li>
</ul>
<h4 id="本质理解-1"><a href="#本质理解-1" class="headerlink" title="本质理解"></a>本质理解</h4><p>这道题可以视为一种<strong>带结构约束的组合回溯</strong>：</p>
<ul>
<li>“选” → 加左括号</li>
<li>“不选” → 加右括号（但有条件）</li>
</ul>
<p>本质不是排列，而是<strong>合法结构的组合生成</strong>。</p>
<hr>
<h3 id="39-组合总和（可重复选择）"><a href="#39-组合总和（可重复选择）" class="headerlink" title="39. 组合总和（可重复选择）"></a>39. 组合总和（可重复选择）</h3><p><strong>目标</strong>：元素可重复选，和为 target</p>
<h4 id="关键剪枝-2"><a href="#关键剪枝-2" class="headerlink" title="关键剪枝"></a>关键剪枝</h4><ol>
<li><p><code>leftTarget &lt; 0</code> → 直接返回</p>
</li>
<li><p><code>leftTarget == 0</code> → 记录答案并返回</p>
</li>
<li><p><strong>排序 + 剪枝</strong></p>
<p>若当前元素 &gt; <code>leftTarget</code>，后续元素更大，可直接 break</p>
</li>
</ol>
<h4 id="可重复选择的表达"><a href="#可重复选择的表达" class="headerlink" title="可重复选择的表达"></a>可重复选择的表达</h4><ul>
<li>使用 <code>dfs(i)</code> 表示<strong>当前元素可再次选择</strong></li>
<li>通过起始索引控制是否允许重复</li>
</ul>
<hr>
<h3 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a>93. 复原 IP 地址</h3><p><strong>目标</strong>：将字符串分割为 4 段合法 IP</p>
<h4 id="强剪枝条件"><a href="#强剪枝条件" class="headerlink" title="强剪枝条件"></a>强剪枝条件</h4><ol>
<li><p><strong>字符数量剪枝</strong></p>
<p>剩余字符数 ∉ <code>[剩余段数, 剩余段数 * 3]</code></p>
</li>
<li><p><strong>数值剪枝</strong></p>
<p>当前段 &gt; 255</p>
</li>
<li><p><strong>前导零剪枝</strong></p>
<p>段以 <code>0</code> 开头但长度 &gt; 1</p>
</li>
</ol>
<h4 id="补充思路"><a href="#补充思路" class="headerlink" title="补充思路"></a>补充思路</h4><ul>
<li>由于段数固定为 4</li>
<li>该题也可以用 <strong>三重循环</strong> 实现</li>
<li>但回溯解法在结构上更统一、可复用性更强</li>
</ul>
<hr>
<h2 id="四、方法论总结：如何写好组合型回溯？"><a href="#四、方法论总结：如何写好组合型回溯？" class="headerlink" title="四、方法论总结：如何写好组合型回溯？"></a>四、方法论总结：如何写好组合型回溯？</h2><h3 id="推荐解题步骤"><a href="#推荐解题步骤" class="headerlink" title="推荐解题步骤"></a>推荐解题步骤</h3><ol>
<li><p><strong>先不剪枝，写出正确解</strong></p>
</li>
<li><p>明确以下要素：</p>
<p>状态变量（路径、索引、剩余目标）</p>
<p>终止条件</p>
</li>
<li><p>回看搜索树，问自己：</p>
<p>当前状态已经不可能成功了吗？</p>
</li>
<li><p>将「不可能成功」的情况提前 return</p>
</li>
</ol>
<h3 id="一个重要认知"><a href="#一个重要认知" class="headerlink" title="一个重要认知"></a>一个重要认知</h3><blockquote>
<p>剪枝为了利用题目的<strong>单调性</strong>。</p>
</blockquote>
<ul>
<li>当前不满足 → 未来一定不满足</li>
<li>才是可以安全剪枝的前提</li>
</ul>
<hr>
<h2 id="五、个人心得体会"><a href="#五、个人心得体会" class="headerlink" title="五、个人心得体会"></a>五、个人心得体会</h2><ul>
<li><p><strong>组合型回溯并不是新的模型</strong><br> 它只是对子集型回溯的“<strong>条件收敛</strong>”</p>
</li>
<li><p>实战中：</p>
<p>先保证正确性、再逐步加剪枝，思路更清晰</p>
</li>
<li><p>多数高质量剪枝，都来源于：</p>
<ul>
<li>数量边界</li>
<li>数值上下界</li>
<li>结构合法性</li>
</ul>
</li>
</ul>
<p>当你能一眼看出「当前状态是否还有希望」，回溯题就不再是暴力搜索，而是<strong>受控的状态枚举</strong>。</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/09/algorithms/backtracking/2026-1-9-Combinatorial%20backtracking/" data-id="cmkdskc96000gww8t7kvkaa8g" data-title="组合型回溯 + 剪枝：从子集枚举到条件收敛" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MyBatis/">MyBatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MyBatis/ssm/">ssm</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/">递归</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/">链表</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/01%E8%83%8C%E5%8C%85/" rel="tag">01背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/" rel="tag">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL%E4%BC%98%E5%8C%96/" rel="tag">SQL优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/druid/" rel="tag">druid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/" rel="tag">jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis-plus/" rel="tag">mybatis-plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml%E6%98%A0%E5%B0%84/" rel="tag">xml映射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" rel="tag">事务原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F/" rel="tag">先序、中序、后序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/" rel="tag">删除链表节点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81mysql/" rel="tag">动态mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" rel="tag">反转链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" rel="tag">学习计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" rel="tag">完全背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">层序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" rel="tag">快慢指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" rel="tag">数据库锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/" rel="tag">时间复杂度优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" rel="tag">深度优先遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">由遍历序列生成二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%86%E5%9B%BE/" rel="tag">视图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" rel="tag">触发器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/01%E8%83%8C%E5%8C%85/" style="font-size: 10px;">01背包</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 10px;">SQL优化</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/druid/" style="font-size: 10px;">druid</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/jdbc/" style="font-size: 12.5px;">jdbc</a> <a href="/tags/maven/" style="font-size: 12.5px;">maven</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/mybatis-plus/" style="font-size: 10px;">mybatis-plus</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/xml%E6%98%A0%E5%B0%84/" style="font-size: 10px;">xml映射</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" style="font-size: 10px;">事务原理</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 20px;">二叉树</a> <a href="/tags/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F/" style="font-size: 12.5px;">先序、中序、后序</a> <a href="/tags/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/" style="font-size: 10px;">删除链表节点</a> <a href="/tags/%E5%8A%A8%E6%80%81mysql/" style="font-size: 10px;">动态mysql</a> <a href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">反转链表</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 17.5px;">回溯</a> <a href="/tags/%E5%AD%90%E9%9B%86/" style="font-size: 12.5px;">子集</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 10px;">学习计划</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" style="font-size: 10px;">完全背包</a> <a href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">层序遍历</a> <a href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" style="font-size: 10px;">快慢指针</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 12.5px;">总结</a> <a href="/tags/%E6%8E%92%E5%88%97/" style="font-size: 10px;">排列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" style="font-size: 10px;">数据库锁</a> <a href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/" style="font-size: 10px;">时间复杂度优化</a> <a href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" style="font-size: 10px;">最近公共祖先</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" style="font-size: 12.5px;">深度优先遍历</a> <a href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">热部署</a> <a href="/tags/%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">由遍历序列生成二叉树</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BB%84%E5%90%88/" style="font-size: 10px;">组合</a> <a href="/tags/%E8%A7%86%E5%9B%BE/" style="font-size: 10px;">视图</a> <a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" style="font-size: 10px;">触发器</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 12.5px;">记录</a> <a href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" style="font-size: 12.5px;">记忆化搜索</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 17.5px;">递归</a> <a href="/tags/%E9%80%92%E6%8E%A8/" style="font-size: 12.5px;">递推</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">配置</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">一月 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">十二月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/14/misc/git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/">git 开发工具整理总结</a>
          </li>
        
          <li>
            <a href="/2026/01/13/algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/">DP 模型：从回溯语义到 0-1 背包与完全背包（2026-01-13）</a>
          </li>
        
          <li>
            <a href="/2026/01/13/backend/project/2026-1-13-project-day01/">项目结构搭建：从系统结构图到多模块 Maven 项目设计</a>
          </li>
        
          <li>
            <a href="/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/">Spring Boot 配置与测试实战复盘</a>
          </li>
        
          <li>
            <a href="/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/">从回溯到记忆化搜索到递推：动态规划巩固练习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 Tingfeng Li<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>