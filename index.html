<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>廷风的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="记录 Java 后端学习与项目实践的技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="廷风的技术博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="廷风的技术博客">
<meta property="og:description" content="记录 Java 后端学习与项目实践的技术博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Tingfeng Li">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="廷风的技术博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">廷风的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Java 后端开发</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-algorithms/dynamicprogramming/2026-1-19-dynamicprogramming-04线性DP总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/19/algorithms/dynamicprogramming/2026-1-19-dynamicprogramming-04%E7%BA%BF%E6%80%A7DP%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2026-01-18T16:00:00.000Z" itemprop="datePublished">2026-01-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/19/algorithms/dynamicprogramming/2026-1-19-dynamicprogramming-04%E7%BA%BF%E6%80%A7DP%E6%80%BB%E7%BB%93/">线性 DP 总结与最长递增子序列（LIS）与二维扩展</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>基础题目</strong>：300. 最长递增子序列<br><strong>扩展题目</strong>：354. 俄罗斯套娃信封问题</p>
<hr>
<h2 id="一、引言：LIS-在「线性-DP」中的位置"><a href="#一、引言：LIS-在「线性-DP」中的位置" class="headerlink" title="一、引言：LIS 在「线性 DP」中的位置"></a>一、引言：LIS 在「线性 DP」中的位置</h2><p>在完整学习了：</p>
<ul>
<li>打家劫舍（选 &#x2F; 不选）</li>
<li>爬楼梯（排列计数）</li>
<li>背包问题（容量约束）</li>
<li>双序列线性 DP（公共子序列）</li>
</ul>
<p>之后，<strong>最长递增子序列（LIS）是线性 DP 中最后、也是最容易“升维”的一种模型</strong>。</p>
<p>它的核心特征非常明确：</p>
<blockquote>
<p><strong>单序列 + 子序列 + 有序性约束</strong></p>
</blockquote>
<p>一旦理解 LIS，不仅可以解决一维问题，还可以通过<strong>排序 + 降维</strong>，解决看似更复杂的二维、分组问题。</p>
<hr>
<h2 id="二、354-俄罗斯套娃信封问题"><a href="#二、354-俄罗斯套娃信封问题" class="headerlink" title="二、354. 俄罗斯套娃信封问题"></a>二、354. 俄罗斯套娃信封问题</h2><h3 id="问题本质与第一直觉"><a href="#问题本质与第一直觉" class="headerlink" title="问题本质与第一直觉"></a>问题本质与第一直觉</h3><p>每个信封用 <code>(w, h)</code> 表示，若：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w1 &lt; w2 且 h1 &lt; h2</span><br></pre></td></tr></table></figure>

<p>则信封 1 可以嵌套进信封 2。</p>
<p>直觉思路是：</p>
<blockquote>
<p>把每个信封当成一个“元素”，求最长递增子序列</p>
</blockquote>
<p>但这里<strong>存在一个关键陷阱</strong>：</p>
<p><strong>题目允许任意重排信封顺序</strong><br> → 原数组顺序是无意义的<br> → 直接在二维数组上做 LIS 会<strong>漏解</strong></p>
<hr>
<h3 id="正确建模：二维-→-一维的关键转化"><a href="#正确建模：二维-→-一维的关键转化" class="headerlink" title="正确建模：二维 → 一维的关键转化"></a>正确建模：二维 → 一维的关键转化</h3><p>要想使用 LIS，必须满足：</p>
<blockquote>
<p><strong>只在一个维度上递增</strong></p>
</blockquote>
<p>因此需要先消除一个维度的干扰。</p>
<h4 id="核心转化步骤"><a href="#核心转化步骤" class="headerlink" title="核心转化步骤"></a>核心转化步骤</h4><p><strong>Step 1：排序</strong></p>
<ul>
<li>宽度 <code>w</code>：<strong>升序</strong></li>
<li>高度 <code>h</code>：<strong>降序（当 w 相同）</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 双关键字排序：宽度升序，高度降序</span><br><span class="line">Arrays.sort(envelopes, (a, b) -&gt; &#123;</span><br><span class="line">    if (a[0] == b[0]) &#123;</span><br><span class="line">        return b[1] - a[1]; // 高度降序</span><br><span class="line">    &#125;</span><br><span class="line">    return a[0] - b[0];     // 宽度升序</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="为什么-w-相同时要按-h-降序？"><a href="#为什么-w-相同时要按-h-降序？" class="headerlink" title="为什么 w 相同时要按 h 降序？"></a>为什么 w 相同时要按 h 降序？</h4><p>这是本题<strong>最容易被忽略、也是面试最常考的点</strong>。</p>
<p>如果：</p>
<ul>
<li><code>w</code> 相同</li>
<li><code>h</code> 也按升序排</li>
</ul>
<p>那么在之后对 <code>h</code> 求 LIS 时，会错误地把<strong>同一宽度的信封选进子序列</strong>，违反题意（宽度必须严格递增）。</p>
<p>而 <strong>h 降序</strong> 的作用是：</p>
<blockquote>
<p>在 LIS（严格递增）中，<strong>相同 w 的信封不可能同时被选中</strong></p>
</blockquote>
<hr>
<h3 id="问题彻底降维：只看高度-h"><a href="#问题彻底降维：只看高度-h" class="headerlink" title="问题彻底降维：只看高度 h"></a>问题彻底降维：只看高度 h</h3><p>排序完成后：</p>
<ul>
<li>宽度已经隐式满足递增约束</li>
<li>只需要在高度数组上求 <strong>严格递增 LIS</strong></li>
</ul>
<p>问题就完全转化为：</p>
<blockquote>
<p><strong>300. 最长递增子序列</strong></p>
</blockquote>
<hr>
<h3 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h3><ul>
<li>排序：<code>O(n log n)</code></li>
<li>LIS（贪心 + 二分）：<code>O(n log n)</code></li>
</ul>
<p>整体复杂度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O(n log n)</span><br></pre></td></tr></table></figure>

<p>满足 <code>n ≤ 10^5</code> 的数据规模要求。</p>
<h2 id="三、心得体会（俄罗斯套娃-→-LIS）"><a href="#三、心得体会（俄罗斯套娃-→-LIS）" class="headerlink" title="三、心得体会（俄罗斯套娃 → LIS）"></a>三、心得体会（俄罗斯套娃 → LIS）</h2><p>这道题<strong>真正考察的不是 LIS 本身，而是问题转化能力</strong>：</p>
<ol>
<li><strong>是否意识到原顺序无意义</strong></li>
<li><strong>是否能通过排序消掉一个维度</strong></li>
<li><strong>是否处理了“相等元素”的边界情况</strong></li>
</ol>
<p>本质模型可以总结为一句话：</p>
<blockquote>
<p><strong>二维严格递增问题 &#x3D; 排序 + 一维 LIS</strong></p>
</blockquote>
<hr>
<h2 id="四、线性-DP-模型全景总结"><a href="#四、线性-DP-模型全景总结" class="headerlink" title="四、线性 DP 模型全景总结"></a>四、线性 DP 模型全景总结</h2><p>回顾整个线性 DP 学习路径，可以清晰地分为 <strong>五大模型</strong>。</p>
<hr>
<h3 id="打家劫舍模型（选-不选-相邻约束）"><a href="#打家劫舍模型（选-不选-相邻约束）" class="headerlink" title="打家劫舍模型（选 &#x2F; 不选 + 相邻约束）"></a>打家劫舍模型（选 &#x2F; 不选 + 相邻约束）</h3><p><strong>核心特征</strong></p>
<ul>
<li>枚举元素选或不选</li>
<li>相邻元素不能同时选</li>
</ul>
<p><strong>典型变形</strong></p>
<ul>
<li>打家劫舍 II（成环）<br> → 拆成「选第一个 &#x2F; 不选第一个」</li>
<li>删除并获得点数<br> → 构造值域数组，转化为打家劫舍</li>
</ul>
<hr>
<h3 id="爬楼梯模型（排列型-DP）"><a href="#爬楼梯模型（排列型-DP）" class="headerlink" title="爬楼梯模型（排列型 DP）"></a>爬楼梯模型（排列型 DP）</h3><p><strong>核心特征</strong></p>
<ul>
<li>顺序不同 &#x3D; 不同方案</li>
<li>每一步选择不同“动作”</li>
</ul>
<p><strong>常见变形</strong></p>
<ul>
<li>最小代价爬楼梯</li>
<li>目标字符串构造方案数</li>
<li>组合总和（顺序相关）</li>
<li>分组 + 爬楼梯</li>
</ul>
<hr>
<h3 id="背包模型（容量约束）"><a href="#背包模型（容量约束）" class="headerlink" title="背包模型（容量约束）"></a>背包模型（容量约束）</h3><p><strong>分类</strong></p>
<ul>
<li>01 背包（不能重复选）</li>
<li>完全背包（可以重复选）</li>
</ul>
<p><strong>常见问法</strong></p>
<ul>
<li>至多 &#x2F; 恰好 &#x2F; 至少装满</li>
<li>求最大值 &#x2F; 最小值 &#x2F; 方案数</li>
</ul>
<p><strong>重要收获</strong></p>
<ul>
<li><p>空间优化的本质：</p>
<p>明确当前状态依赖哪些旧状态</p>
<p>是否会发生状态覆盖</p>
<p>必要时引入 <code>pre</code></p>
</li>
</ul>
<hr>
<h3 id="双序列线性-DP"><a href="#双序列线性-DP" class="headerlink" title="双序列线性 DP"></a>双序列线性 DP</h3><p><strong>核心特征</strong></p>
<ul>
<li>操作两个序列</li>
<li>关注“公共部分”</li>
</ul>
<p><strong>典型问题</strong></p>
<ul>
<li>最长公共子序列（LCS）</li>
<li>最短公共超序列（SCS）</li>
<li>编辑距离</li>
</ul>
<hr>
<h3 id="最长递增子序列（LIS）"><a href="#最长递增子序列（LIS）" class="headerlink" title="最长递增子序列（LIS）"></a>最长递增子序列（LIS）</h3><p><strong>核心特征</strong></p>
<ul>
<li>单序列</li>
<li>子序列</li>
<li>有序性约束（递增 &#x2F; 非递减）</li>
</ul>
<p><strong>两种解法层级</strong></p>
<table>
<thead>
<tr>
<th>解法</th>
<th>时间复杂度</th>
<th>适用</th>
</tr>
</thead>
<tbody><tr>
<td>经典 DP</td>
<td>O(n²)</td>
<td>理解模型</td>
</tr>
<tr>
<td>贪心 + 二分</td>
<td>O(n log n)</td>
<td>大规模数据</td>
</tr>
</tbody></table>
<h4 id="关键技巧"><a href="#关键技巧" class="headerlink" title="关键技巧"></a>关键技巧</h4><blockquote>
<p><strong>交换 dp 的“状态”与“状态值”</strong></p>
</blockquote>
<ul>
<li>用 <code>g[k]</code> 表示：<ul>
<li>长度为 <code>k+1</code> 的递增子序列</li>
<li>其末尾元素的最小值</li>
</ul>
</li>
</ul>
<p>严格来说：</p>
<ul>
<li><code>g</code> 不存在状态覆盖</li>
<li>已不再是传统 DP</li>
<li>而是 <strong>贪心 + 有序结构 + 二分查找</strong></li>
</ul>
<hr>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/19/algorithms/dynamicprogramming/2026-1-19-dynamicprogramming-04%E7%BA%BF%E6%80%A7DP%E6%80%BB%E7%BB%93/" data-id="cmkkn3hbl004ugw8t68x6cxfl" data-title="线性 DP 总结与最长递增子序列（LIS）与二维扩展" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LIS/" rel="tag">LIS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7DP/" rel="tag">线性DP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-18-dynamicprogramming-03LIS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/18/algorithms/dynamicprogramming/2026-1-18-dynamicprogramming-03LIS/" class="article-date">
  <time class="dt-published" datetime="2026-01-18T12:56:51.834Z" itemprop="datePublished">2026-01-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/18/algorithms/dynamicprogramming/2026-1-18-dynamicprogramming-03LIS/">线性 DP · 最长递增子序列（LIS）专题总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>基础题目</strong>：300. 最长递增子序列</p>
<p><strong>扩展题目</strong>：</p>
<ul>
<li>将三个组排序</li>
<li>找出到每个位置为止最长的有效障碍赛跑路线</li>
<li>得到山型数组的最少删除次数</li>
<li>使数组 K 递增的最少操作次数</li>
</ul>
<hr>
<h2 id="一、概述：为什么-LIS-是一种“新的线性-DP”"><a href="#一、概述：为什么-LIS-是一种“新的线性-DP”" class="headerlink" title="一、概述：为什么 LIS 是一种“新的线性 DP”"></a>一、概述：为什么 LIS 是一种“新的线性 DP”</h2><p>这两天的题目有一个非常鲜明的共同点：</p>
<blockquote>
<p><strong>都是「单数组 + 子序列 + 有序性」问题</strong></p>
</blockquote>
<p>它们与之前接触的模型（如 0&#x2F;1 背包、完全背包、双序列 DP）有本质区别：</p>
<ul>
<li><strong>不是选容量 &#x2F; 次数</strong></li>
<li><strong>不是两个序列之间的匹配</strong></li>
<li>而是：<strong>在保持原相对顺序的前提下，选出一个“有序的子序列”</strong></li>
</ul>
<p>这类问题的核心关键词是：</p>
<ul>
<li><strong>子序列（Subsequence）</strong></li>
<li><strong>递增 &#x2F; 不降（有序性约束）</strong></li>
<li><strong>最长 &#x2F; 最少删除（等价转化）</strong></li>
</ul>
<p>而这一整类问题，几乎都可以归约到一个经典母题：</p>
<blockquote>
<p><strong>最长递增子序列（LIS）</strong></p>
</blockquote>
<h2 id="二、300-最长递增子序列（LIS）"><a href="#二、300-最长递增子序列（LIS）" class="headerlink" title="二、300. 最长递增子序列（LIS）"></a>二、300. 最长递增子序列（LIS）</h2><h3 id="从回溯到-O-n²-线性-DP"><a href="#从回溯到-O-n²-线性-DP" class="headerlink" title="从回溯到 O(n²) 线性 DP"></a>从回溯到 O(n²) 线性 DP</h3><h4 id="思维起点：子序列-子集的一种"><a href="#思维起点：子序列-子集的一种" class="headerlink" title="思维起点：子序列 &#x3D; 子集的一种"></a>思维起点：子序列 &#x3D; 子集的一种</h4><p>LIS 本质是一个「选或不选」的问题，可以有两种回溯视角：</p>
<ul>
<li><strong>枚举元素选不选</strong><br> → 需要额外维护「上一个选了谁」</li>
<li><strong>枚举答案以谁结尾</strong>（更适合 DP）<br> → 只关心：<em>以 nums[i] 结尾的 LIS 最长是多少</em></li>
</ul>
<h4 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i]：以 nums[i] 结尾的最长严格递增子序列长度</span><br></pre></td></tr></table></figure>

<h4 id="状态转移"><a href="#状态转移" class="headerlink" title="状态转移"></a>状态转移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[j] + 1)  (j &lt; i 且 nums[j] &lt; nums[i])</span><br></pre></td></tr></table></figure>

<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul>
<li>状态数：n</li>
<li>转移代价：n</li>
<li><strong>时间复杂度：O(n²)</strong></li>
</ul>
<p>考虑优化时间复杂度。</p>
<hr>
<h3 id="贪心-二分：从-O-n²-到-O-n-log-n"><a href="#贪心-二分：从-O-n²-到-O-n-log-n" class="headerlink" title="贪心 + 二分：从 O(n²) 到 O(n log n)"></a>贪心 + 二分：从 O(n²) 到 O(n log n)</h3><p>当 n 上到 10⁵ 时，O(n²) 就不够用了，需要进一步优化。</p>
<p>核心技巧只有一句话：</p>
<blockquote>
<p><strong>将 dp 的「状态」和「状态值」进行交</strong></p>
</blockquote>
<h4 id="关键构造：g-数组"><a href="#关键构造：g-数组" class="headerlink" title="关键构造：g 数组"></a>关键构造：<code>g</code> 数组</h4><p>我们不再显式记录「每个位置的 LIS 长度」，而是维护一个数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g[k]：长度为 k+1 的递增子序列，其末尾元素的最小可能值</span><br></pre></td></tr></table></figure>

<p>它有两个重要性质：</p>
<ul>
<li><code>g</code> <strong>始终是单调递增的</strong></li>
<li><code>g.size()</code> 就是当前 LIS 的长度</li>
</ul>
<h4 id="遍历过程（贪心本质）"><a href="#遍历过程（贪心本质）" class="headerlink" title="遍历过程（贪心本质）"></a>遍历过程（贪心本质）</h4><p>对每个元素 <code>x = nums[i]</code>：</p>
<ol>
<li>在 <code>g</code> 中二分查找：<ul>
<li><strong>严格递增 LIS</strong>：找第一个 <code>&gt;= x</code> 的位置</li>
</ul>
</li>
<li>分两种情况：<ul>
<li><strong>找不到</strong>（位置 &#x3D;&#x3D; g.size）<br> → 说明可以扩展长度，<code>g.add(x)</code></li>
<li><strong>找到了</strong><br> → 用 <code>x</code> 替换该位置，<code>g[pos] = x</code></li>
</ul>
</li>
</ol>
<h4 id="为什么可以替换-为什么要替换"><a href="#为什么可以替换-为什么要替换" class="headerlink" title="为什么可以替换+为什么要替换"></a>为什么可以替换+为什么要替换</h4><p>因为：</p>
<ul>
<li>我们只关心 <strong>在固定长度下，末尾元素越小越好</strong></li>
<li>更小的末尾元素，能给后续元素留下更大的扩展空间</li>
</ul>
<p>这就是贪心正确性的核心。</p>
<p><strong>时间复杂度：O(n log n)</strong></p>
<hr>
<h2 id="三、LIS-的“模型迁移”：扩展题统一视角"><a href="#三、LIS-的“模型迁移”：扩展题统一视角" class="headerlink" title="三、LIS 的“模型迁移”：扩展题统一视角"></a>三、LIS 的“模型迁移”：扩展题统一视角</h2><h3 id="2826-将三个组排序"><a href="#2826-将三个组排序" class="headerlink" title="2826. 将三个组排序"></a>2826. 将三个组排序</h3><p><strong>核心转化</strong>：</p>
<ul>
<li>不要求严格递增</li>
<li>只要求 <strong>非递减子序列</strong></li>
</ul>
<p>问题等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最少操作数 = n - 最长非递减子序列长度</span><br></pre></td></tr></table></figure>

<p>实现细节：</p>
<ul>
<li>二分时找 <strong>第一个 &gt; x 的位置</strong></li>
</ul>
<hr>
<h3 id="1964-有效障碍赛跑路线"><a href="#1964-有效障碍赛跑路线" class="headerlink" title="1964. 有效障碍赛跑路线"></a>1964. 有效障碍赛跑路线</h3><p>题目要求的是：</p>
<blockquote>
<p><strong>到每个位置为止的最长非递减子序列长度</strong></p>
</blockquote>
<p>关键点：</p>
<ul>
<li><code>g</code> 数组的维护方式不变</li>
<li>每次插入 &#x2F; 替换后：当前 <code>g.size()</code> 就是答案，因为遍历nums的过程，每个数都对应一次操作。</li>
</ul>
<p>本质是 <strong>LIS 贪心过程的“在线版本”</strong></p>
<hr>
<h3 id="1671-得到山型数组的最少删除次数"><a href="#1671-得到山型数组的最少删除次数" class="headerlink" title="1671. 得到山型数组的最少删除次数"></a>1671. 得到山型数组的最少删除次数</h3><p>标准「山型数组」模型：</p>
<ul>
<li>枚举 <code>i</code> 作为峰顶</li>
<li>左边：<strong>最长严格递增子序列</strong></li>
<li>右边：<strong>最长严格递减子序列</strong></li>
</ul>
<p>处理技巧：</p>
<ul>
<li>右侧「严格递减」<br> → 倒序遍历，等价于再做一次 LIS</li>
</ul>
<p>答案计算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n - (len_left + len_right - 1)</span><br></pre></td></tr></table></figure>

<p>注意边界：</p>
<ul>
<li>峰顶左右必须至少有一个元素 → <code>len_left &gt;= 2 &amp;&amp; len_right &gt;= 2</code></li>
</ul>
<hr>
<h3 id="2111-使数组-K-递增的最少操作次数"><a href="#2111-使数组-K-递增的最少操作次数" class="headerlink" title="2111. 使数组 K 递增的最少操作次数"></a>2111. 使数组 K 递增的最少操作次数</h3><p>核心拆解：</p>
<ol>
<li>按下标 <code>i % k</code> 分成 k 组</li>
<li>每一组 <strong>互不影响</strong></li>
<li>对每一组：<ul>
<li>求最长非递减子序列长度</li>
</ul>
</li>
</ol>
<p>最终答案：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">总长度 - 各组 LNDS 之和</span><br></pre></td></tr></table></figure>

<p>这是一个非常经典的：</p>
<blockquote>
<p><strong>“全局问题 → 独立子问题 → LIS 统一求解”</strong></p>
</blockquote>
<hr>
<h2 id="四、方法论总结"><a href="#四、方法论总结" class="headerlink" title="四、方法论总结"></a>四、方法论总结</h2><h3 id="子序列-最少操作-最长子序列"><a href="#子序列-最少操作-最长子序列" class="headerlink" title="子序列 + 最少操作 &#x3D; 最长子序列"></a>子序列 + 最少操作 &#x3D; 最长子序列</h3><p>只要题目满足：</p>
<ul>
<li>只能删除 &#x2F; 修改</li>
<li>不改变相对顺序</li>
</ul>
<p>几乎都可以转化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最少操作 = n - 最长满足条件的子序列长度</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="严格递增-vs-非递减（二分差异）"><a href="#严格递增-vs-非递减（二分差异）" class="headerlink" title="严格递增 vs 非递减（二分差异）"></a>严格递增 vs 非递减（二分差异）</h3><table>
<thead>
<tr>
<th>子序列类型</th>
<th>二分查找条件</th>
</tr>
</thead>
<tbody><tr>
<td>严格递增 LIS</td>
<td>找第一个 <code>&gt;= x</code></td>
</tr>
<tr>
<td>非递减 LNDS</td>
<td>找第一个 <code>&gt; x</code></td>
</tr>
</tbody></table>
<p>这是 LIS 题中<strong>最容易写错的点</strong></p>
<hr>
<h3 id="为什么-LIS-属于线性-DP"><a href="#为什么-LIS-属于线性-DP" class="headerlink" title="为什么 LIS 属于线性 DP"></a>为什么 LIS 属于线性 DP</h3><ul>
<li>本质仍是 DP</li>
<li>只是通过：<ul>
<li><strong>贪心</strong></li>
<li><strong>有序结构</strong></li>
<li><strong>二分查找</strong></li>
</ul>
</li>
<li>将状态转移从 <code>O(n)</code> 优化成 <code>O(log n)</code></li>
</ul>
<p>这个优化的关键技巧只有一句话：</p>
<blockquote>
<p><strong>交换 dp 的“状态”和“状态值”</strong></p>
</blockquote>
<hr>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><strong>300. 最长递增子序列（LIS）是一个“母题”</strong>：</p>
<ul>
<li><p>它不是一题，而是一整类题型的统一入口</p>
</li>
<li><p>一旦 LIS 的 <strong>O(n²)</strong> 与 <strong>O(n log n)</strong> 两套思路真正吃透：</p>
<ul>
<li><p>山型数组</p>
</li>
<li><p>非递减序列</p>
</li>
<li><p>分组 LIS</p>
</li>
<li><p>最少删除 &#x2F; 修改问题</p>
</li>
</ul>
</li>
</ul>
<p>都可以自然转化、快速识别</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/18/algorithms/dynamicprogramming/2026-1-18-dynamicprogramming-03LIS/" data-id="cmkkn3hbk004rgw8tccwa7fc5" data-title="线性 DP · 最长递增子序列（LIS）专题总结" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LIS/" rel="tag">LIS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7DP/" rel="tag">线性DP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-14-dynamicprogramming-02线性DP" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/15/algorithms/dynamicprogramming/2026-1-14-dynamicprogramming-02%E7%BA%BF%E6%80%A7DP/" class="article-date">
  <time class="dt-published" datetime="2026-01-15T04:30:00.000Z" itemprop="datePublished">2026-01-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/15/algorithms/dynamicprogramming/2026-1-14-dynamicprogramming-02%E7%BA%BF%E6%80%A7DP/">线性 DP：字符串问题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文通过 1143、72、583 三道典型题目，总结出线性 DP 的核心不在于「一维还是二维」，而在于<strong>当前状态只依赖于“更小规模的历史状态”，并且状态推进顺序是线性的</strong>；字符串 DP 与背包 DP 在模型上是统一的，只是状态含义不同。</p>
</blockquote>
<hr>
<h2 id="一、什么是「线性-DP」——不是维度，而是递推方向"><a href="#一、什么是「线性-DP」——不是维度，而是递推方向" class="headerlink" title="一、什么是「线性 DP」——不是维度，而是递推方向"></a>一、什么是「线性 DP」——不是维度，而是递推方向</h2><p>最初我把“线性 DP”理解为<strong>一维数组</strong>，但这其实是结果，不是本质。</p>
<h3 id="1-状态只依赖于“过去”"><a href="#1-状态只依赖于“过去”" class="headerlink" title="1. 状态只依赖于“过去”"></a>1. 状态只依赖于“过去”</h3><ul>
<li><code>dp[i]</code> 或 <code>dp[i][j]</code> <strong>只从更小的 i &#x2F; j 推导</strong></li>
<li>不存在回头依赖、环形依赖</li>
</ul>
<h3 id="2-状态推进顺序是线性的"><a href="#2-状态推进顺序是线性的" class="headerlink" title="2. 状态推进顺序是线性的"></a>2. 状态推进顺序是线性的</h3><ul>
<li>一维：<code>i = 1 → n</code></li>
<li>二维：固定一个维度，另一个维度线性推进<br> （例如先枚举 <code>i</code>，再枚举 <code>j</code>）</li>
</ul>
<h3 id="3-可以被空间优化（但不是必须）"><a href="#3-可以被空间优化（但不是必须）" class="headerlink" title="3. 可以被空间优化（但不是必须）"></a>3. 可以被空间优化（但不是必须）</h3><ul>
<li>如果 <code>dp[i]</code> 只依赖 <code>dp[i-1]</code>，就能压缩</li>
<li>如果 <code>dp[i][j]</code> 只依赖上一行或左侧，也可以压缩</li>
</ul>
<p><strong>是否能压缩 ≠ 是否是线性 DP</strong></p>
<hr>
<h2 id="二、统一视角：字符串-DP-与背包-DP-本质相同"><a href="#二、统一视角：字符串-DP-与背包-DP-本质相同" class="headerlink" title="二、统一视角：字符串 DP 与背包 DP 本质相同"></a>二、统一视角：字符串 DP 与背包 DP 本质相同</h2><table>
<thead>
<tr>
<th>维度</th>
<th>背包问题</th>
<th>字符串问题</th>
</tr>
</thead>
<tbody><tr>
<td>输入</td>
<td>数组</td>
<td>字符串</td>
</tr>
<tr>
<td>状态含义</td>
<td>前 i 个物品</td>
<td>前 i &#x2F; j 个字符</td>
</tr>
<tr>
<td>决策</td>
<td>选 &#x2F; 不选</td>
<td>保留 &#x2F; 删除 &#x2F; 替换</td>
</tr>
<tr>
<td>本质</td>
<td>枚举当前位置的决策</td>
<td>枚举当前位置的操作</td>
</tr>
</tbody></table>
<p><strong>01 背包、完全背包、LCS、编辑距离，本质上都是“位置 + 决策”的线性 DP。</strong></p>
<hr>
<h2 id="三、经典模型一：1143-最长公共子序列（LCS）"><a href="#三、经典模型一：1143-最长公共子序列（LCS）" class="headerlink" title="三、经典模型一：1143 最长公共子序列（LCS）"></a>三、经典模型一：1143 最长公共子序列（LCS）</h2><h3 id="状态定义"><a href="#状态定义" class="headerlink" title="状态定义"></a>状态定义</h3><blockquote>
<p><code>dp[i][j]</code>：<br> <strong>word1 前 i 个字符</strong> 与 <strong>word2 前 j 个字符</strong> 的最长公共子序列长度</p>
</blockquote>
<p>注意：</p>
<ul>
<li>是「前 i 个」，不是「第 i 个」</li>
<li>这是为了让 <code>dp[0][*]</code> 成为合法边界</li>
</ul>
<hr>
<h3 id="决策拆解（从-DFS-到-DP）"><a href="#决策拆解（从-DFS-到-DP）" class="headerlink" title="决策拆解（从 DFS 到 DP）"></a>决策拆解（从 DFS 到 DP）</h3><p>站在回溯角度：</p>
<ul>
<li>当前考察 <code>word1[i-1]</code> 和 <code>word2[j-1]</code></li>
<li>两种情况：<ul>
<li>相等 → 一起加入子序列</li>
<li>不等 → 放弃其中一个</li>
</ul>
</li>
</ul>
<hr>
<h3 id="状态转移（核心）"><a href="#状态转移（核心）" class="headerlink" title="状态转移（核心）"></a>状态转移（核心）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if word1[i-1] == word2[j-1]:</span><br><span class="line">    dp[i][j] = dp[i-1][j-1] + 1</span><br><span class="line">else:</span><br><span class="line">    dp[i][j] = max(dp[i-1][j], dp[i][j-1])</span><br></pre></td></tr></table></figure>

<p><strong>这是一个非常“干净”的线性 DP：</strong></p>
<ul>
<li>依赖方向：左、上、左上</li>
<li>遍历顺序：i 从小到大，j 从小到大</li>
</ul>
<hr>
<h2 id="四、经典模型二：72-编辑距离（Edit-Distance）"><a href="#四、经典模型二：72-编辑距离（Edit-Distance）" class="headerlink" title="四、经典模型二：72 编辑距离（Edit Distance）"></a>四、经典模型二：72 编辑距离（Edit Distance）</h2><h3 id="状态定义-1"><a href="#状态定义-1" class="headerlink" title="状态定义"></a>状态定义</h3><blockquote>
<p><code>dp[i][j]</code>：<br> <strong>word1 前 i 个字符</strong> 转换为 <strong>word2 前 j 个字符</strong> 的最少操作数</p>
</blockquote>
<hr>
<h3 id="为什么它和-LCS-是同一类问题？"><a href="#为什么它和-LCS-是同一类问题？" class="headerlink" title="为什么它和 LCS 是同一类问题？"></a>为什么它和 LCS 是同一类问题？</h3><p>可以从“操作视角”统一理解：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>对应状态变化</th>
</tr>
</thead>
<tbody><tr>
<td>删除 word1[i-1]</td>
<td><code>dp[i-1][j] + 1</code></td>
</tr>
<tr>
<td>插入的字符与 word2[j] 相同，所以递归到 word2[j-1]</td>
<td><code>dp[i][j-1] + 1</code></td>
</tr>
<tr>
<td>替换 &#x2F; 保留</td>
<td><code>dp[i-1][j-1] + cost</code></td>
</tr>
</tbody></table>
<p>其中：</p>
<ul>
<li><code>cost = 0</code>（字符相等）</li>
<li><code>cost = 1</code>（字符不等）</li>
</ul>
<hr>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if word1[i-1] == word2[j-1]:</span><br><span class="line">    dp[i][j] = dp[i-1][j-1]</span><br><span class="line">else:</span><br><span class="line">    dp[i][j] = min(</span><br><span class="line">        dp[i-1][j],     // 删除</span><br><span class="line">        dp[i][j-1],     // 插入</span><br><span class="line">        dp[i-1][j-1]    // 替换</span><br><span class="line">    ) + 1</span><br></pre></td></tr></table></figure>

<p>和 LCS 的区别不在于 DP 框架，而在于：</p>
<ul>
<li><strong>相等时是否“奖励 +1”</strong></li>
<li><strong>不等时是取 max 还是 min</strong></li>
</ul>
<hr>
<h2 id="五、模型变形：583-两个字符串的删除操作"><a href="#五、模型变形：583-两个字符串的删除操作" class="headerlink" title="五、模型变形：583 两个字符串的删除操作"></a>五、模型变形：583 两个字符串的删除操作</h2><blockquote>
<p>这道题是 <strong>编辑距离的特例</strong>：</p>
<ul>
<li>只能删除</li>
<li>允许对两个字符串都删除</li>
</ul>
</blockquote>
<hr>
<h3 id="两种等价解法（体现思维深度）"><a href="#两种等价解法（体现思维深度）" class="headerlink" title="两种等价解法（体现思维深度）"></a>两种等价解法（体现思维深度）</h3><h4 id="解法一：直接-DP（编辑距离删减版）"><a href="#解法一：直接-DP（编辑距离删减版）" class="headerlink" title="解法一：直接 DP（编辑距离删减版）"></a>解法一：直接 DP（编辑距离删减版）</h4><ul>
<li>只保留「删除」相关转移</li>
<li>不允许插入和替换</li>
</ul>
<h4 id="解法二：LCS-转化（更优雅）"><a href="#解法二：LCS-转化（更优雅）" class="headerlink" title="解法二：LCS 转化（更优雅）"></a>解法二：LCS 转化（更优雅）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最少删除次数 =</span><br><span class="line">    len(word1) + len(word2) - 2 * LCS(word1, word2)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、字符串-DP-vs-背包-DP：本质对比总结"><a href="#六、字符串-DP-vs-背包-DP：本质对比总结" class="headerlink" title="六、字符串 DP vs 背包 DP：本质对比总结"></a>六、字符串 DP vs 背包 DP：本质对比总结</h2><table>
<thead>
<tr>
<th>维度</th>
<th>背包</th>
<th>字符串 DP</th>
</tr>
</thead>
<tbody><tr>
<td>状态</td>
<td><code>dp[i][j] </code></td>
<td><code>dp[i][j] </code></td>
</tr>
<tr>
<td>i 的含义</td>
<td>前 i 个物品</td>
<td>前 i 个字符</td>
</tr>
<tr>
<td>j 的含义</td>
<td>容量 &#x2F; 价值</td>
<td>另一个字符串长度</td>
</tr>
<tr>
<td>决策</td>
<td>选 &#x2F; 不选</td>
<td>删除 &#x2F; 插入 &#x2F; 替换</td>
</tr>
<tr>
<td>共同点</td>
<td>线性推进、局部最优构成全局最优</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><ul>
<li>线性 DP 的核心是 <strong>“状态规模单调变小 + 线性遍历顺序”</strong></li>
<li>LCS、编辑距离、字符串删除问题 <strong>本质是一套 DP 模型</strong></li>
<li>能从 DFS → 状态定义 → 转移方程 → 空间优化，是完整 DP 能力的体现</li>
<li><strong>理解状态含义，比记公式重要得多</strong></li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/15/algorithms/dynamicprogramming/2026-1-14-dynamicprogramming-02%E7%BA%BF%E6%80%A7DP/" data-id="cmkkn3hbj004pgw8tetp34c08" data-title="线性 DP：字符串问题" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7DP/" rel="tag">线性DP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-misc/git-开发工具整理总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/14/misc/git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2026-01-14T06:20:00.000Z" itemprop="datePublished">2026-01-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/14/misc/git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/">git 开发工具整理总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文是在学习过程中，零星对 git 的学习的总结与汇总。</p>
</blockquote>
<h2 id="什么是-Git"><a href="#什么是-Git" class="headerlink" title="什么是 Git"></a>什么是 Git</h2><p>git 是基于 c 语言的分布式版本控制系统，与之对应的是集中式版本控制系统。这两者的不同：</p>
<ul>
<li>集中式版本控制系统：版本库存放在中央服务器，必须联网才能从中央服务器拉取最新版本，推送新版本到中央服务器。</li>
<li>分布式版本控制系统：没有中央服务器，每个人的电脑都有一个完整的版本库。多人协作的实现是通过将各自修改的内容推送给对方。实际应用中，通常用一台电脑充当“中央服务器”，这个服务器只用来交换大家的修改信息，不存放版本库。</li>
</ul>
<p>git 的优势不单单是不必联网，还有强大的分支管理</p>
<hr>
<h2 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h2><p>版本库又名仓库（Repository），可以理解为一个目录，这个目录中的所有文件受 git 管理，每个文件的增删改，git 都能跟踪，以便根据需求还原。</p>
<p>创建版本库非常简单，在需要交给 git 管理的目录下，执行 <code>git init</code> 命令即可。</p>
<blockquote>
<p>需要注意的是，目录名尽量不要包含中文。</p>
</blockquote>
<p>所有的版本控制系统，其实都只是跟踪文本文件的改动，例如 txt 文件、程序代码等等，不能监控图片、视频这种二进制文件（只能监控大小的改变，内容的改变不能监控）。</p>
<h3 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h3><p>在 git 管理的目录下，通过 <code>git add &lt;filename&gt;</code> 添加文件到版本库，再通过 <code>git commit -m &quot;msg&quot;</code> 命令把文件提交到仓库。<code>git status</code> 命令可以查看仓库当前状态，会提示修改过的文件，以及准备提交的文件（add 的文件）。<code>git diff</code> 命令可以对比文件哪些地方变化了。</p>
<p>注意添加和提交是两个操作。</p>
<h3 id="小结（目前最常用命令）"><a href="#小结（目前最常用命令）" class="headerlink" title="小结（目前最常用命令）"></a>小结（目前最常用命令）</h3><ul>
<li><code>git init</code>：将当前目录交给 git 管理</li>
<li><code>git add &lt;filename&gt;</code>：将指定文件添加到版本库中</li>
<li><code>git commit -m &quot;msg&quot;</code>：提交本次修改，msg 是对本次提交的说明</li>
<li><code>git status</code>：查看仓库当前状态，哪些文件被修改了，哪些文件添加到版本库中但是还没有提交</li>
<li><code>git diff</code>：查看文件修改内容</li>
</ul>
<hr>
<h2 id="时光穿梭"><a href="#时光穿梭" class="headerlink" title="时光穿梭"></a>时光穿梭</h2><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>同一仓库，经过多次提交后，难免记不清哪个版本修改了什么内容，所以在进行版本回退前，可以通过 <code>git log</code> 命令查看历史记录，可以看到包含了每次提交的 commit id：364… 以及谁提交的，以及日期和每次提交的说明。</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/1.png" alt="1"></p>
<p>此外，我们还需要当前版本的信息，head 指向的就是当前版本，然后就可以定位需要回退的版本，通过 <code>git reset</code> 命令进行回退</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure>

<p>^ 表示上个版本，多个版本可用 <del>， HEAD</del>100 表示回退 100  个版本。</p>
<p>–hard 参数表示回退上个版本的已提交状态，–soft 表示回退到上个版本的未提交状态，–mixed 回到上个版本已添加但是为提交的状态。</p>
<p>也可以通过 <code>git reset --hard f35ed</code> 回退到具体版本，或者穿梭到未来的版本，注意这里 commit id 不用写全，只要让 git 能够找到唯一的版本即可。<code>git reflog</code> 命令显示 git 记录的每一次命令，通过这个可用查看版本号。</p>
<blockquote>
<p>git 的版本回退速度非常快，因为 git 内部有个指向当前版本的 HEAD 指针，回退版本时，仅仅是将 HEAD 指向指定版本</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li><code>git reset --hard HEAD^/指定版本号</code>：回退到当前版本的上个版本或回退到指定版本号的版本</li>
<li><code>git log</code> 与 <code>git reflog</code> ：命令查看历史记录，来找到需要回退的版本或版本号</li>
</ul>
<h3 id="工作区与暂存区"><a href="#工作区与暂存区" class="headerlink" title="工作区与暂存区"></a>工作区与暂存区</h3><p>工作区，就是电脑中实际操作的目录。</p>
<p>版本库，是工作区中的隐藏目录 .git，其中存储 git 进行版本控制的很多信息，最重要的就是暂存区（stage）和 git 自动创建的 master 分支，以及指向 master 分支的 HEAD 指针。</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/2.png" alt="2"></p>
<ul>
<li><code>git add</code> 就是将<strong>文件修改</strong>添加到暂存区</li>
<li><code>git commit</code> 就是将暂存区的所有内容添加到当前分支</li>
</ul>
<blockquote>
<p>可以理解为：需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
</blockquote>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>git 管理的是对文件的修改而非文件，怎么理解？例如，在文件中新增一个 ‘a’ 字符，然后 <code>git add</code> 后又将字符改为了 ‘b’，暂存区中只知道你将新增了一个字符 ‘a’，而不知道它改为了 ‘b’，这是一个很好的证明 git 管理的是修改而非文件本身。</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>撤销修改有三种情形：</p>
<ul>
<li><p>只是对工作区进行了修改，还没有 add 与 commit：直接通过 <code>git restore &lt;file&gt;</code> 撤销修改</p>
</li>
<li><p>对工作区的修改，添加到了暂存区：通过 <code>git restore --staged &lt;file&gt;</code> 命令将文件从暂存区删除，然后通过  <code>git restore &lt;file&gt;</code> 撤销修改。 </p>
</li>
<li><p>对工作区的修改不仅添加到了缓存区，还提交到了分支当中：<code>git reset HEAD^</code> 进行版本回退。</p>
</li>
</ul>
<blockquote>
<p>git checkout –filename 命令是让文件回到最近一次 add 或 commit 时的状态</p>
</blockquote>
<h3 id="文件的删除"><a href="#文件的删除" class="headerlink" title="文件的删除"></a>文件的删除</h3><p>仓库中的文件的删除也是一次修改操作，git 会记录下来。如果想在 git 仓库中也实现文件的永久删除，可以用 <code>git rm filename</code> 命令，也可以用 <code>git add filename</code> 将这次修改提交到暂存区，然后再提交。</p>
<p>如果要撤销这次删除操作，只需要用到上一节介绍的 <code>git checkout --filename</code> 命令</p>
<blockquote>
<p>这里需要注意的就是：没有被添加到仓库中的文件，git 是无法控制的</p>
</blockquote>
<hr>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>以上的功能，集中版本控制系统也能做到。真正体现 git 优势的是远程仓库，简单来说，就是将本地仓库托管到服务器上每天 24 小时开机，也可以从服务器中拉取别人的仓库，还能将提交推送到服务器上。</p>
<p>GitHub 就是提供 Git 仓库托管服务的，你需要告诉远程仓库你的身份信息，谁都可以修改你的远程仓库。本地Git仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以需要先设置 SSH 密钥。</p>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>在 github 上创建好远程仓库后，需要将它与本地仓库关联：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:tingfeng-worK/project.git</span><br></pre></td></tr></table></figure>

<p>如果没有设置 SSH 密钥这一步，本地推送就推送不到远程仓库，相当于没有登录。命令中的 origin 是默认的远程仓库名，将本地仓库的内容推送到远程仓库，用命令 <code>git push</code>，实际上是将当前分支 master 推送到远程库，第一次推送时需要加上 <code>-u</code> 参数，它表示 git 不但会把本地的 master 分支推送到远程库中新的 master 分支，还会将它们关联起来，以后推送或拉取时就可以简化命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>上述添加远程库是将本地已有的仓库添加并关联到远程仓库，而将远程仓库拉取到本地用到的 git 命令是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:tingfeng-worK/project.git <span class="comment"># ssh 协议</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/tingfeng-work/project.git <span class="comment"># https 协议</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Git 支持多协议，可以使用 https，但是使用 ssh 最快</p>
</blockquote>
<hr>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>Git 的分支管理是它的优势之一，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
<p>分支管理就好比在一个项目中，你与队友并行在不同的分支上开发不同的功能，在这个分支上你想提交就提交，不会影响主分支，在功能完成后，将分支合并到主分支上，项目就同时具备了你俩开发的功能。</p>
<h3 id="分支的创建与合并"><a href="#分支的创建与合并" class="headerlink" title="分支的创建与合并"></a>分支的创建与合并</h3><p>每次提交，git 都会 将它们串联为一条时间线，这个时间线就是一个分支，目前为止用到的都是 git 默认为我们常见的主分支 master，HEAD 严格来说不是指向提交，而是指向 master，而 master 指向每一次提交，如图所示：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/3.png" alt="3"></p>
<p>每次提交，master 分支都会向前移动一次，HEAD 指针也随之移动。</p>
<p>当我们创建新的分支 dev 时，相当于创建了一个新的时间线，Git 会创建一个 dev 指针，指向 master 相同的提交，再把 HEAD 指向 dev，就表示当前分支在 dev 上：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/4.png" alt="4"></p>
<p>这也解释了为什么 git 新建分支很快，它只是新建了一个指针，同时更改了 HEAD 的指向。现在对工作区的修改提交之后，就是 dev 指针移动，而 master 指针不变了：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/5.png" alt="5"></p>
<p>在<code>dev</code>上的工作完成后，就可以把<code>dev</code>合并到<code>master</code>上。这种单时间线的合并最简单，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并。相关指令：</p>
<ul>
<li><code>git branch</code>：查看有哪些分支</li>
<li><code>git branch &lt;name&gt;</code> ：新建分支</li>
<li><code>git checkout &lt;name&gt;</code> 或 <code>git switch &lt;name&gt;</code>：切换分支</li>
<li><code>git checkout -b &lt;name&gt;</code> 或 <code>git switch -c &lt;name&gt;</code>：创建并切换到新建的分支</li>
<li><code>git merger &lt;name&gt;</code>：合并某分支到当前分支</li>
<li><code>git branch -d &lt;name&gt;</code>：删除分支</li>
</ul>
<h3 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h3><p>上面描述最简单的单时间线的分支合并，考虑合并两个时间线的分支，这种情况下，git 无法执行快速合并，只能试着把各自的修改合并起来：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/6.png" alt="6"></p>
<p>但是，这种合并可能会有冲突，假设这两次提交针对文件的同一地方进行了修改，合并分支时就会产生冲突，这也很好理解，git 不知道到底要怎么修改，所以必须手动解决冲突后再提交，也就是明确告诉 git 要怎么改。手动解决后，再合并就会变为：</p>
<p><img src="D:/develop/tingfeng-work.github.io/source/_posts/misc/assets/7.png" alt="7"></p>
<p>可以看到这种合并会创建一次新的提交，这也很好理解，因为这是对文件的一次修改。</p>
<ul>
<li><code>git log --graph --pretty=oneline --abbrev-commit</code>：可以看到分支合并情况。</li>
</ul>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><ul>
<li>从远程仓库拉取分支进行本地修改</li>
<li>修改后从本地推送分支，如果推送失败，说明远程仓库中已经有人对操作 1 中拉取的分支进行了修改，并提交到远程仓库了，这时需要需要进行合并。</li>
<li>如果合并失败，就在本地解决冲突，然后再提交。</li>
</ul>
<p>这个过程会用到的指令：</p>
<ul>
<li><p><code>git remote -v</code>：查看远程仓库信息</p>
</li>
<li><p><code>git pull</code>：拉取并合并远程基于当前分支的提交，这个命令执行的前提是远程仓库上的分支与当前分支建立了联系。</p>
</li>
<li><p><code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>：将远程仓库中的分支与本地分支建立联系</p>
</li>
<li><p><code>git push origin &lt;branch-name&gt;</code>：从本地推送分支到远程仓库</p>
</li>
<li><p><code>git checkout -b branch-name origin/branch-name</code></p>
</li>
</ul>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>将本地未 push 的分叉提交历史整理为一条分支（一条直线）</p>
<hr>
<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><p>标签就相当于一个有名字的不会动的指针，指向某一个 commit，方便进行版本控制。如果没有标签，想要跳转到指定的版本，需要通过 git log 找 commit 的 id，而且 id 还很长，所以标签就起到了快速找到指定版本的作用。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>切换到需要打标签的提交，通过 <code>git tag &lt;name&gt;</code>，就实现打标签了，也可以指定 commit id 的方式打标签，同时指定 <code>git tag -a &lt;name&gt; -m &quot;msg&quot;</code> 参数可以对创建标签进行说明。<code>git tag</code> 查看所有标签，<code>git show &lt;tagname&gt;</code>查看指定标签。</p>
<blockquote>
<p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
</blockquote>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><ul>
<li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li>
<li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li>
<li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li>
<li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li>
</ul>
<hr>
<h2 id="GitHub-开源项目"><a href="#GitHub-开源项目" class="headerlink" title="GitHub 开源项目"></a>GitHub 开源项目</h2><p>在 GitHub 上，利用 Git 强大的克隆和分支功能，可以实现自由参与各种开源项目了。</p>
<p>对于开源项目，先 fork 到自己的远程仓库，再从自己的远程仓库中克隆到本地仓库。对本地仓库的修改，再提交到自己的远程仓库，如果希望自己的修改被项目方接受，需要在 GitHub 上发起 pull request，最终取决于对方是否接受。</p>
<hr>
<h2 id="学习-Git-的网站"><a href="#学习-Git-的网站" class="headerlink" title="学习 Git 的网站"></a>学习 Git 的网站</h2><p><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/?locale=zh_CN">https://learngitbranching.js.org/?locale=zh_CN</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/14/misc/git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/" data-id="cmkkn3hae0001gw8t9tw8bjs9" data-title="git 开发工具整理总结" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01背包与完全背包模型" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/13/algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="dt-published" datetime="2026-01-13T04:30:00.000Z" itemprop="datePublished">2026-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/13/algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/">DP 模型：从回溯语义到 0-1 背包与完全背包（2026-01-13）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文通过 494、322、2915 三道典型题目，总结 <strong>0-1 背包与完全背包的统一建模方式</strong>。重点在于<strong>如何从回溯语义自然推导出动态规划模型</strong>。</p>
</blockquote>
<p><strong>基础题目</strong>：01背包、完全背包</p>
<p><strong>01背包变形</strong>：</p>
<p>494.目标和、2915.和为目标值的最长子序列的长度</p>
<p><strong>完全背包变形</strong>：</p>
<p>322.零钱兑换</p>
<hr>
<h2 id="一、为什么要从“回溯语义”入手理解-DP？"><a href="#一、为什么要从“回溯语义”入手理解-DP？" class="headerlink" title="一、为什么要从“回溯语义”入手理解 DP？"></a>一、为什么要从“回溯语义”入手理解 DP？</h2><p>在学习动态规划的过程中，我一度陷入这样的问题：</p>
<ul>
<li>明明知道这是 DP 题</li>
<li>但一到写 <code>dp[i][j]</code> 就容易：<ul>
<li>不知道从何下手</li>
<li>理解错误状态含义</li>
<li>写错初始化</li>
</ul>
</li>
</ul>
<p>后来我解题循序渐进旨在加深对回溯与DP的理解：</p>
<blockquote>
<p><strong>所有 DP 题，先用 <code>dfs(i, j)</code> 把“语义”想清楚，再翻译成 DP。</strong></p>
</blockquote>
<p>这篇博客正是围绕这一方法，总结 <strong>0-1 背包与完全背包</strong> 这两类最常见的 DP 模型。</p>
<hr>
<h2 id="二、统一视角：什么是“背包模型”？"><a href="#二、统一视角：什么是“背包模型”？" class="headerlink" title="二、统一视角：什么是“背包模型”？"></a>二、统一视角：什么是“背包模型”？</h2><p>从抽象层面看，背包问题的本质只有一句话：</p>
<blockquote>
<p><strong>枚举每个输入元素，决定“选或不选”，并维护一个容量约束。</strong></p>
</blockquote>
<h3 id="0-1-背包模型"><a href="#0-1-背包模型" class="headerlink" title="0-1 背包模型"></a>0-1 背包模型</h3><p><strong>问题描述</strong></p>
<ul>
<li>有 <code>n</code> 个物品</li>
<li>第 <code>i</code> 个物品体积 <code>w[i]</code>，价值 <code>v[i]</code></li>
<li>每个物品最多选一次</li>
<li>在容量 <code>capacity</code> 内，求最大价值和</li>
</ul>
<h3 id="回溯语义三问（非常重要）"><a href="#回溯语义三问（非常重要）" class="headerlink" title="回溯语义三问（非常重要）"></a>回溯语义三问（非常重要）</h3><ul>
<li>当前操作：枚举第 i 个物品选或不选：不选，剩余容量不变；选，容量减少 w[i]</li>
<li>子问题：剩余容量为 c 时，前 i 个物品中的最大价值和</li>
<li>下一个子问题：分类讨论：<ul>
<li>当前操作不选：剩余容量 c 从前 i-1 个物品中得到的最大价值</li>
<li>当前操作选：剩余容量 c - w[i] 从前 i-1 个物品得到的最大价值</li>
</ul>
</li>
</ul>
<h3 id="回溯表达式"><a href="#回溯表达式" class="headerlink" title="回溯表达式"></a>回溯表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int dfs(int i, int c, int[] w, int[] v) &#123;</span><br><span class="line">    if (i &lt; 0) return 0;</span><br><span class="line">    if (w[i] &gt; c) &#123;</span><br><span class="line">        return dfs(i - 1, c, w, v);</span><br><span class="line">    &#125;</span><br><span class="line">    return Math.max(</span><br><span class="line">        dfs(i - 1, c, w, v),                 // 不选</span><br><span class="line">        dfs(i - 1, c - w[i], w, v) + v[i]    // 选</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>一旦写出这段递归，DP 就已经成功了一半。</strong></p>
<hr>
<h3 id="完全背包模型"><a href="#完全背包模型" class="headerlink" title="完全背包模型"></a>完全背包模型</h3><p>完全背包与 0-1 背包只有一个本质区别：</p>
<blockquote>
<p><strong>当前物品是否允许在同一层决策中被再次使用</strong></p>
</blockquote>
<h4 id="回溯表达式-1"><a href="#回溯表达式-1" class="headerlink" title="回溯表达式"></a>回溯表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dfs(i, c) = max(</span><br><span class="line">    dfs(i - 1, c),          // 不选</span><br><span class="line">    dfs(i, c - w[i]) + v[i] // 选，并且还能继续选 i</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="一个非常容易困惑的问题"><a href="#一个非常容易困惑的问题" class="headerlink" title="一个非常容易困惑的问题"></a>一个非常容易困惑的问题</h4><blockquote>
<p>为什么不需要写 <code>dfs(i - 1, c - w[i])</code>？即选了一次后不在选了</p>
</blockquote>
<p>原因在于：</p>
<ul>
<li><code>dfs(i, c - w[i])</code> 中，下一层仍然可以选择“不选”，自然会递归到 <code>dfs(i - 1, c - w[i])</code></li>
</ul>
<p>也就是说：</p>
<blockquote>
<p><strong>“选一次就不再选”这个语义，已经被递归本身隐式表达了。</strong></p>
</blockquote>
<p>这是我在完全背包中收获最大的一个认知点。</p>
<hr>
<h2 id="三、常见背包问题的分类方式"><a href="#三、常见背包问题的分类方式" class="headerlink" title="三、常见背包问题的分类方式"></a>三、常见背包问题的分类方式</h2><p>在做题时，我会优先判断两个维度：</p>
<h3 id="1-装不装满？"><a href="#1-装不装满？" class="headerlink" title="1. 装不装满？"></a>1. 装不装满？</h3><ul>
<li><strong>至多装 capacity</strong></li>
<li><strong>恰好装 capacity</strong></li>
<li><strong>至少装 capacity</strong></li>
</ul>
<h3 id="2-求什么？"><a href="#2-求什么？" class="headerlink" title="2. 求什么？"></a>2. 求什么？</h3><ul>
<li>方案数</li>
<li>最大价值</li>
<li>最小价值</li>
</ul>
<blockquote>
<p>大部分 LeetCode 背包题，都可以被放入这个二维分类表中。</p>
</blockquote>
<hr>
<h2 id="四、结合具体题目分析"><a href="#四、结合具体题目分析" class="headerlink" title="四、结合具体题目分析"></a>四、结合具体题目分析</h2><h3 id="494-目标和-——-0-1-背包（恰好装满，求方案数）"><a href="#494-目标和-——-0-1-背包（恰好装满，求方案数）" class="headerlink" title="494. 目标和 —— 0-1 背包（恰好装满，求方案数）"></a>494. 目标和 —— 0-1 背包（恰好装满，求方案数）</h3><h4 id="建模思路"><a href="#建模思路" class="headerlink" title="建模思路"></a>建模思路</h4><ul>
<li>每个数只能用一次 → <strong>0-1 背包</strong></li>
<li>每个数选或不选 → 枚举符号</li>
<li>本质是：<strong>恰好凑出 target 的方案数</strong></li>
</ul>
<h4 id="回溯语义"><a href="#回溯语义" class="headerlink" title="回溯语义"></a>回溯语义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i, t)：使用前 i 个数，凑出和为 t 的方案数</span><br></pre></td></tr></table></figure>

<h4 id="转移关系"><a href="#转移关系" class="headerlink" title="转移关系"></a>转移关系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dfs(i, t) = dfs(i - 1, t)           // 不选 nums[i]</span><br><span class="line">          + dfs(i - 1, t - nums[i]) // 选 nums[i]</span><br></pre></td></tr></table></figure>

<p>在实现时，我采用了：</p>
<ol>
<li>回溯 + 记忆化搜索</li>
<li>翻译为二维 DP</li>
<li>再做空间优化</li>
</ol>
<blockquote>
<p>这道题让我深刻体会到：<br> <strong><code>dp[i][j]</code> 的含义，必须和 dfs(i, j) 的返回值一一对应。</strong></p>
</blockquote>
<hr>
<h3 id="322-零钱兑换-——-完全背包（恰好装满，求最小价值）"><a href="#322-零钱兑换-——-完全背包（恰好装满，求最小价值）" class="headerlink" title="322. 零钱兑换 —— 完全背包（恰好装满，求最小价值）"></a>322. 零钱兑换 —— 完全背包（恰好装满，求最小价值）</h3><h4 id="模型映射"><a href="#模型映射" class="headerlink" title="模型映射"></a>模型映射</h4><table>
<thead>
<tr>
<th>零钱兑换</th>
<th>背包模型</th>
</tr>
</thead>
<tbody><tr>
<td>amount</td>
<td>capacity</td>
</tr>
<tr>
<td>coin 面值</td>
<td>物品体积</td>
</tr>
<tr>
<td>使用枚数</td>
<td>价值（每次 +1）</td>
</tr>
</tbody></table>
<h4 id="为什么是完全背包？"><a href="#为什么是完全背包？" class="headerlink" title="为什么是完全背包？"></a>为什么是完全背包？</h4><p>因为：<strong>同一种硬币，在同一轮决策中可以被重复使用</strong></p>
<h4 id="转移方程（核心）——-经过回溯、空间优化的结果"><a href="#转移方程（核心）——-经过回溯、空间优化的结果" class="headerlink" title="转移方程（核心）—— 经过回溯、空间优化的结果"></a>转移方程（核心）—— 经过回溯、空间优化的结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = min(</span><br><span class="line">    dp[j],              // 不使用当前硬币</span><br><span class="line">    dp[j - coin] + 1    // 使用一次当前硬币</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2915-和为目标值的最长子序列-——-0-1-背包（恰好装满，求最大价值）"><a href="#2915-和为目标值的最长子序列-——-0-1-背包（恰好装满，求最大价值）" class="headerlink" title="2915. 和为目标值的最长子序列 —— 0-1 背包（恰好装满，求最大价值）"></a>2915. 和为目标值的最长子序列 —— 0-1 背包（恰好装满，求最大价值）</h3><h4 id="抽象方式"><a href="#抽象方式" class="headerlink" title="抽象方式"></a>抽象方式</h4><ul>
<li>每个元素只能选一次 → <strong>0-1 背包</strong></li>
<li>nums[i] 作为“体积”</li>
<li>每选一个元素，价值 +1</li>
</ul>
<h4 id="语义定义"><a href="#语义定义" class="headerlink" title="语义定义"></a>语义定义</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j]：和为 j 时，能得到的最大长度</span><br></pre></td></tr></table></figure>

<p>这道题让我意识到：</p>
<blockquote>
<p><strong>“价值”不一定是题目直接给的，而可以从题目中转化。</strong></p>
</blockquote>
<hr>
<h2 id="五、空间优化：理解即可，不必强求"><a href="#五、空间优化：理解即可，不必强求" class="headerlink" title="五、空间优化：理解即可，不必强求"></a>五、空间优化：理解即可，不必强求</h2><p>在这三道题中，状态转移均只依赖于：</p>
<ul>
<li>上一层 <code>i - 1</code></li>
<li>或当前层更小的 <code>j</code></li>
</ul>
<p>因此可以：</p>
<ol>
<li><code>dp[n][target] → dp[2][target]</code></li>
<li>再进一步压缩为一维数组</li>
</ol>
<p>但我目前的态度是：</p>
<blockquote>
<p><strong>空间优化属于锦上添花，优先保证语义正确。</strong></p>
</blockquote>
<p>如果一维 DP 的依赖方向一时想不清楚，我会选择保留二维。</p>
<hr>
<h2 id="六、总结与反思"><a href="#六、总结与反思" class="headerlink" title="六、总结与反思"></a>六、总结与反思</h2><p>通过这几道题，我对动态规划的理解有了一个明显转变：</p>
<ul>
<li>DP 的核心不在公式</li>
<li>而在 <strong>状态含义 + 转移语义</strong></li>
</ul>
<p>我目前仍然习惯：<strong>先写 dfs(i, j)，再翻译成 dp</strong></p>
<p>但我也希望，随着练习的增多，能够逐渐做到：</p>
<ul>
<li>直接从问题 → 状态定义 → 转移方程</li>
<li>减少对回溯的依赖</li>
</ul>
<p>这是我接下来刻意训练的方向。</p>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/13/algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/" data-id="cmkkn3hbi004ogw8tgey9g6uo" data-title="DP 模型：从回溯语义到 0-1 背包与完全背包（2026-01-13）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/01%E8%83%8C%E5%8C%85/" rel="tag">01背包</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" rel="tag">完全背包</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/project/2026-1-13-project-day01" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/13/backend/project/2026-1-13-project-day01/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T16:00:00.000Z" itemprop="datePublished">2026-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/13/backend/project/2026-1-13-project-day01/">项目结构搭建：从系统结构图到多模块 Maven 项目设计</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文记录了我在餐饮管理系统项目中，从系统结构图设计到多模块 Maven 项目搭建的完整思考过程。</p>
</blockquote>
<hr>
<h2 id="一、从产品原型到系统结构图"><a href="#一、从产品原型到系统结构图" class="headerlink" title="一、从产品原型到系统结构图"></a>一、从产品原型到系统结构图</h2><p>在项目初期，我根据产品原型首先尝试绘制系统结构图，用于梳理系统的整体模块划分。</p>
<h3 id="初版结构图的问题"><a href="#初版结构图的问题" class="headerlink" title="初版结构图的问题"></a>初版结构图的问题</h3><p>最初绘制的结构图中，各个模块是<strong>平级关系</strong>，主要关注功能划分，而忽略了：</p>
<ul>
<li>模块之间的 <strong>层级关系</strong></li>
<li>模块之间的 <strong>依赖方向</strong></li>
<li>不同模块在工程中的 <strong>关注重点</strong></li>
</ul>
<p>在这一阶段，我逐渐意识到：<br> <strong>系统结构图不只是“模块列表”，而是模块间关系的表达。</strong></p>
<hr>
<h3 id="结构图的逐步演进"><a href="#结构图的逐步演进" class="headerlink" title="结构图的逐步演进"></a>结构图的逐步演进</h3><p>在不断调整后，我对结构图提出了更明确的目标：</p>
<ul>
<li>能体现 <strong>调用层级</strong></li>
<li>能反映 <strong>依赖方向</strong></li>
<li>能提示 <strong>开发过程中的关键关注点</strong>（如高并发、事务敏感、高频读等）</li>
</ul>
<p>在这一原则下，结构图经历了多次迭代，最终形成了第三版系统结构图，用于指导后续的工程搭建。</p>
<hr>
<h2 id="二、从系统结构图到项目模块规划"><a href="#二、从系统结构图到项目模块规划" class="headerlink" title="二、从系统结构图到项目模块规划"></a>二、从系统结构图到项目模块规划</h2><p>基于最终的系统结构图，我开始尝试将设计落地为实际的项目结构。</p>
<h3 id="初始拆分思路"><a href="#初始拆分思路" class="headerlink" title="初始拆分思路"></a>初始拆分思路</h3><p>最初的出发点是：</p>
<ul>
<li>结构清晰</li>
<li>各层职责独立</li>
</ul>
<p>因此，我按照经典的三层架构，将项目拆分为三个 Maven Module：</p>
<ul>
<li>controller</li>
<li>service</li>
<li>dao</li>
</ul>
<p>从“概念理解”的角度看，这样的拆分似乎是合理的。</p>
<hr>
<h2 id="三、对照教学案例后的关键反思"><a href="#三、对照教学案例后的关键反思" class="headerlink" title="三、对照教学案例后的关键反思"></a>三、对照教学案例后的关键反思</h2><p>在对照教学案例（如 sky-take-out）后，我发现一个非常明显的差异：</p>
<h3 id="教学案例的模块划分方式"><a href="#教学案例的模块划分方式" class="headerlink" title="教学案例的模块划分方式"></a>教学案例的模块划分方式</h3><p>案例项目并 <strong>没有</strong> 将 controller &#x2F; service &#x2F; dao 拆分为独立 Maven Module，而是采用了：</p>
<ul>
<li><strong>pojo</strong>：实体类与数据模型模块</li>
<li><strong>common</strong>：通用常量、工具类、公共定义</li>
<li><strong>server</strong>：业务模块（包含 controller &#x2F; service &#x2F; mapper）</li>
</ul>
<p>并且：<strong>所有模块由一个 parent pom 统一管理</strong></p>
<hr>
<h3 id="我的拆分方式存在的问题"><a href="#我的拆分方式存在的问题" class="headerlink" title="我的拆分方式存在的问题"></a>我的拆分方式存在的问题</h3><p>对比之后，我逐渐意识到自己最初的设计存在以下隐患：</p>
<ol>
<li>controller &#x2F; service &#x2F; dao <strong>强耦合、同步演进</strong></li>
<li>业务变化频繁，模块边界不稳定</li>
<li>缺少统一的实体与通用模块<ul>
<li>实体类、常量、工具类被迫分散在不同模块</li>
<li>不可避免地出现模块间交叉 import</li>
</ul>
</li>
<li>结构复杂，但并未带来工程收益</li>
</ol>
<p><strong>最终结果很可能是：模块越拆越乱。</strong></p>
<hr>
<h2 id="四、什么该拆-Module，什么不该拆"><a href="#四、什么该拆-Module，什么不该拆" class="headerlink" title="四、什么该拆 Module，什么不该拆"></a>四、什么该拆 Module，什么不该拆</h2><h3 id="Maven-Module-≠-逻辑分层"><a href="#Maven-Module-≠-逻辑分层" class="headerlink" title="Maven Module ≠ 逻辑分层"></a>Maven Module ≠ 逻辑分层</h3><p>在这一阶段，我对 Maven Module 的角色有了更清晰的认识：</p>
<blockquote>
<p><strong>Maven Module 的拆分依据不是 MVC 分层，而是工程属性。</strong></p>
</blockquote>
<p>更合理的判断标准是：</p>
<ul>
<li><strong>稳定性</strong>：是否长期稳定、不易变化</li>
<li><strong>复用性</strong>：是否会被多个模块依赖</li>
<li><strong>变化频率</strong>：是否频繁随业务调整</li>
</ul>
<hr>
<h3 id="合理的拆分原则"><a href="#合理的拆分原则" class="headerlink" title="合理的拆分原则"></a>合理的拆分原则</h3><ul>
<li><strong>稳定、通用、可复用的内容</strong><br> → 适合拆为 Maven Module（如 common、pojo）</li>
<li><strong>强耦合、变化频繁的业务逻辑</strong><br> → 更适合作为 package 层次存在（controller &#x2F; service &#x2F; mapper）</li>
</ul>
<p>这一认知也解释了为什么教学案例会选择将 MVC 分层整合在 server 模块中。</p>
<hr>
<h2 id="五、项目搭建：从“能跑”到“规范”"><a href="#五、项目搭建：从“能跑”到“规范”" class="headerlink" title="五、项目搭建：从“能跑”到“规范”"></a>五、项目搭建：从“能跑”到“规范”</h2><p>在统一思路后，我按照案例的工程结构重新搭建了项目，形成了如下多模块 Maven 项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend-catering-management-system</span><br><span class="line">├── common</span><br><span class="line">├── pojo</span><br><span class="line">├── server</span><br><span class="line">└── pom.xml</span><br></pre></td></tr></table></figure>

<h3 id="父工程的角色"><a href="#父工程的角色" class="headerlink" title="父工程的角色"></a>父工程的角色</h3><p>父工程（parent pom）主要职责是：</p>
<ul>
<li>统一管理依赖版本</li>
<li>统一插件配置</li>
<li>管理子模块（Aggregator）</li>
</ul>
<p>在这一过程中，我遇到了一个典型的 Maven 报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aggregator projects require &#x27;pom&#x27; as packaging</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="问题与结论"><a href="#问题与结论" class="headerlink" title="问题与结论"></a>问题与结论</h3><p>通过该问题明确了一个关键规则：</p>
<ul>
<li><strong>聚合父工程的 packaging 必须是 <code>pom</code></strong></li>
<li>父工程不参与业务代码编译</li>
<li><strong>只有子模块才是 <code>jar</code></strong></li>
</ul>
<p>这一细节也进一步加深了我对 Maven 多模块项目结构的理解。</p>
<hr>
<h2 id="六、阶段性总结"><a href="#六、阶段性总结" class="headerlink" title="六、阶段性总结"></a>六、阶段性总结</h2><p>通过从系统结构图到项目搭建的完整过程，我对后端工程结构有了更清晰的认识：</p>
<ul>
<li>项目结构不能自由发挥，一切为了方便开发为主</li>
<li>复杂的结构并不一定带来更好的工程效果</li>
<li><strong>知道“为什么不这么拆”，比“我能拆得多细”更重要</strong></li>
</ul>
<hr>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/13/backend/project/2026-1-13-project-day01/" data-id="cmkkn3hbm004ygw8t5lhuahiv" data-title="项目结构搭建：从系统结构图到多模块 Maven 项目设计" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/maven/" rel="tag">maven</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-backend/ssm/springboot/2026-1-11-springboot-day03 " class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T16:00:00.000Z" itemprop="datePublished">2026-01-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/">Spring Boot 配置与测试实战复盘</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文基于一次完整的学习与踩坑过程，系统复盘 <strong>配置绑定、宽松绑定、属性校验、测试配置覆盖、Web 测试</strong> 等关键机制，重点回答一个问题：<br> <strong>Spring Boot 为什么要这样设计？我在工程中应该如何正确使用？</strong></p>
</blockquote>
<h2 id="一、Spring-Boot-热部署的本质：不是“热更新”，而是-ClassLoader-重启"><a href="#一、Spring-Boot-热部署的本质：不是“热更新”，而是-ClassLoader-重启" class="headerlink" title="一、Spring Boot 热部署的本质：不是“热更新”，而是 ClassLoader 重启"></a>一、Spring Boot 热部署的本质：不是“热更新”，而是 ClassLoader 重启</h2><p>在传统 Java Web 项目中，热部署通常由外置 Web 容器完成；<br>而 Spring Boot 采用 <strong>内嵌容器</strong>，服务器本身运行在 Spring 容器中，因此热部署的实现方式完全不同。</p>
<h3 id="devtools-的核心原理"><a href="#devtools-的核心原理" class="headerlink" title="devtools 的核心原理"></a>devtools 的核心原理</h3><p>Spring Boot 的热部署依赖 <code>spring-boot-devtools</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>其核心并不是 JVM 层面的“代码热替换”，而是 <strong>类加载器分层重启</strong>：</p>
<ul>
<li><strong>base ClassLoader</strong>：加载第三方依赖（jar 包），只加载一次</li>
<li><strong>restart ClassLoader</strong>：加载业务代码，修改后可重新加载</li>
</ul>
<p>热部署的本质是：<strong>重启 restart ClassLoader，而不是整个 JVM</strong>。</p>
<h3 id="为什么线上环境必须关闭热部署？"><a href="#为什么线上环境必须关闭热部署？" class="headerlink" title="为什么线上环境必须关闭热部署？"></a>为什么线上环境必须关闭热部署？</h3><ul>
<li>ClassLoader 重启可能带来状态不一致</li>
<li>与线上稳定性目标冲突</li>
<li>devtools 本身只服务于开发阶段</li>
<li>额外的开销，线上改不了源码，所以也不会启动热部署</li>
</ul>
<p>因此，<strong>热部署是开发工具</strong>。</p>
<hr>
<h2 id="二、-ConfigurationProperties：配置绑定的正确方式"><a href="#二、-ConfigurationProperties：配置绑定的正确方式" class="headerlink" title="二、@ConfigurationProperties：配置绑定的正确方式"></a>二、@ConfigurationProperties：配置绑定的正确方式</h2><h3 id="为什么不推荐大量使用-Value？"><a href="#为什么不推荐大量使用-Value？" class="headerlink" title="为什么不推荐大量使用 @Value？"></a>为什么不推荐大量使用 @Value？</h3><p><code>@Value</code> 属于“点对点注入”，在配置复杂时会带来问题：</p>
<ul>
<li>类型不安全</li>
<li>分散、不可维护</li>
<li>无法集中校验</li>
</ul>
<p>相比之下，<code>@ConfigurationProperties</code> 提供了 <strong>结构化配置绑定</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">servers:</span><br><span class="line">  ip-address: 192.168.0.1</span><br><span class="line">  port: 2345</span><br><span class="line">  timeout: 3h</span><br><span class="line"></span><br><span class="line">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="line">public class ServerConfig &#123;</span><br><span class="line">    private String ipAddress;</span><br><span class="line">    private int port;</span><br><span class="line">    private Duration timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、宽松绑定-≠-配置名可以随便写（第一个踩坑点）"><a href="#三、宽松绑定-≠-配置名可以随便写（第一个踩坑点）" class="headerlink" title="三、宽松绑定 ≠ 配置名可以随便写（第一个踩坑点）"></a>三、宽松绑定 ≠ 配置名可以随便写（第一个踩坑点）</h2><h3 id="我最初的误解"><a href="#我最初的误解" class="headerlink" title="我最初的误解"></a>我最初的误解</h3><blockquote>
<p>Spring Boot 配置支持宽松绑定，忽略大小写、中划线、下划线<br> 那是不是 <code>dataSource</code>、<code>data_source</code>、<code>data-source</code> 都可以？</p>
</blockquote>
<h3 id="实际踩坑现象"><a href="#实际踩坑现象" class="headerlink" title="实际踩坑现象"></a>实际踩坑现象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dataSource:</span><br><span class="line">  url: jdbc:mysql://...</span><br></pre></td></tr></table></figure>

<p>启动时报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Configuration property name &#x27;dataSource&#x27; is not valid</span><br><span class="line">Canonical names should be kebab-case</span><br></pre></td></tr></table></figure>

<h3 id="3-3-正确理解（非常重要）"><a href="#3-3-正确理解（非常重要）" class="headerlink" title="3.3 正确理解（非常重要）"></a>3.3 正确理解（非常重要）</h3><ul>
<li><strong>宽松绑定发生在：配置项 → Java 字段</strong></li>
<li><strong>但配置 key 本身必须是合法的 canonical 名称</strong></li>
</ul>
<p>正确写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  url: ...</span><br></pre></td></tr></table></figure>

<p>或官方标准写法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>宽松绑定解决的是“如何映射”，不是“命名是否合法”。</p>
</blockquote>
<hr>
<h2 id="四、-Validated-是一把“双刃剑”（第二个踩坑点）"><a href="#四、-Validated-是一把“双刃剑”（第二个踩坑点）" class="headerlink" title="四、@Validated 是一把“双刃剑”（第二个踩坑点）"></a>四、@Validated 是一把“双刃剑”（第二个踩坑点）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;servers&quot;)</span><br><span class="line">@Validated</span><br><span class="line">public class ServerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Min(1)</span><br><span class="line">    @Max(1234)</span><br><span class="line">    private int port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在生产环境中的价值"><a href="#在生产环境中的价值" class="headerlink" title="在生产环境中的价值"></a>在生产环境中的价值</h3><ul>
<li>配置非法 → 容器启动失败</li>
<li>fail-fast，避免线上事故</li>
<li>非常符合工程安全性要求</li>
</ul>
<h3 id="在测试环境中被“反杀”"><a href="#在测试环境中被“反杀”" class="headerlink" title="在测试环境中被“反杀”"></a>在测试环境中被“反杀”</h3><p>测试中尝试覆盖配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(properties = &#123;</span><br><span class="line">    &quot;servers.port=8888&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>结果直接启动失败：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConstraintViolationException</span><br></pre></td></tr></table></figure>

<p>原因：<br> <strong>8888 超出了 @Max(1234)</strong></p>
<h3 id="正确的工程姿势"><a href="#正确的工程姿势" class="headerlink" title="正确的工程姿势"></a>正确的工程姿势</h3><ul>
<li><strong>测试只覆盖 <code>servers.port</code>（Web 端口）</strong></li>
<li>业务配置仍使用合法值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest(properties = &#123;</span><br><span class="line">    &quot;servers.port=8888&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>测试不是绕过校验，而是在合法范围内模拟不同环境。</strong></p>
</blockquote>
<hr>
<h2 id="六、Web-层测试：为什么我选择-MockMvc"><a href="#六、Web-层测试：为什么我选择-MockMvc" class="headerlink" title="六、Web 层测试：为什么我选择 MockMvc"></a>六、Web 层测试：为什么我选择 MockMvc</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootTest</span><br><span class="line">@AutoConfigureMockMvc</span><br><span class="line">class WebTest &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="MockMvc-的优势"><a href="#MockMvc-的优势" class="headerlink" title="MockMvc 的优势"></a>MockMvc 的优势</h3><ul>
<li>不需要真实端口</li>
<li>不依赖网络</li>
<li>执行速度快</li>
<li>适合 CI &#x2F; 自动化测试</li>
</ul>
<h3 id="JSON-断言的工程选择"><a href="#JSON-断言的工程选择" class="headerlink" title="JSON 断言的工程选择"></a>JSON 断言的工程选择</h3><ul>
<li>接口稳定：<code>content().json()</code></li>
<li>接口可能演进：<code>jsonPath()</code></li>
</ul>
<hr>
<h2 id="七、我从这次-Spring-Boot-学习中总结的经验"><a href="#七、我从这次-Spring-Boot-学习中总结的经验" class="headerlink" title="七、我从这次 Spring Boot 学习中总结的经验"></a>七、我从这次 Spring Boot 学习中总结的经验</h2><ol>
<li><strong>配置名是否合法，比是否能绑定更早发生</strong></li>
<li>宽松绑定只解决映射问题，不解决命名问题</li>
<li><code>@Validated</code> 是 fail-fast，不是调试工具</li>
<li>测试配置覆盖必须遵守业务约束</li>
<li>Web 测试优先 MockMvc，而不是启动真实端口</li>
</ol>
<h2 id="学习资料与完整代码"><a href="#学习资料与完整代码" class="headerlink" title="学习资料与完整代码"></a>学习资料与完整代码</h2><p><strong>已整理并上传至 GitHub 仓库</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/13/backend/ssm/springboot/2026-1-11-springboot-day03%20/" data-id="cmkkn3hbp005hgw8t32jkfzon" data-title="Spring Boot 配置与测试实战复盘" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/" class="article-date">
  <time class="dt-published" datetime="2026-01-12T06:30:00.000Z" itemprop="datePublished">2026-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/">从回溯到记忆化搜索到递推：动态规划巩固练习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>今天的练习并不是学习新的 DP 模板，而是<strong>围绕两个最经典的模型：打家劫舍 与 爬楼梯，去做“变形题”的识别与迁移</strong>。</p>
<p>通过这一组题目的训练，我逐渐体会到：</p>
<p>动态规划的关键不在于记公式，而在于识别“本质模型”，并主动把陌生题目转化为熟悉结构。</p>
</blockquote>
<p><strong>基础题目</strong>：198. 打家劫舍</p>
<p><strong>打家劫舍模型变形</strong></p>
<ul>
<li><strong>740. 删除并获得点数</strong></li>
</ul>
<p><strong>爬楼梯模型变形（方案数）</strong></p>
<ul>
<li><strong>2466. 统计构造好字符串的方案数</strong></li>
<li><strong>377. 组合总和 Ⅳ</strong></li>
<li><strong>2266. 统计打字方案数</strong></li>
</ul>
<p><strong>经典二维 DP</strong></p>
<ul>
<li><strong>64. 最小路径和</strong></li>
</ul>
<hr>
<h2 id="核心模型回顾"><a href="#核心模型回顾" class="headerlink" title="核心模型回顾"></a>核心模型回顾</h2><p>在进入具体题目之前，先明确两个核心模型的“<strong>本质约束</strong>”。</p>
<h3 id="1-打家劫舍模型的本质"><a href="#1-打家劫舍模型的本质" class="headerlink" title="1. 打家劫舍模型的本质"></a>1. 打家劫舍模型的本质</h3><ul>
<li>每个元素都有「选 &#x2F; 不选」两种状态</li>
<li><strong>一旦选择某个元素，就会限制相邻元素不能被选择</strong></li>
<li>状态转移通常是：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = max(dp[i - 1], dp[i - 2] + value[i])</span><br></pre></td></tr></table></figure>

<p>重点不在“房子”，而在<strong>相邻约束</strong></p>
<hr>
<h3 id="2-爬楼梯模型的本质"><a href="#2-爬楼梯模型的本质" class="headerlink" title="2. 爬楼梯模型的本质"></a>2. 爬楼梯模型的本质</h3><ul>
<li>本质是一个<strong>排列问题</strong></li>
<li><strong>顺序不同 &#x3D; 不同方案</strong></li>
<li>给定一个目标值 <code>target</code></li>
<li>每一步可以选择若干“步长”，问总方案数</li>
</ul>
<p>只要是：</p>
<ul>
<li>「目标值固定」</li>
<li>「每一步可以选择若干选项」</li>
<li>「顺序敏感」</li>
</ul>
<p>都可以往爬楼梯模型上靠</p>
<hr>
<h2 id="结合具体题目分析"><a href="#结合具体题目分析" class="headerlink" title="结合具体题目分析"></a>结合具体题目分析</h2><h3 id="740-删除并获得点数-——-打家劫舍的值域改造"><a href="#740-删除并获得点数-——-打家劫舍的值域改造" class="headerlink" title="740. 删除并获得点数 —— 打家劫舍的值域改造"></a>740. 删除并获得点数 —— 打家劫舍的值域改造</h3><p><strong>题意简述</strong>：<br> 选择一个数 <code>nums[i]</code>，可以获得 <code>nums[i]</code> 的点数，但会删除所有值为 <code>nums[i] - 1</code> 和 <code>nums[i] + 1</code> 的元素。</p>
<h4 id="思路转化"><a href="#思路转化" class="headerlink" title="思路转化"></a>思路转化</h4><p>这道题的难点在于：</p>
<ul>
<li>原数组中，相同数字可能出现多次</li>
<li>删除的是“值相邻”，而不是“位置相邻”</li>
</ul>
<p><strong>关键一步：构造打家劫舍的条件</strong></p>
<p>将数组转为<strong>值域数组</strong></p>
<ul>
<li><code>sums[x]</code>：表示值为 <code>x</code> 的所有元素之和</li>
<li>例如：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [2,2,3,3,3,4]</span><br><span class="line">sums = [0,0,4,9,4]</span><br></pre></td></tr></table></figure>

<p>此时问题变成：</p>
<blockquote>
<p>在 <code>sums</code> 数组中，选择若干不相邻的元素，使得总和最大</p>
</blockquote>
<p><strong>完全等价于打家劫舍</strong></p>
<hr>
<h3 id="2466-统计构造好字符串的方案数-——-爬楼梯模型"><a href="#2466-统计构造好字符串的方案数-——-爬楼梯模型" class="headerlink" title="2466. 统计构造好字符串的方案数 —— 爬楼梯模型"></a>2466. 统计构造好字符串的方案数 —— 爬楼梯模型</h3><p>这道题表面是字符串问题，但本质非常清晰：</p>
<ul>
<li>当前字符串长度 &#x3D; 已爬的台阶数</li>
<li>每一步可以：<ul>
<li>增加 <code>zero</code> 个字符</li>
<li>或增加 <code>one</code> 个字符</li>
</ul>
</li>
<li>问：长度在 <code>[low, high]</code> 区间内的方案总数</li>
</ul>
<p><strong>这是标准的爬楼梯模型</strong></p>
<ul>
<li><code>dp[i]</code>：构造长度为 <code>i</code> 的方案数</li>
<li>每次从 <code>i - zero</code> 或 <code>i - one</code> 转移而来</li>
</ul>
<hr>
<h3 id="377-组合总和-Ⅳ-——-爬楼梯-顺序敏感"><a href="#377-组合总和-Ⅳ-——-爬楼梯-顺序敏感" class="headerlink" title="377. 组合总和 Ⅳ —— 爬楼梯 + 顺序敏感"></a>377. 组合总和 Ⅳ —— 爬楼梯 + 顺序敏感</h3><p>这道题非常具有代表性：</p>
<ul>
<li>给定 <code>nums</code></li>
<li>目标和 <code>target</code></li>
<li><strong>不同顺序算不同方案</strong></li>
</ul>
<h4 id="本质理解"><a href="#本质理解" class="headerlink" title="本质理解"></a>本质理解</h4><p>可以这样理解：</p>
<blockquote>
<p>爬 <code>target</code> 阶楼梯<br> 每次可以爬 <code>nums[i]</code> 阶<br> 问一共有多少种爬法</p>
</blockquote>
<p>顺序不同 → 不同路径</p>
<hr>
<h3 id="2266-统计打字方案数-——-分组-爬楼梯"><a href="#2266-统计打字方案数-——-分组-爬楼梯" class="headerlink" title="2266. 统计打字方案数 —— 分组 + 爬楼梯"></a>2266. 统计打字方案数 —— 分组 + 爬楼梯</h3><p>这道题本身规则较复杂，但从 DP 角度可以拆解为：</p>
<ol>
<li><strong>按连续相同数字分组</strong></li>
<li>每一组内部：<ul>
<li>是一个「爬楼梯问题」</li>
<li>不同按键允许的最大步长不同</li>
</ul>
</li>
<li><strong>最终答案 &#x3D; 各组方案数相乘</strong></li>
</ol>
<p>这是一个非常典型的：</p>
<blockquote>
<p><strong>局部 DP + 全局组合</strong></p>
</blockquote>
<hr>
<h3 id="64-最小路径和-——-经典二维-DP"><a href="#64-最小路径和-——-经典二维-DP" class="headerlink" title="64. 最小路径和 —— 经典二维 DP"></a>64. 最小路径和 —— 经典二维 DP</h3><p>这是标准的网格 DP：</p>
<ul>
<li><code>dp[i][j]</code> 表示到 <code>(i, j)</code> 的最小路径和</li>
<li>当前状态只依赖：<ul>
<li>上方 <code>(i - 1, j)</code></li>
<li>左方 <code>(i, j - 1)</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]</span><br></pre></td></tr></table></figure>

<p>没有变形，但非常适合作为 DP 基础模板反复巩固</p>
<hr>
<h2 id="心得与方法论总结"><a href="#心得与方法论总结" class="headerlink" title="心得与方法论总结"></a>心得与方法论总结</h2><h3 id="1-打家劫舍-≠-偷房子"><a href="#1-打家劫舍-≠-偷房子" class="headerlink" title="1. 打家劫舍 ≠ 偷房子"></a>1. 打家劫舍 ≠ 偷房子</h3><p>打家劫舍的真正核心是：</p>
<blockquote>
<p><strong>选择一个元素，会导致“相邻状态失效”</strong></p>
</blockquote>
<ul>
<li>740 题中，相邻的是「值」</li>
<li>所以我们主动<strong>构造值域数组</strong>，人为制造相邻关系</li>
</ul>
<p><strong>没有条件，就创造条件</strong></p>
<hr>
<h3 id="2-爬楼梯-顺序敏感的方案计数"><a href="#2-爬楼梯-顺序敏感的方案计数" class="headerlink" title="2. 爬楼梯 &#x3D; 顺序敏感的方案计数"></a>2. 爬楼梯 &#x3D; 顺序敏感的方案计数</h3><p>爬楼梯模型特别适合解决：</p>
<ul>
<li>方案数问题</li>
<li>和 &#x2F; 长度固定的问题</li>
<li>顺序不同算不同的情况</li>
</ul>
<p>例如：</p>
<ul>
<li>字符串构造</li>
<li>数字组合</li>
<li>步数累加</li>
</ul>
<p>把「目标值」当成台阶数，把「选择」当成一步能走的距离</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过今天这一组题目的训练，我对动态规划有了一个更重要的认知转变：</p>
<blockquote>
<p><strong>DP 的关键不是记住状态转移方程，而是识别题目的“原型模型”。</strong></p>
</blockquote>
<ul>
<li>看到「相邻不能同时选」 → 想打家劫舍</li>
<li>看到「目标固定 + 多种选择 + 顺序敏感」 → 想爬楼梯</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/12/algorithms/dynamicprogramming/2026-1-12-dynamicprogramming-practice/" data-id="cmkkn3has0012gw8tg15l6uke" data-title="从回溯到记忆化搜索到递推：动态规划巩固练习" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/dynamicprogramming/2026-1-11-dynamicprogramming" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/" class="article-date">
  <time class="dt-published" datetime="2026-01-11T05:30:00.000Z" itemprop="datePublished">2026-01-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/">动态规划：从回溯到记忆化搜索，再到递推</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><strong>核心思想</strong>：当前状态的最优解，来源于之前状态的最优解</p>
</blockquote>
<p><strong>基础题目</strong>：198. 打家劫舍</p>
<p><strong>扩展题目</strong>：</p>
<ul>
<li>爬楼梯</li>
<li>使用最小花费爬楼梯</li>
<li>爬楼梯 II</li>
<li>打家劫舍 II</li>
</ul>
<hr>
<h2 id="一、什么是动态规划？"><a href="#一、什么是动态规划？" class="headerlink" title="一、什么是动态规划？"></a>一、什么是动态规划？</h2><p>很多人第一次接触动态规划，都会被「状态转移方程」劝退。但实际上，<strong>动态规划并不是一种“新算法”，而是回溯的一种系统性优化</strong>。</p>
<blockquote>
<p>动态规划 &#x3D; 回溯 + 去重 + 自底向上</p>
</blockquote>
<p>理解动态规划，最自然的一条路径是：</p>
<blockquote>
<p><strong>回溯 → 记忆化搜索 → 递推（DP）</strong></p>
</blockquote>
<p>下面我们通过「打家劫舍」这个经典问题，完整走一遍这条路径。</p>
<hr>
<h2 id="二、从回溯开始：暴力-DFS-的本质"><a href="#二、从回溯开始：暴力-DFS-的本质" class="headerlink" title="二、从回溯开始：暴力 DFS 的本质"></a>二、从回溯开始：暴力 DFS 的本质</h2><p>以 <strong>198. 打家劫舍</strong> 为例：</p>
<ul>
<li>每一间房子：<strong>选 or 不选</strong></li>
<li>不能选相邻的房子</li>
</ul>
<p>我们从“最后一个房子”开始思考，定义：</p>
<blockquote>
<p><strong>dfs(i)</strong>：考虑前 <code>i</code> 个房子，能偷到的最大金额</p>
</blockquote>
<p>那么对于第 <code>i</code> 个房子：</p>
<ul>
<li>不偷：最大金额 &#x3D; <code>dfs(i - 1)</code></li>
<li>偷：最大金额 &#x3D; <code>dfs(i - 2) + nums[i]</code></li>
</ul>
<p>得到递归公式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs(i) = max(dfs(i - 1), dfs(i - 2) + nums[i])</span><br></pre></td></tr></table></figure>

<p>但问题也随之而来：<strong>大量重复计算</strong>。</p>
<p><img src="/assets/1.png" alt="1"></p>
<p>可以看到：</p>
<ul>
<li><code>dfs(2)</code> 被计算了多次</li>
<li><code>dfs(1)</code> 被计算了更多次</li>
</ul>
<p>这正是 <strong>动态规划要解决的核心问题：重复子问题</strong></p>
<hr>
<h2 id="三、记忆化搜索：给回溯加“缓存”"><a href="#三、记忆化搜索：给回溯加“缓存”" class="headerlink" title="三、记忆化搜索：给回溯加“缓存”"></a>三、记忆化搜索：给回溯加“缓存”</h2><p>回溯的问题不在于“递归”，而在于 <strong>重复递归</strong>。</p>
<p>解决方法也很直接：</p>
<blockquote>
<p><strong>算过的结果，存下来，下次直接用</strong></p>
</blockquote>
<p>这就是 <strong>记忆化搜索（Memoization）</strong>。</p>
<h3 id="Java-示例"><a href="#Java-示例" class="headerlink" title="Java 示例"></a>Java 示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int dfs(int i, int[] nums, int[] cache) &#123;</span><br><span class="line">    if (i &lt; 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cache[i] != -1) &#123;</span><br><span class="line">    	// 之前计算过,直接返回</span><br><span class="line">        return cache[i];</span><br><span class="line">    &#125;</span><br><span class="line">    // 之前没算过，将当前结果缓存</span><br><span class="line">    cache[i] = Math.max(</span><br><span class="line">        dfs(i - 1, nums, cache),</span><br><span class="line">        dfs(i - 2, nums, cache) + nums[i]</span><br><span class="line">    );</span><br><span class="line">    return cache[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时：</p>
<ul>
<li>时间复杂度：从指数级 ➜ <strong>O(n)</strong></li>
<li>但仍然有：<ul>
<li>递归栈空间</li>
<li>cache 数组空间</li>
</ul>
</li>
</ul>
<p>接下来就是最后一步优化空间复杂度：<strong>递推</strong></p>
<hr>
<h2 id="四、从记忆化搜索到递推（真正的-DP）"><a href="#四、从记忆化搜索到递推（真正的-DP）" class="headerlink" title="四、从记忆化搜索到递推（真正的 DP）"></a>四、从记忆化搜索到递推（真正的 DP）</h2><p>观察记忆化搜索中的递归关系：</p>
<ul>
<li><code>dfs(2)</code> 依赖 <code>dfs(1)</code> 和 <code>dfs(0)</code></li>
<li><code>dfs(3)</code> 依赖 <code>dfs(2)</code> 和 <code>dfs(1)</code></li>
<li>……</li>
</ul>
<p>这说明：</p>
<blockquote>
<p><strong>状态之间的依赖顺序是确定的</strong></p>
</blockquote>
<p>既然如此，我们完全可以：</p>
<ul>
<li>不再“递”</li>
<li>只保留“归”</li>
<li><strong>从小到大计算每一个状态</strong></li>
</ul>
<h3 id="递推（DP）的三要素"><a href="#递推（DP）的三要素" class="headerlink" title="递推（DP）的三要素"></a>递推（DP）的三要素</h3><p>从记忆化搜索到递推，本质上完成了三件事：</p>
<ol>
<li><strong>状态数组（dp）</strong>：<code>dp[i]</code> 记录 <code>dfs(i)</code> 的结果</li>
<li><strong>循环代替递归</strong>：从 <code>i = 0</code> 推到 <code>n</code></li>
<li><strong>初始化代替递归边界</strong>：<code>dp[0]</code>、<code>dp[1]</code> 对应原来的递归边界</li>
</ol>
<h3 id="为什么叫“递推”？"><a href="#为什么叫“递推”？" class="headerlink" title="为什么叫“递推”？"></a>为什么叫“递推”？</h3><blockquote>
<p>因为当前状态是 <strong>由之前状态推导出来的</strong></p>
</blockquote>
<p>在打家劫舍中：</p>
<ul>
<li>偷到第 <code>i</code> 间房子的最大金额<br> <strong>不是只由第 <code>i</code> 间房子决定的</strong></li>
<li>而是由：<ul>
<li>第 <code>i-1</code> 间房子的最优解</li>
<li>第 <code>i-2</code> 间房子的最优解<br> 共同决定</li>
</ul>
</li>
</ul>
<p>这正是动态规划中最核心的结构：</p>
<blockquote>
<p><strong>最优子结构</strong></p>
</blockquote>
<hr>
<h2 id="五、空间优化：从-O-n-到-O-1"><a href="#五、空间优化：从-O-n-到-O-1" class="headerlink" title="五、空间优化：从 O(n) 到 O(1)"></a>五、空间优化：从 O(n) 到 O(1)</h2><p>在打家劫舍中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] 只依赖 dp[i-1] 和 dp[i-2]</span><br></pre></td></tr></table></figure>

<p>因此：</p>
<ul>
<li>不需要完整 dp 数组</li>
<li>只需要保存「前两个状态」</li>
</ul>
<p> 空间复杂度可进一步优化为 <strong>O(1)</strong></p>
<hr>
<h2 id="六、结合具体题目总结-DP-模型"><a href="#六、结合具体题目总结-DP-模型" class="headerlink" title="六、结合具体题目总结 DP 模型"></a>六、结合具体题目总结 DP 模型</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h3><ul>
<li><strong>状态定义</strong>：<code>dp[i]</code> &#x3D; 爬到第 i 阶的方法数</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化</strong>：<ul>
<li><code>dp[0] = 1</code></li>
<li><code>dp[1] = 1</code></li>
</ul>
</li>
<li><strong>答案</strong>：<code>dp[n]</code></li>
</ul>
<p>本质：<strong>斐波那契数列</strong></p>
<hr>
<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h3><ul>
<li><strong>状态定义</strong>：<code>dp[i]</code> &#x3D; 到达第 i 阶的最小花费</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i - 1] + cost[i - 1],</span><br><span class="line">            dp[i - 2] + cost[i - 2])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>初始化</strong>：<ul>
<li><code>dp[0] = 0</code></li>
<li><code>dp[1] = 0</code></li>
</ul>
</li>
<li><strong>答案</strong>：<code>dp[n]</code></li>
</ul>
<p>特点： <strong>不是计数，而是最小值优化</strong></p>
<hr>
<h3 id="3693-爬楼梯-II"><a href="#3693-爬楼梯-II" class="headerlink" title="3693. 爬楼梯 II"></a>3693. 爬楼梯 II</h3><ul>
<li>一次可以跳 <strong>1 &#x2F; 2 &#x2F; 3</strong> 阶</li>
<li><strong>递推公式</strong>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]</span><br></pre></td></tr></table></figure>

<p>本质变化只有：</p>
<blockquote>
<p><strong>当前状态依赖的“历史状态数量”变多了</strong>，计算 cost 的方式不同了</p>
</blockquote>
<hr>
<h3 id="213-打家劫舍-II（环形）"><a href="#213-打家劫舍-II（环形）" class="headerlink" title="213. 打家劫舍 II（环形）"></a>213. 打家劫舍 II（环形）</h3><p>核心难点：</p>
<blockquote>
<p><strong>首尾不能同时选</strong></p>
</blockquote>
<p>经典处理方式：</p>
<ul>
<li>情况一：不偷第 0 间 ➜ 偷 <code>[1 … n-1]</code></li>
<li>情况二：不偷第 n-1 间 ➜ 偷 <code>[0 … n-2]</code></li>
<li>对两种情况分别做 <strong>198 打家劫舍</strong></li>
<li>取最大值</li>
</ul>
<p> <strong>环形 DP → 拆成两个线性 DP</strong></p>
<hr>
<h2 id="七、心得与方法论总结"><a href="#七、心得与方法论总结" class="headerlink" title="七、心得与方法论总结"></a>七、心得与方法论总结</h2><h3 id="动态规划到底“动”在哪？"><a href="#动态规划到底“动”在哪？" class="headerlink" title="动态规划到底“动”在哪？"></a>动态规划到底“动”在哪？</h3><ul>
<li>状态是变化的</li>
<li>当前状态来自之前状态</li>
<li>本质是 <strong>dfs 中的“归”</strong></li>
</ul>
<p>递推，其实就是：</p>
<blockquote>
<p><strong>省略 dfs 的“递”，只保留“归”</strong></p>
</blockquote>
<hr>
<h3 id="想不出递推公式怎么办？"><a href="#想不出递推公式怎么办？" class="headerlink" title="想不出递推公式怎么办？"></a>想不出递推公式怎么办？</h3><p>一个非常实用的技巧：</p>
<blockquote>
<p><strong>回退一步，用回溯 + 记忆化搜索先写出来</strong></p>
</blockquote>
<ul>
<li>回溯天然符合“选 or 不选”</li>
<li>递归公式写出来后</li>
<li>直接“翻译”为 dp 即可</li>
</ul>
<hr>
<h3 id="什么时候应该想到动态规划？"><a href="#什么时候应该想到动态规划？" class="headerlink" title="什么时候应该想到动态规划？"></a>什么时候应该想到动态规划？</h3><p>当题目满足以下特征之一时，<strong>高度警惕 DP</strong>：</p>
<ul>
<li>当前结果依赖之前的结果</li>
<li>有“最优”“最多”“最少”“方案数”等关键词</li>
<li>存在大量重复子问题</li>
<li>能清晰定义「状态」</li>
</ul>
<p>一句话总结：</p>
<blockquote>
<p><strong>只要当前状态是在之前状态的基础上演化而来，就可以尝试动态规划</strong></p>
</blockquote>
<hr>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>动态规划并不是死记模板，而是一种 <strong>从回溯中抽象出的系统性思维方式</strong>。<br>真正掌握 DP 的标志，不是会写状态转移方程，而是：</p>
<blockquote>
<p><strong>能从回溯自然地推导出递推</strong></p>
</blockquote>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/11/algorithms/dynamicprogramming/2026-1-11-dynamicprogramming/" data-id="cmkkn3hat0014gw8th05j98s2" data-title="动态规划：从回溯到记忆化搜索，再到递推" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-algorithms/backtracking/2026-1-10-Permutation-backtracking" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/" class="article-date">
  <time class="dt-published" datetime="2026-01-10T05:00:00.000Z" itemprop="datePublished">2026-01-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>►<a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/">排列型回溯</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>排列型回溯的本质是「<strong>每一层都可以从所有未使用的元素中重新选择</strong>」，顺序不同即视为不同答案，通常通过 <strong>used &#x2F; flag 数组</strong> 来记录当前路径中已使用的元素。</p>
</blockquote>
<hr>
<h2 id="一、什么是排列型回溯？"><a href="#一、什么是排列型回溯？" class="headerlink" title="一、什么是排列型回溯？"></a>一、什么是排列型回溯？</h2><p>在回溯问题中，<strong>排列型问题</strong>有一个非常鲜明的特征：</p>
<ul>
<li><strong>元素相同，但顺序不同，算作不同答案</strong></li>
<li>例如：<ul>
<li><code>[1, 2]</code> 和 <code>[2, 1]</code> 是 <strong>两个不同的解</strong></li>
</ul>
</li>
</ul>
<p>这与我们之前做过的两类问题形成了清晰对比：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>是否关心顺序</th>
<th>是否允许重复选</th>
</tr>
</thead>
<tbody><tr>
<td>子集型</td>
<td>❌ 不关心</td>
<td>每个元素只选 &#x2F; 不选</td>
</tr>
<tr>
<td>组合型</td>
<td>❌ 不关心</td>
<td>对于选或不选有约束条件</td>
</tr>
<tr>
<td><strong>排列型</strong></td>
<td>✅ 关心</td>
<td><strong>每一轮可选任意当前轮次未使用元素</strong></td>
</tr>
</tbody></table>
<hr>
<h2 id="二、排列型回溯的核心思想"><a href="#二、排列型回溯的核心思想" class="headerlink" title="二、排列型回溯的核心思想"></a>二、排列型回溯的核心思想</h2><p>从「<strong>枚举答案的角度</strong>」来看，排列型回溯有两个关键点：</p>
<h3 id="每一层都在“选位置”，而不是“选元素范围”"><a href="#每一层都在“选位置”，而不是“选元素范围”" class="headerlink" title="每一层都在“选位置”，而不是“选元素范围”"></a>每一层都在“选位置”，而不是“选元素范围”</h3><ul>
<li>第 0 位选谁？</li>
<li>第 1 位选谁？</li>
<li>第 2 位选谁？</li>
</ul>
<p>每一层都可以从 <strong>当前轮所有尚未使用的元素中选择</strong></p>
<hr>
<h3 id="必须显式记录「当前路径中已使用的元素」"><a href="#必须显式记录「当前路径中已使用的元素」" class="headerlink" title="必须显式记录「当前路径中已使用的元素」"></a>必须显式记录「当前路径中已使用的元素」</h3><p>因此，排列型回溯 <strong>一定需要</strong> 一个 <code>used / flag</code> 数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">used[i] = true  → nums[i] 已经在当前排列中使用过</span><br><span class="line">used[i] = false → 当前轮次仍可选择 nums[i]</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、基础题目分析"><a href="#三、基础题目分析" class="headerlink" title="三、基础题目分析"></a>三、基础题目分析</h2><h3 id="46-全排列（Permutations）"><a href="#46-全排列（Permutations）" class="headerlink" title="46. 全排列（Permutations）"></a>46. 全排列（Permutations）</h3><h4 id="问题特征"><a href="#问题特征" class="headerlink" title="问题特征"></a>问题特征</h4><ul>
<li>目标：生成数组的所有排列</li>
<li>终止条件：<strong>当前路径长度 &#x3D;&#x3D; nums.length</strong></li>
<li>每一层：从所有 <code>used[i] == false</code> 的元素中选一个</li>
</ul>
<hr>
<h4 id="核心实现思路"><a href="#核心实现思路" class="headerlink" title="核心实现思路"></a>核心实现思路</h4><ol>
<li>使用 <code>path</code> 记录当前排列</li>
<li>使用 <code>used[]</code> 标记哪些元素已被选</li>
<li>当 <code>path.size() == nums.length</code> 时，记录答案</li>
<li>回溯时恢复现场（<code>used[i] = false</code>）</li>
</ol>
<hr>
<h4 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h4><ul>
<li><strong>排列的深度 &#x3D; nums.length</strong></li>
<li><strong>叶子节点数量 &#x3D; n!</strong></li>
<li><code>used[]</code> 的作用是：<strong>保证每个元素在同一条路径中只出现一次</strong></li>
</ul>
<hr>
<h3 id="51-N-皇后（N-Queens）"><a href="#51-N-皇后（N-Queens）" class="headerlink" title="51. N 皇后（N-Queens）"></a>51. N 皇后（N-Queens）</h3><p>这是一个<strong>非常经典的“受限排列问题”</strong>。</p>
<hr>
<h4 id="问题拆解"><a href="#问题拆解" class="headerlink" title="问题拆解"></a>问题拆解</h4><ul>
<li>每一行只能放一个皇后</li>
<li>每一列只能放一个皇后</li>
<li>皇后不能在同一条对角线上</li>
</ul>
<hr>
<h4 id="建模方式（非常关键）"><a href="#建模方式（非常关键）" class="headerlink" title="建模方式（非常关键）"></a>建模方式（非常关键）</h4><p>用一个一维数组 <code>queens</code> 表示棋盘状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queens[row] = col</span><br></pre></td></tr></table></figure>

<p>含义是：</p>
<ul>
<li>第 <code>row</code> 行</li>
<li>第 <code>col</code> 列</li>
<li>放置了一个皇后</li>
</ul>
<hr>
<h4 id="为什么这是一个排列问题？"><a href="#为什么这是一个排列问题？" class="headerlink" title="为什么这是一个排列问题？"></a>为什么这是一个排列问题？</h4><ul>
<li>行天然不重复（递归层数保证）</li>
<li>列不能重复 → <code>queens</code> 本质是一个 <strong>列索引的全排列</strong></li>
<li>对角线限制 → 给这个全排列 <strong>增加合法性约束</strong></li>
</ul>
<hr>
<h4 id="对角线判断条件"><a href="#对角线判断条件" class="headerlink" title="对角线判断条件"></a>对角线判断条件</h4><p>若两个皇后在 <code>(r1, c1)</code> 和 <code>(r2, c2)</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|r1 - r2| == |c1 - c2| → 在同一对角线</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="本质总结"><a href="#本质总结" class="headerlink" title="本质总结"></a>本质总结</h4><blockquote>
<p><strong>N 皇后 &#x3D; 带约束条件的全排列问题</strong></p>
</blockquote>
<hr>
<h2 id="四、扩展题目"><a href="#四、扩展题目" class="headerlink" title="四、扩展题目"></a>四、扩展题目</h2><h3 id="357-统计各位数字都不同的数字个数"><a href="#357-统计各位数字都不同的数字个数" class="headerlink" title="357. 统计各位数字都不同的数字个数"></a>357. 统计各位数字都不同的数字个数</h3><p>这道题虽然形式不同，但本质仍然是：</p>
<ul>
<li>在每一位上选数字</li>
<li>同一个数字不能重复使用</li>
<li>位数不同，形成不同答案</li>
</ul>
<p>本质是 <strong>多层排列 + 剪枝计数</strong>，而不是生成具体排列。</p>
<hr>
<h2 id="五、排列型回溯的时间复杂度"><a href="#五、排列型回溯的时间复杂度" class="headerlink" title="五、排列型回溯的时间复杂度"></a>五、排列型回溯的时间复杂度</h2><p>排列问题的时间复杂度通常非常直观：</p>
<ul>
<li><p><strong>等于叶子节点数量</strong></p>
</li>
<li><p>对于 n 个元素的全排列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度 = O(n!) // 画树分析节点数量得到</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这是排列问题不可避免的代价，因此：</p>
<ul>
<li>剪枝尤为重要</li>
<li>约束条件越多，搜索空间越小</li>
</ul>
<hr>
<h2 id="六、心得体会与方法论总结"><a href="#六、心得体会与方法论总结" class="headerlink" title="六、心得体会与方法论总结"></a>六、心得体会与方法论总结</h2><h3 id="排列型回溯的固定模板"><a href="#排列型回溯的固定模板" class="headerlink" title="排列型回溯的固定模板"></a>排列型回溯的固定模板</h3><ol>
<li>路径长度固定（通常等于元素个数）</li>
<li>每一层从 <strong>所有未使用元素中选择</strong></li>
<li>使用 <code>used[] / flag[]</code> 记录使用状态</li>
<li>回溯时一定要 <strong>恢复现场</strong></li>
</ol>
<hr>
<h3 id="与前两类回溯的根本区别"><a href="#与前两类回溯的根本区别" class="headerlink" title="与前两类回溯的根本区别"></a>与前两类回溯的根本区别</h3><blockquote>
<p><strong>是否允许在下一层重新选择之前没选过的元素</strong></p>
</blockquote>
<ul>
<li>子集 &#x2F; 组合：「之前轮次选过，就不能再选」</li>
<li>排列：「只要当前路径没用过，就可以选」</li>
</ul>
<h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>本文涉及的所有代码与笔记，均已同步至我的 GitHub 算法仓库，作为 Java 后端校招过程中的学习记录。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2026/01/10/algorithms/backtracking/2026-1-10-Permutation-backtracking/" data-id="cmkkn3han000ggw8thwoa4jrn" data-title="排列型回溯" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MyBatis/">MyBatis</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MyBatis/ssm/">ssm</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%90%8E%E7%AB%AF/SpringBoot/">SpringBoot</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/%E9%80%92%E5%BD%92/">递归</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">动态规划</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/">回溯</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/">链表</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/01%E8%83%8C%E5%8C%85/" rel="tag">01背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LIS/" rel="tag">LIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedList/" rel="tag">LinkedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/" rel="tag">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL%E4%BC%98%E5%8C%96/" rel="tag">SQL优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring-MVC/" rel="tag">Spring MVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/druid/" rel="tag">druid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jdbc/" rel="tag">jdbc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/" rel="tag">maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis/" rel="tag">mybatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mybatis-plus/" rel="tag">mybatis-plus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/xml%E6%98%A0%E5%B0%84/" rel="tag">xml映射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag">事务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" rel="tag">事务原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F/" rel="tag">先序、中序、后序</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/" rel="tag">删除链表节点</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81mysql/" rel="tag">动态mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" rel="tag">反转链表</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%9E%E6%BA%AF/" rel="tag">回溯</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%90%E9%9B%86/" rel="tag">子集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" rel="tag">学习计划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" rel="tag">完全背包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" rel="tag">层序遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" rel="tag">快慢指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%88%97/" rel="tag">排列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" rel="tag">数据库锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/" rel="tag">时间复杂度优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" rel="tag">最近公共祖先</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag">测试</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" rel="tag">深度优先遍历</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" rel="tag">热部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/" rel="tag">由遍历序列生成二叉树</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag">索引</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%BF%E6%80%A7DP/" rel="tag">线性DP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E5%90%88/" rel="tag">组合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%86%E5%9B%BE/" rel="tag">视图</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" rel="tag">触发器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BD%95/" rel="tag">记录</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" rel="tag">记忆化搜索</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/01%E8%83%8C%E5%8C%85/" style="font-size: 10px;">01背包</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/LIS/" style="font-size: 12px;">LIS</a> <a href="/tags/LinkedList/" style="font-size: 10px;">LinkedList</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/SQL%E4%BC%98%E5%8C%96/" style="font-size: 10px;">SQL优化</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/Spring-MVC/" style="font-size: 10px;">Spring MVC</a> <a href="/tags/druid/" style="font-size: 10px;">druid</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/jdbc/" style="font-size: 12px;">jdbc</a> <a href="/tags/maven/" style="font-size: 12px;">maven</a> <a href="/tags/mybatis/" style="font-size: 16px;">mybatis</a> <a href="/tags/mybatis-plus/" style="font-size: 10px;">mybatis-plus</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/xml%E6%98%A0%E5%B0%84/" style="font-size: 10px;">xml映射</a> <a href="/tags/%E4%BA%8B%E5%8A%A1/" style="font-size: 10px;">事务</a> <a href="/tags/%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86/" style="font-size: 10px;">事务原理</a> <a href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 20px;">二叉树</a> <a href="/tags/%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F/" style="font-size: 12px;">先序、中序、后序</a> <a href="/tags/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9/" style="font-size: 10px;">删除链表节点</a> <a href="/tags/%E5%8A%A8%E6%80%81mysql/" style="font-size: 10px;">动态mysql</a> <a href="/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" style="font-size: 10px;">反转链表</a> <a href="/tags/%E5%9B%9E%E6%BA%AF/" style="font-size: 18px;">回溯</a> <a href="/tags/%E5%AD%90%E9%9B%86/" style="font-size: 12px;">子集</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 10px;">字符串</a> <a href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/" style="font-size: 10px;">学习计划</a> <a href="/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/" style="font-size: 10px;">完全背包</a> <a href="/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/" style="font-size: 10px;">层序遍历</a> <a href="/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/" style="font-size: 10px;">快慢指针</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 12px;">总结</a> <a href="/tags/%E6%8E%92%E5%88%97/" style="font-size: 10px;">排列</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/" style="font-size: 10px;">数据库锁</a> <a href="/tags/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%98%E5%8C%96/" style="font-size: 10px;">时间复杂度优化</a> <a href="/tags/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" style="font-size: 10px;">最近公共祖先</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" style="font-size: 10px;">测试</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/" style="font-size: 12px;">深度优先遍历</a> <a href="/tags/%E7%83%AD%E9%83%A8%E7%BD%B2/" style="font-size: 10px;">热部署</a> <a href="/tags/%E7%94%B1%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%94%9F%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91/" style="font-size: 10px;">由遍历序列生成二叉树</a> <a href="/tags/%E7%B4%A2%E5%BC%95/" style="font-size: 10px;">索引</a> <a href="/tags/%E7%BA%BF%E6%80%A7DP/" style="font-size: 14px;">线性DP</a> <a href="/tags/%E7%BB%84%E5%90%88/" style="font-size: 10px;">组合</a> <a href="/tags/%E8%A7%86%E5%9B%BE/" style="font-size: 10px;">视图</a> <a href="/tags/%E8%A7%A6%E5%8F%91%E5%99%A8/" style="font-size: 10px;">触发器</a> <a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 12px;">记录</a> <a href="/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/" style="font-size: 12px;">记忆化搜索</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 18px;">递归</a> <a href="/tags/%E9%80%92%E6%8E%A8/" style="font-size: 12px;">递推</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">配置</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2026/01/">一月 2026</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/12/">十二月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2026/01/19/algorithms/dynamicprogramming/2026-1-19-dynamicprogramming-04%E7%BA%BF%E6%80%A7DP%E6%80%BB%E7%BB%93/">线性 DP 总结与最长递增子序列（LIS）与二维扩展</a>
          </li>
        
          <li>
            <a href="/2026/01/18/algorithms/dynamicprogramming/2026-1-18-dynamicprogramming-03LIS/">线性 DP · 最长递增子序列（LIS）专题总结</a>
          </li>
        
          <li>
            <a href="/2026/01/15/algorithms/dynamicprogramming/2026-1-14-dynamicprogramming-02%E7%BA%BF%E6%80%A7DP/">线性 DP：字符串问题</a>
          </li>
        
          <li>
            <a href="/2026/01/14/misc/git-%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/">git 开发工具整理总结</a>
          </li>
        
          <li>
            <a href="/2026/01/13/algorithms/dynamicprogramming/2026-1-13-dynamicprogramming-01%E8%83%8C%E5%8C%85%E4%B8%8E%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/">DP 模型：从回溯语义到 0-1 背包与完全背包（2026-01-13）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2026 Tingfeng Li<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>